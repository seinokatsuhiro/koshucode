-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-data
@version 0.200.0.0


-- | Message list.
module Koshucode.Baala.Data.Decode.Message

-- | Abortable scope for literal.
abLiteral :: (GetCodePos cp) => Abortable cp b

-- | Nothing
nothing :: Ab a

-- | Missing pairing term
missPairTerm :: Ab a

-- | Odd relation literal
oddRelation :: Int -> Int -> Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require tuple in list
reqRelTuple :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown content
unkContent :: Ab a

-- | Unknown type name
unkType :: String -> Ab a

-- | Expect and actual.
expectActual :: String -> String -> [String]

-- | Expect (2 lines) and actual.
expect2Actual :: String -> String -> String -> [String]


-- | Decode terms.
module Koshucode.Baala.Data.Decode.Term

-- | Term name cache.
type CacheT = CacheS TermName

-- | Empty term name cache.
cacheT :: CacheT

-- | Read flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTree "/a" &gt;&gt;= treeFlatName
--   Right (TermName EQ "a")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.toTree "+/a" &gt;&gt;= treeFlatName
--   Right (TermName GT "a")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.toTree "/a/x" &gt;&gt;= treeFlatName
--   Left ...
--   </pre>
treeFlatName :: Tree -> Ab TermName

-- | Cached version of <a>treeFlatName</a>.
treeFlatNameCached :: CacheT -> Tree -> Ab (CacheT, TermName)

-- | Read flat term names.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "/a +/b -/c" &gt;&gt;= treesFlatNames
--   Right [TermName EQ "a",TermName GT "b",TermName LT "c"]
--   </pre>
treesFlatNames :: [Tree] -> Ab [TermName]

-- | Decode term names with optional complement symbol.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "~ /a /b" &gt;&gt;= treesFlatNamesCo
--   Right (True, [TermName EQ "a",TermName EQ "b"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "/a /b" &gt;&gt;= treesFlatNamesCo
--   Right (False, [TermName EQ "a",TermName EQ "b"])
--   </pre>
treesFlatNamesCo :: [Tree] -> Ab (Bool, [TermName])

-- | Decode a list of name-and-name pairs.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "/a /x /b /y" &gt;&gt;= treesFlatNamePairs
--   Right [(TermName EQ "a", TermName EQ "x"), (TermName EQ "b", TermName EQ "y")]
--   </pre>
treesFlatNamePairs :: [Tree] -> Ab [TermName2]

-- | Decode term names grouped by colons.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "/a /b : /p /q : /x /y" &gt;&gt;= treesNamesByColon
--   Right [ [TermName EQ "a", TermName EQ "b"]
--         , [TermName EQ "p", TermName EQ "q"]
--         , [TermName EQ "x", TermName EQ "y"] ]
--   </pre>
treesNamesByColon :: [Tree] -> Ab [[TermName]]

-- | Read list of named token trees from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "/a 'A3 /b 10" &gt;&gt;= treesTerms
--   Right [ (TermName EQ "a", [TreeL ...]),
--           (TermName EQ "b", [TreeL ...]) ]
--   </pre>
treesTerms :: [Tree] -> Ab [Term [Tree]]

-- | Cached version of <a>treesTerms</a>.
treesTermsCached :: CacheT -> [Tree] -> Ab (CacheT, [Term [Tree]])

-- | Read list of named token trees from token trees. This function wraps
--   long branches into group.
treesTerms1 :: [Tree] -> Ab [Term Tree]


-- | Decode specific-type contents.
module Koshucode.Baala.Data.Decode.Type

-- | Get single text from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "'aa 'bb" &gt;&gt;= treesTexts True
--   Right ["aa","bb"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "\"aa\" \"bb\"" &gt;&gt;= treesTexts True
--   Right ["aabb"]
--   </pre>
treesTexts :: Bool -> [Tree] -> Ab [String]

-- | Get interpretation from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "term /a" &gt;&gt;= treesInterp
--   Right (Interp { interpWords = [InterpText "term", InterpTerm "a"],
--                   interpTerms = ["a"] })
--   </pre>
treesInterp :: [Tree] -> Ab Interp

-- | Decode type content.
treesType :: [Tree] -> Ab Type


-- | Decode numeric contents.
module Koshucode.Baala.Data.Decode.Numeric

-- | Get digits from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "-123 450.00" &gt;&gt;= treesDigits
--   Right "-123450.00"
--   </pre>
treesDigits :: [Tree] -> Ab String

-- | Get clock from token.
--   
--   <pre>
--   &gt;&gt;&gt; tokenClock $ head $ S.toks "|12:00|"
--   Right |12:00|
--   </pre>
tokenClock :: Token -> Ab Clock

-- | Get time from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "2013-04-18 12:00" &gt;&gt;= treesTime
--   Right 2013-04-18 12:00
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "2013-04-18" &gt;&gt;= treesTime
--   Right 2013-04-18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.toTrees "2013-#16" &gt;&gt;= treesTime
--   Right 2013-#16
--   </pre>
treesTime :: [Tree] -> Ab Time

-- | Get time from string.
--   
--   <pre>
--   &gt;&gt;&gt; stringTime "2013-04-18 12:00"
--   Right 2013-04-18 12:00
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringTime "2013-04-18 12:00 +9:00" &gt;&gt;= (Right . T.timeCutZone)
--   Right 2013-04-18 03:00
--   </pre>
stringTime :: String -> Ab Time


-- | Message list.
module Koshucode.Baala.Data.Class.Message

-- | <ul>
--   <li><i>Type unmatch</i> Content = <i>C</i></li>
--   </ul>
typeUnmatched :: (MixEncode c) => c -> Ab a

-- | <ul>
--   <li><i>Bad argument</i> #1 = <i>C</i>, #2 = <i>C</i>, ...</li>
--   </ul>
badArg :: (MixEncode c) => [Ab c] -> Ab a

-- | <ul>
--   <li><i>Unexpected argument</i> Expect <i>E</i>, Actual <i>A</i></li>
--   </ul>
unexpArg :: (MixEncode c) => [Ab c] -> [String] -> Ab a

-- | <ul>
--   <li><i>Not a decimal</i> Content = <i>C</i></li>
--   </ul>
notDec :: (MixEncode c) => c -> Ab a


-- | Edge content types.
module Koshucode.Baala.Data.Class.Edge

-- | Basis of contents.
class (Eq c, Ord c, MixEncode c) => Basis c where isA c t = typeOf c == t sameType c1 c2 = typeOf c1 == typeOf c2

-- | Get type of content.
typeOf :: Basis c => c -> Type

-- | Test content is a some type.
isA :: Basis c => Test2 c Type

-- | Test two contents are same type.
sameType :: Basis c => Test2 c c

-- | Get content in calculation.
type GetContent b c = Ab c -> Ab b

-- | Get content which may be aborted.
getContent :: (Basis c) => Test c -> (c -> b) -> GetContent b c

-- | Empty: the minimum content.
class (Basis c) => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c

-- | Create empty or non-empty content.
--   
--   <pre>
--   &gt;&gt;&gt; maybeEmpty pText $ Just "foo" :: Content
--   ContentText "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeEmpty pText $ Nothing :: Content
--   ContentEmpty
--   </pre>
maybeEmpty :: (CEmpty c) => (a -> c) -> Maybe a -> c

-- | Maximum content of contents list. If argument is the empty list,
--   returns the <a>empty</a> content.
maxContents :: (CEmpty c) => [c] -> c

-- | List of empties.
--   
--   <pre>
--   &gt;&gt;&gt; empties 4 :: [Content]
--   [ContentEmpty, ContentEmpty, ContentEmpty, ContentEmpty]
--   </pre>
empties :: (CEmpty c) => Int -> [c]

-- | Cut empty terms.
cutEmpty :: (CEmpty c) => Map [Term c]

-- | End of everything: the maximum content.
class (Basis c) => CEnd c
isEnd :: CEnd c => c -> Bool
end :: CEnd c => c

-- | Minimum content of contents list. If argument is the empty list,
--   returns the <a>end</a> content.
minContents :: (CEnd c) => [c] -> c


-- | Simple content type.
module Koshucode.Baala.Data.Class.Simple

-- | True or false, affirmed or denied.
class (Basis c) => CBool c where getBool = getContent isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => GetContent Bool c
putBool :: CBool c => Bool -> Ab c

-- | Boolean constant true.
true :: (CBool c) => c

-- | Boolean constant false.
false :: (CBool c) => c

-- | Boolean constant true.
putTrue :: (CBool c) => Ab c

-- | Boolean constant false.
putFalse :: (CBool c) => Ab c

-- | Decimal number.
class (Basis c) => CDec c where getDec = getContent isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => GetContent Decimal c
putDec :: CDec c => Decimal -> Ab c

-- | Create decimal content.
--   
--   <pre>
--   &gt;&gt;&gt; pInt 15 :: Content
--   ContentDec Decimal (0) 15
--   </pre>
pInt :: (CDec c) => Int -> c

-- | Create decimal content.
pInteger :: (CDec c) => Integer -> c

-- | Create decimal content.
pIntegral :: (CDec c, Integral n) => n -> c

-- | Get rational number from decimal content.
gRational :: (CDec c) => c -> Rational

-- | Get truncated integer from decimal content.
gIntegral :: (CDec c, Integral n) => c -> n

-- | Get rational number from decimal content.
getRational :: (CDec c) => GetContent Rational c

-- | Get truncated integer from decimal content.
getIntegral :: (CDec c, Integral n) => GetContent n c

-- | Distance between two points in timeline.
class (Basis c) => CClock c where getClock = getContent isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => GetContent Clock c
putClock :: CClock c => Clock -> Ab c

-- | Point in timeline.
class (Basis c) => CTime c where getTime = getContent isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => GetContent Time c
putTime :: CTime c => Time -> Ab c

-- | Code.
class (Basis c) => CCode c where getCode = getContent isCode gCode putCode = Right . pCode
isCode :: CCode c => c -> Bool
gCode :: CCode c => c -> String
pCode :: CCode c => String -> c
getCode :: CCode c => GetContent String c
putCode :: CCode c => String -> Ab c

-- | Term name.
class (Basis c) => CTerm c where getTerm = getContent isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> TermName
pTerm :: CTerm c => TermName -> c
getTerm :: CTerm c => GetContent TermName c
putTerm :: CTerm c => TermName -> Ab c

-- | Double-quoted text content.
class (Basis c) => CText c where getText = getContent isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => GetContent String c
putText :: CText c => String -> Ab c

-- | Create text or empty content.
--   
--   <pre>
--   &gt;&gt;&gt; pMaybeText "a" :: Content
--   ContentText "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pMaybeText "" :: Content
--   ContentEmpty
--   </pre>
pMaybeText :: (CText c, CEmpty c) => String -> c

-- | Create text content from strict text.
pTx :: (CText c) => Text -> c

-- | Create text content from lazy text.
pTz :: (CText c) => Text -> c


-- | Complex content type.
module Koshucode.Baala.Data.Class.Complex

-- | List of contents.
class (Basis c) => CList c where getList = getContent isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => GetContent [c] c
putList :: CList c => [c] -> Ab c

-- | Create list of text contents.
pTextList :: (CText c, CList c) => [String] -> c

-- | Set of contents.
class (Basis c) => CSet c where getSet = getContent isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => GetContent [c] c
putSet :: CSet c => [c] -> Ab c

-- | Create set of term contents.
pTermSet :: (CTerm c, CSet c) => [TermName] -> c

-- | Create set of text contents.
pTextSet :: (CText c, CSet c) => [String] -> c

-- | Sorted version of <a>gSet</a>.
gSetSort :: (CSet c) => c -> [c]

-- | Test membership between element and collection contents.
isMember :: (CSet c, CList c) => c -> c -> Bool

-- | Tie of terms.
class (Basis c) => CTie c where getTie = getContent isTie gTie putTie = Right . pTie
isTie :: CTie c => c -> Bool
gTie :: CTie c => c -> [Term c]
pTie :: CTie c => [Term c] -> c
getTie :: CTie c => GetContent [Term c] c
putTie :: CTie c => [Term c] -> Ab c

-- | Relation of terms.
class (Basis c) => CRel c where getRel = getContent isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => GetContent (Rel c) c
putRel :: CRel c => Rel c -> Ab c

-- | The nullary full relation.
dee :: (CRel c) => c

-- | The nullary empty relation.
dum :: (CRel c) => c

-- | Data intepretation.
class (Basis c) => CInterp c where getInterp = getContent isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => GetContent Interp c
putInterp :: CInterp c => Interp -> Ab c

-- | Type of content.
class (Basis c) => CType c where getType = getContent isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => GetContent Type c
putType :: CType c => Type -> Ab c


-- | Generic content class.
module Koshucode.Baala.Data.Class.Content

-- | Generic content class.
class (Show c, Default c, CEmpty c, CEnd c, CBool c, CCode c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CTie c, CRel c) => CContent c where typeOrder c | isEmpty c = 1 | isBool c = 11 | isDec c = 12 | isClock c = 13 | isTime c = 14 | isCode c = 15 | isTerm c = 16 | isText c = 17 | isList c = 21 | isSet c = 22 | isTie c = 23 | isRel c = 24 | isInterp c = 25 | isType c = 27 | isEnd c = 31 | otherwise = error "unknown content"

-- | Order of content type.
typeOrder :: CContent c => c -> Int

-- | Convert some content to decimal number.
toDec :: (CContent c) => Map c

-- | Convert <a>Value</a> to content.
valueContent :: (CContent c) => Value -> c


-- | Content encoder.
module Koshucode.Baala.Data.Class.Encode

-- | Encode content to string.
--   
--   <pre>
--   &gt;&gt;&gt; contentString (the $ pText "a")
--   "a"
--   </pre>
contentString :: (CContent c) => c -> String

-- | Enclose mix text in list brackets.
--   
--   <pre>
--   &gt;&gt;&gt; mixBracketList $ B.mixString "a"
--   MixText "[ a ]"
--   </pre>
mixBracketList :: MixText -> MixText

-- | Enclose mix text in set brackets.
--   
--   <pre>
--   &gt;&gt;&gt; mixBracketSet $ B.mixString "a"
--   MixText "{ a }"
--   </pre>
mixBracketSet :: MixText -> MixText


-- | Content map.
module Koshucode.Baala.Data.Class.Map

-- | Pair of get and put.
type CGetPut a c = (c -> a, a -> c)

-- | <tt>gText</tt> and <tt>pText</tt>.
gpText :: (CText c) => CGetPut String c

-- | <tt>gList</tt> and <tt>pList</tt>.
gpList :: (CList c) => CGetPut [c] c

-- | <tt>gSet</tt> and <tt>pSet</tt>.
gpSet :: (CSet c) => CGetPut [c] c

-- | <tt>gSetSort</tt> and <tt>pSet</tt>.
gpSetSort :: (Ord c, CSet c) => CGetPut [c] c

-- | Apply function to internal value of content.
--   
--   <pre>
--   &gt;&gt;&gt; contentAp gText pText reverse (the $ pText "abc") :: Content
--   ContentText "cba"
--   </pre>
contentAp :: (c -> a) -> (b -> c') -> (a -> b) -> c -> c'

-- | Map function to internal value of content.
contentMap :: (Functor f) => (c -> f a) -> (f b -> c') -> (a -> b) -> c -> c'

-- | Apply function to internal string of text content.
--   
--   <pre>
--   &gt;&gt;&gt; contentApText reverse (the $ pText "abc")
--   VText "cba"
--   </pre>
contentApText :: (CText c) => StringMap -> Map c

-- | Map function to characters of internal string of text content.
--   
--   <pre>
--   &gt;&gt;&gt; contentMapTextList (\c -&gt; pText [c]) (the $ pText "abc")
--   VList [VText "a",VText "b",VText "c"]
--   </pre>
contentMapTextList :: (CList c, CText c) => (Char -> c) -> Map c


-- | Message list.
module Koshucode.Baala.Data.Church.Message

-- | Abortable scope for cox building.
abCoxBuild :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for cox calculation.
abCoxCalc :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for cox filling.
abCoxFill :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for irreducible expression.
abCoxIrrep :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for cox position.
abCoxPosition :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for cox prefix.
abCoxPrefix :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for cox reduction.
abCoxReduce :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for cox syntax.
abCoxSyntax :: (GetCodePos cp) => Abortable cp b

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown object
unkShow :: (Show x) => x -> Ab a

-- | Unknown term name
unkTerm :: (GetTermNames t1, GetTermNames t2) => t1 -> t2 -> Ab a

-- | Unknown term name
newTerm :: (GetTermNames t2) => TermPicker c -> t2 -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a

-- | Terms and input relation heading.
detailTermRel :: String -> [TermName] -> Head -> [String]

-- | Create message lines from double term names.
msgTerms2 :: (GetTermNames t1, GetTermNames t2) => String -> t1 -> String -> t2 -> [String]


-- | Term-content expression.
module Koshucode.Baala.Data.Church.Cox

-- | Term-content expressions.
data Cox c

-- | <b>1.</b> Literal content
CoxLit :: [CodePos] -> c -> Cox c

-- | <b>2.</b> Term reference, its name and index
CoxTerm :: [CodePos] -> [TermName] -> [TermIndex] -> Cox c

-- | <b>3.</b> Content calculator
CoxCalc :: [CodePos] -> BlankName -> (CopCalc c) -> Cox c

-- | <b>4.</b> Local blank, its name and De Bruijn index
CoxLocal :: [CodePos] -> String -> Int -> Cox c

-- | <b>5.</b> Blank in form
CoxBlank :: [CodePos] -> BlankName -> Cox c

-- | <b>6.</b> Fill args in a form
CoxFill :: [CodePos] -> (Cox c) -> [Cox c] -> Cox c

-- | <b>7.</b> Form with single blank
CoxForm1 :: [CodePos] -> CoxTag -> String -> (Cox c) -> Cox c

-- | <b>8.</b> Form with multiple blanks
CoxForm :: [CodePos] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | <b>9.</b> Cox with outside arguments
CoxWith :: [CodePos] -> [NamedCox c] -> (Cox c) -> Cox c

-- | Expression pair.
type Cox2 c = (Cox c, Cox c)

-- | Expression triple.
type Cox3 c = (Cox c, Cox c, Cox c)

-- | Expression quadruple.
type Cox4 c = (Cox c, Cox c, Cox c, Cox c)

-- | Maybe content expression.
type MaybeCox c = Maybe (Cox c)

-- | Abortable content expression.
type AbCox c = Ab (Cox c)

-- | Named content expression.
type NamedCox c = Named (Cox c)

-- | Term name and content expression.
type TermCox c = Term (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c

-- | Expression tag.
type CoxTag = Maybe String

-- | Create literal expression.
coxLit :: c -> Cox c

-- | Get arity of expression.
coxSyntacticArity :: Cox c -> Int

-- | Map expression form.
coxMap :: Map (Map (Cox c))

-- | Fill expression form.
coxCall :: Cox c -> (Map (Cox c)) -> Cox c

-- | Check irreducible expression.
checkIrreducible :: AbMap (Cox c)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Data.Church.Cox.Cox c)
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode c => GHC.Show.Show (Koshucode.Baala.Data.Church.Cox.Cox c)


-- | Term-content operator.
module Koshucode.Baala.Data.Church.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> AbCox c

-- | Tree-level syntax.
type CopTree = [Tree] -> Ab Tree

-- | Name of content operator.
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName

-- | Set of content operators.
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
[copsetCopList] :: CopSet c -> [Cop c]
[copsetInfixList] :: CopSet c -> [Named InfixHeight]

-- | CopCalc
[copsetCalcList] :: CopSet c -> [Named (Cop c)]

-- | CopCox
[copsetCoxList] :: CopSet c -> [Named (Cop c)]

-- | CopTree
[copsetTreeList] :: CopSet c -> [Named (Cop c)]

-- | This is created by <a>copsetFill</a>.
[copsetFindCalc] :: CopSet c -> CopFind (Cox c)

-- | This is created by <a>copsetFill</a>.
[copsetFindCox] :: CopSet c -> CopFind (CopCox c)

-- | This is created by <a>copsetFill</a>.
[copsetFindTree] :: CopSet c -> CopFind CopTree
[copsetDerived] :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Complete operator set.
copsetFill :: Map (CopSet c)

-- | Get set of content operators.
class GetCops a
getCops :: GetCops a => a c -> CopSet c
instance GHC.Show.Show (Koshucode.Baala.Data.Church.Cop.Cop c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Data.Church.Cop.Cop c)
instance Data.Default.Class.Default (Koshucode.Baala.Data.Church.Cop.CopSet c)
instance GHC.Base.Monoid (Koshucode.Baala.Data.Church.Cop.CopSet c)
instance Koshucode.Baala.Data.Church.Cop.GetCops Koshucode.Baala.Data.Church.Cop.CopSet


-- | Bundle of message modules.
module Koshucode.Baala.Data.Message


-- | Classes for term contents.
module Koshucode.Baala.Data.Class


-- | Decode contents from token trees.
module Koshucode.Baala.Data.Decode.Content

-- | Content decoder.
type DecodeContent c = Tree -> Ab c

-- | Content calculator.
type CalcContent c = Tree -> Ab c

-- | Decode content from string.
stringContent :: (CContent c) => String -> Ab c

-- | Decode content from token tree.
treeContent :: (CContent c) => DecodeContent c

-- | Decode judge from token trees. Judges itself are not content type. It
--   can be only used in the top-level of resources.
treesJudge :: (CContent c) => CacheT -> AssertType -> JudgeClass -> [Tree] -> Ab (CacheT, Judge c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Data.Decode.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Retrieve judgement class and its term names.
datasetClasses :: Dataset c -> Map JudgeClass [TermName]

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
datasetAdd :: [Judge c] -> Map (Dataset c)

-- | Read file and convert to dataset.
--   
--   <pre>
--   &gt;&gt;&gt; readDataset "foo.k" :: Koshucode.Baala.Base.IOAb DatasetC
--   Right Dataset { 3 * A /x /y | 2 * B /y /z | 1 * C /z }
--   </pre>
readDataset :: (CContent c) => FilePath -> IOAb (Dataset c)
instance GHC.Show.Show (Koshucode.Baala.Data.Decode.Dataset.Dataset c)
instance Data.Default.Class.Default (Koshucode.Baala.Data.Decode.Dataset.Dataset c)
instance Koshucode.Baala.Type.Rel.Rel.SelectRel Koshucode.Baala.Data.Decode.Dataset.Dataset


-- | Term content decoder.
module Koshucode.Baala.Data.Decode


-- | The Baala content type.
module Koshucode.Baala.Data.Content

-- | The Baala content type.
data Content

-- | <b>1. Edge:</b> Sign of no ordinary type

-- | <i>Warning: Use <tt>empty</tt> instead.</i>
ContentEmpty :: Content

-- | <b>2. Numeric:</b> Boolean type

-- | <i>Warning: Use <tt>pBool</tt> instead.</i>
ContentBool :: Bool -> Content

-- | <b>3. Numeric:</b> Decimal number type

-- | <i>Warning: Use <tt>pDec</tt> instead.</i>
ContentDec :: Decimal -> Content

-- | <b>4. Numeric:</b> Clock type

-- | <i>Warning: Use <tt>pClock</tt> instead.</i>
ContentClock :: Clock -> Content

-- | <b>5. Numeric:</b> Time type

-- | <i>Warning: Use <tt>pTime</tt> instead.</i>
ContentTime :: Time -> Content

-- | <b>6. Textual:</b> Code type

-- | <i>Warning: Use <tt>pCode</tt> instead.</i>
ContentCode :: String -> Content

-- | <b>7. Textual:</b> Term name type

-- | <i>Warning: Use <tt>pTerm</tt> instead.</i>
ContentTerm :: TermName -> Content

-- | <b>8. Textual:</b> Text type

-- | <i>Warning: Use <tt>pText</tt> instead.</i>
ContentText :: String -> Content

-- | <b>9. Recursive, Collective:</b> List type

-- | <i>Warning: Use <tt>pList</tt> instead.</i>
ContentList :: [Content] -> Content

-- | <b>10. Recursive, Collective:</b> Set type

-- | <i>Warning: Use <tt>pSet</tt> instead.</i>
ContentSet :: [Content] -> Content

-- | <b>11. Recursive, Relational:</b> Tie type (set of terms)

-- | <i>Warning: Use <tt>pTie</tt> instead.</i>
ContentTie :: [TermC] -> Content

-- | <b>12. Recursive, Relational:</b> Relation type

-- | <i>Warning: Use <tt>pRel</tt> instead.</i>
ContentRel :: RelC -> Content

-- | <b>13. Meta, Relational:</b> Interpretation type

-- | <i>Warning: Use <tt>pInterp</tt> instead.</i>
ContentInterp :: Interp -> Content

-- | <b>14. Meta:</b> Type for type

-- | <i>Warning: Use <tt>pType</tt> instead.</i>
ContentType :: Type -> Content

-- | <b>15. Edge:</b> The end of everything

-- | <i>Warning: Use <tt>end</tt> instead.</i>
ContentEnd :: Content

-- | Constants for edge content, i.e., empty and end.
type DispatchEdge a = (a, a)

-- | Functions for simple content, i.e., boolean, decimal, clock, time,
--   code, term, and text.
type DispatchSimple a = (Bool -> a, Decimal -> a, Clock -> a, Time -> a, String -> a, TermName -> a, String -> a)

-- | Functions for complex content, i.e., list, set, tie, relation, interp,
--   and type.
type DispatchComplex a = ([Content] -> a, [Content] -> a, [TermC] -> a, RelC -> a, Interp -> a, Type -> a)

-- | Call type-specific functions on empty or end content.
dispatchEdge :: DispatchEdge a -> (Content -> a) -> (Content -> a)

-- | Call type-specific functions on simple content.
dispatchSimple :: DispatchSimple a -> (Content -> a) -> (Content -> a)

-- | Call type-specific functions on complex content.
dispatchComplex :: DispatchComplex a -> (Content -> a) -> (Content -> a)

-- | Call type-specific functions on content.
dispatchContent :: DispatchEdge a -> DispatchSimple a -> DispatchComplex a -> (Content -> a)

-- | <tt>Term</tt> for concrete baala content.
type TermC = Term Content

-- | <tt>Judge</tt> for concrete baala content.
type JudgeC = Judge Content

-- | <tt>Rel</tt> for concrete baala content.
type RelC = Rel Content

-- | Abortable content.
type AbC = Ab Content

-- | Concrete dataset.
type DatasetC = Dataset Content

-- | Shorthand function for the Baala content type.
--   
--   <pre>
--   &gt;&gt;&gt; the $ D.pText "a"
--   ContentText "a"
--   </pre>
the :: Content -> Content

-- | Decode the Baala content from string.
--   
--   Edge contents.
--   
--   <pre>
--   &gt;&gt;&gt; stringC "()"
--   Right ContentEmpty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "(/)"
--   Right ContentEnd
--   </pre>
--   
--   Numeric contents.
--   
--   <pre>
--   &gt;&gt;&gt; stringC "(+)"
--   Right (ContentBool True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "12.00"
--   Right (ContentDec Decimal (2) 12)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "|02:30:00|"
--   Right (ContentClock |02:30:00|)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "2013-04-18"
--   Right (ContentTime 2013-04-18)
--   </pre>
--   
--   Textual contents.
--   
--   <pre>
--   &gt;&gt;&gt; stringC "'foo"
--   Right (ContentCode "foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "'/foo"
--   Right (ContentTerm "foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "\"foo\""
--   Right (ContentText "foo")
--   </pre>
--   
--   Metadata contents.
--   
--   <pre>
--   &gt;&gt;&gt; stringC "{| Aaa /x bbb /y ccc. |}"
--   Right (ContentInterp (Interp { interpWords = ..., interpTerms = ... }))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "[- text -]"
--   Right (ContentType TypeText)
--   </pre>
--   
--   Recursive contents.
--   
--   <pre>
--   &gt;&gt;&gt; stringC "[ 'foo | 'bar ]"
--   Right (ContentList [ContentCode "foo", ContentCode "bar"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "{ 'foo | 'bar }"
--   Right (ContentSet [ContentCode "foo", ContentCode "bar"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "{- /x 'foo /y 'bar -}"
--   Right (ContentTie [("x", ContentCode "foo"), ("y", ContentCode "bar")])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringC "{= /x /y [ 'foo | 'bar ][ 'baz | 'qux ] =}"
--   Right (ContentRel (Rel { relHead = ..., relBody = ... }))
--   </pre>
stringC :: String -> Ab Content
instance GHC.Show.Show Koshucode.Baala.Data.Content.Content
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.Content
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.Content
instance Data.Default.Class.Default Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Edge.Basis Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Content.CContent Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Edge.CEmpty Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Edge.CEnd Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CBool Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CDec Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CClock Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CTime Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CCode Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CTerm Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Simple.CText Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Complex.CList Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Complex.CSet Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Complex.CTie Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Complex.CRel Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Complex.CInterp Koshucode.Baala.Data.Content.Content
instance Koshucode.Baala.Data.Class.Complex.CType Koshucode.Baala.Data.Content.Content


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Build

-- | Construct content expression from token tree.
treeCox :: (CContent c) => CopSet c -> Tree -> AbCox c

-- | Insert fresh form into indexed expression.
coxForm :: (GetCodePos cp) => cp -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calculation.
module Koshucode.Baala.Data.Church.Run

-- | <ul>
--   <li><i>Tuple-to-Content</i> Type for tuple-to-content
--   calculation.</li>
--   </ul>
type CalcTuple c = [c] -> Ab c

-- | <ul>
--   <li><i>Cox-to-Tuple-to-Content</i> Create tuple calculator from
--   content expression.</li>
--   </ul>
calcTuple :: (GetCops cops, CContent c) => cops c -> Head -> Cox c -> CalcTuple c

-- | <ul>
--   <li><i>Tuple-to-Cox-to-Content</i> Calculate content expression with
--   specific tuple.</li>
--   </ul>
calcCox :: (GetCops cops, CContent c) => cops c -> Head -> [c] -> Cox c -> Ab c

-- | <ul>
--   <li><i>Tree-to-Content</i> Calculate token tree as content
--   expression.</li>
--   </ul>
calcTree :: (GetCops cops, CContent c) => cops c -> CalcContent c

-- | Extract single non-abortable argument.
getRightArg1 :: (Basis c) => [Ab c] -> Ab c

-- | Extract two non-abortable arguments.
getRightArg2 :: (Basis c) => [Ab c] -> Ab (c, c)

-- | Extract three non-abortable arguments.
getRightArg3 :: (Basis c) => [Ab c] -> Ab (c, c, c)
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode c => GHC.Show.Show (Koshucode.Baala.Data.Church.Run.Beta c)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Data.Church.Run.Beta c)


-- | Content calculation.
module Koshucode.Baala.Data.Church


-- | Bundle of data modules.
module Koshucode.Baala.Data
