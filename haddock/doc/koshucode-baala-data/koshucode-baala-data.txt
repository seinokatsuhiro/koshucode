-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-data
@version 0.162.0.0


-- | Extra functions for rational numbers.
module Koshucode.Baala.Data.Type.Decimal.Rational

-- | <a>Rational</a> version of <a>%</a>.
(%%) :: Integer -> Integer -> Rational

-- | Integer part and proper fraction part of ratio of two numbers, i.e.,
--   <i>x</i> <a>//.</a> <i>y</i> == (<i>integer</i>,
--   <i>proper-fraction</i>) of <i>x</i> <a>%</a> <i>y</i>.
(//.) :: (Integral n) => n -> n -> (n, Ratio n)

-- | Synonym of <a>quotRem</a>.
(//) :: (Integral n) => n -> n -> (n, n)

-- | 1 <a>%</a> 2
ratioHalf :: (Integral n) => Ratio n

-- | Unit rational number for decimal fractional length.
ratioFracle :: (Integral i, Integral n) => i -> Ratio n

-- | Round rational number at decimal fractional length.
ratioRoundAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round-to-even rational number at decimal fractional length.
ratioRoundEvenAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round rational number per unit rational number.
ratioRoundPer :: (Integral n) => Bin (Ratio n)

-- | Round-to-even rational number per unit rational number.
ratioRoundEvenPer :: (Integral n) => Bin (Ratio n)

-- | Truncate rational number at decimal fractional length.
ratioTruncAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Truncate rational number per unit rational number.
ratioTruncPer :: (Integral n) => Bin (Ratio n)

-- | Round out (toward infinity) rational number at decimal fractional
--   length.
ratioRoundOutAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round out (toward infinity) rational number per unit rational number.
ratioRoundOutPer :: (Integral n) => Bin (Ratio n)

-- | Floor rational number at decimal fractional length.
ratioFloorAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Floor rational number per unit rational number.
ratioFloorPer :: (Integral n) => Bin (Ratio n)

-- | Ceiling rational number at decimal fractional length.
ratioCeilAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Ceiling rational number per unit rational number.
ratioCeilPer :: (Integral n) => Bin (Ratio n)
ratioQuo :: (Integral n) => Bin (Ratio n)
ratioRem :: (Integral n) => Bin (Ratio n)
ratioQuoRem :: (Integral n) => Ratio n -> Ratio n -> (Ratio n, Ratio n)


-- | Decimal number.
--   
--   A decimal number in Koshucode is internally represented using a
--   rational number (<a>decimalRatio</a>) with a length of fractional part
--   (<a>decimalFracle</a>) . For example, the decimal number 11.250
--   correnponds to the rational number 45/4 with the fraction length 3.
--   
--   <ul>
--   <li><i>Decimal number</i> Number represented using 10 digits and the
--   decimal separator.</li>
--   <li><i>Decimal separator</i> Symbol between integer part and
--   fractional part.</li>
--   <li><i>Fractional part</i> The right part of decimal numbers, e.g.,
--   250 for 11.250.</li>
--   <li><i>Integer part</i> The left part of decimal numbers, e.g., 11 for
--   11.250.</li>
--   <li><i>Integral decimal</i> Decimal number without fractional
--   part.</li>
--   </ul>
module Koshucode.Baala.Data.Type.Decimal.Decimal

-- | Type for numerator or denominator for decimal numbers.
type DecimalInteger = Integer

-- | Rational number of decimal type.
type DecimalRatio = Ratio DecimalInteger

-- | Length of fractional part.
type DecimalFracle = Int

-- | Decimal number.
data Decimal
Decimal :: DecimalFracle -> DecimalRatio -> Decimal

-- | Length of the fractional part
[decimalFracle] :: Decimal -> DecimalFracle

-- | Rational number for the decimal number
[decimalRatio] :: Decimal -> DecimalRatio

-- | Change decimal fracle.
decimalFracleSet :: DecimalFracle -> AbMap Decimal

-- | Map function to rational number in decimal.
decimalRatioMap :: Map DecimalRatio -> Map Decimal

-- | Binary operation for two decimals.
type BinDecimal = Bin Decimal

-- | Abortable binary operation for two decimals.
type BinAbDecimal = BinAb Decimal

-- | Combinate fracle.
type BinFracle = Bin DecimalFracle

-- | Combinate rational number.
type BinRatio = Bin DecimalRatio

-- | Binary operation for two decimals.
decimalBin :: BinFracle -> BinRatio -> BinDecimal

-- | Abortable binary operation for two decimals.
decimalBinAb :: BinFracle -> BinRatio -> BinAbDecimal

-- | Convert integral number to integral decimal number.
integralDecimal :: (Integral n) => n -> Decimal

-- | Convert real number to decimal number.
realDecimal :: (Real n) => DecimalFracle -> n -> Decimal

-- | Convert decimal number to fractional number.
decimalFractional :: (Fractional n) => Decimal -> n
instance GHC.Show.Show Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Enum.Enum Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Num.Num Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.Real Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.Fractional Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.RealFrac Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal


-- | Decimal functions.
module Koshucode.Baala.Data.Type.Decimal.Fraction

-- | Integer part of decimals.
decimalIntPart :: Map Decimal

-- | Fractional part of decimals.
decimalFracPart :: Map Decimal
decimalIntFrac :: Decimal -> (Decimal, Decimal)

-- | Numerator part of decimal number.
decimalNum :: Decimal -> DecimalInteger

-- | Denominator part of decimal number.
decimalDenom :: Decimal -> DecimalInteger

-- | Round decimal per self fractional length.
decimalRound :: Map Decimal

-- | Round decimal per fractional length.
decimalRoundAt :: Bin Decimal

-- | Round decimal per unit decimal.
decimalRoundPer :: Bin Decimal

-- | Round decimal to even per self fractional length.
decimalRoundEven :: Map Decimal

-- | Round decimal to even per fractional length.
decimalRoundEvenAt :: Bin Decimal

-- | Round decimal to even per unit decimal.
decimalRoundEvenPer :: Bin Decimal

-- | Truncate decimal per self fractional length.
decimalTrunc :: Map Decimal

-- | Truncate decimal per fractional length.
decimalTruncAt :: Bin Decimal

-- | Truncate decimal per unit decimal.
decimalTruncPer :: Bin Decimal

-- | Truncation error of decimal.
decimalTruncError :: Map Decimal

-- | Round out (toward infinity) decimal to even per self fractional
--   length.
decimalRoundOut :: Map Decimal

-- | Round out (toward infinity) decimal to even per fractional length.
decimalRoundOutAt :: Bin Decimal

-- | Round out (toward infinity) decimal to even per unit decimal.
decimalRoundOutPer :: Bin Decimal

-- | Floor decimal per self fractional length.
decimalFloor :: Map Decimal

-- | Floor decimal per fractional length.
decimalFloorAt :: Bin Decimal

-- | Floor decimal per unit decimal.
decimalFloorPer :: Bin Decimal

-- | Ceiling decimal per self fractional length.
decimalCeil :: Map Decimal

-- | Ceiling decimal per fractional length.
decimalCeilAt :: Bin Decimal

-- | Ceiling decimal per unit decimal.
decimalCeilPer :: Bin Decimal

-- | <tt>chopDigitsTrancate</tt> <i>d</i> <i>n</i> returns a number which
--   does not have the tailing <i>d</i> digits. If <i>d</i> is zero or
--   negative, it returns just <i>n</i>.
chopDigitsTrancate :: (Integral d, Integral n) => d -> n -> n

-- | <tt>chopDigitsRound</tt> is similar to <a>chopDigitsTrancate</a>, but
--   rounds chopped digit.
chopDigitsRound :: (Integral d, Integral n) => d -> n -> n

-- | Round the last (least significant) digit.
roundLastDigit :: (Integral n) => n -> n


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Data.Type.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of class, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement class represents certain sentence class
--   that gives intepretation of data. Sentence class has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c

-- | <pre>
--   |-- P /x 10 /y 20
--   </pre>
JudgeAffirm :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-x P /x 10 /y 20
--   </pre>
JudgeDeny :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-xx P /x 10 /y 20
--   </pre>
JudgeMultiDeny :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-c P /x 10 +/y 20
--   </pre>
JudgeChange :: JudgeClass -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-cc P /x 10 +/y 20
--   </pre>
JudgeMultiChange :: JudgeClass -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-v P /x 10 /y 20
--   </pre>
JudgeViolate :: JudgeClass -> [Term c] -> Judge c

-- | Name of judgement class, in other words, name of propositional
--   function.
type JudgeClass = String

-- | Map function to terms.
judgeTermsMap :: ([Term a] -> [Term b]) -> Judge a -> Judge b

-- | Prepend a term into judgement.
judgeCons :: Term c -> Map (Judge c)

-- | Construct judgement from its class and terms.
type JudgeOf c = JudgeClass -> [Term c] -> Judge c

-- | Construct affirmative judgement.
affirm :: JudgeOf c

-- | Construct denial judgement.
deny :: JudgeOf c

-- | Affirm judgement, i.e., change logical quality to affirmative.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to denial.
denyJudge :: Map (Judge c)

-- | Test which judgement is affirmed.
isAffirmative :: Judge c -> Bool

-- | Test which judgement is denied.
isDenial :: Judge c -> Bool

-- | Test which judgement is for violation.
isViolative :: Judge c -> Bool

-- | Get judge class.
class GetClass a
getClass :: GetClass a => a -> JudgeClass

-- | Get list of term names.
class GetTermNames a
getTermNames :: GetTermNames a => a -> [TermName]

-- | Get term list.
class GetTerms a
getTerms :: GetTerms a => a c -> [Term c]

-- | Conventional line-break setting for judges: 4-spaces indent and
--   120-columns line.
judgeBreak :: LineBreak

-- | Encode term name.
termNameToMix :: TermName -> MixText

-- | Encode term list with one-space separator.
termsToMix1 :: (MixShortEncode c) => Shorten -> [Term c] -> MixText

-- | Encode term list with two-spaces separator.
termsToMix2 :: (MixShortEncode c) => Shorten -> [Term c] -> MixText
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Base.Functor Koshucode.Baala.Data.Type.Judge.Judge
instance Koshucode.Baala.Data.Type.Judge.GetClass (Koshucode.Baala.Data.Type.Judge.Judge c)
instance Koshucode.Baala.Data.Type.Judge.GetTermNames (Koshucode.Baala.Data.Type.Judge.Judge c)
instance Koshucode.Baala.Data.Type.Judge.GetTermNames [Koshucode.Baala.Syntax.Symbol.Term.TermName]
instance Koshucode.Baala.Data.Type.Judge.GetTerms Koshucode.Baala.Data.Type.Judge.Judge
instance Koshucode.Baala.Base.Text.MixEncode.MixShortEncode c => Koshucode.Baala.Base.Text.MixEncode.MixShortEncode (Koshucode.Baala.Data.Type.Judge.Judge c)

module Koshucode.Baala.Data.Type.Type

-- | Type for types.
data Type

-- | Everything
TypeAny :: Type

-- | Type of types
TypeType :: Type

-- | Term name
TypeTerm :: Type

-- | Data interpreation
TypeInterp :: Type

-- | Empty
TypeEmpty :: Type

-- | End
TypeEnd :: Type

-- | Boolean
TypeBool :: Type

-- | Text
TypeText :: Type

-- | Code
TypeCode :: Type

-- | Decimal
TypeDec :: Type

-- | Clock
TypeClock :: (Maybe String) -> Type

-- | Time
TypeTime :: (Maybe String) -> Type

-- | Binary data
TypeBin :: Type

-- | List
TypeList :: Type -> Type

-- | Set
TypeSet :: Type -> Type

-- | Tagged type
TypeTag :: String -> Type -> Type

-- | Tie
TypeTie :: [NamedType] -> Type

-- | Relation
TypeRel :: [NamedType] -> Type

-- | Tuple (Product type)
TypeTuple :: [Type] -> Type

-- | Sum type
TypeSum :: [Type] -> Type
type NamedType = Named Type

-- | Print type as tree.
typeExplain :: Type -> Doc

-- | Encode term types.
typeTermMix :: Type -> MixText

-- | Create relation type from term names.
typeFlatRel :: [TermName] -> Type

-- | Add term name to relation type.
typeConsRel :: TermName -> Map Type

-- | Add term name and type to relation type.
typeConsNest :: TermName -> Type -> Map Type

-- | Add term names to relation type.
typeAppendRel :: [TermName] -> Map Type

-- | Get term names from relation type.
typeRelTermNames :: Type -> [TermName]

-- | Get degree of relation type.
typeRelDegree :: Type -> Int

-- | Get named type from relation type or tie type.
typeTerms :: Type -> [NamedType]

-- | Test type is relational.
isTypeRel :: Type -> Bool

-- | Calculate term index.
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeConsNest "r" (typeFlatRel ["a", "b"]) (typeFlatRel [])) ["r", "b"]
--   [0, 1]
--   </pre>
typeRelIndex :: Type -> TermPath -> [Int]

-- | Modify terms of relation type.
typeRelMapTerms :: Map [NamedType] -> Map Type

-- | Modify term of relation type.
typeRelMapTerm :: Map NamedType -> Map Type

-- | Modify term name of relation type.
typeRelMapName :: Map TermName -> Map Type
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Type.Type
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Type.Type
instance GHC.Show.Show Koshucode.Baala.Data.Type.Type.Type
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Type.Type


-- | Heading of relations
module Koshucode.Baala.Data.Type.Rel.Head

-- | Heading of relations.
data Head
Head :: Type -> Head
[headType] :: Head -> Type

-- | Pretty print head of relation.
--   
--   <pre>
--   &gt;&gt;&gt; headExplain $ headFrom ["a", "b"]
--   rel /a any
--       /b any
--   </pre>
headExplain :: Head -> Doc

-- | Make head of given type..
headOf :: Type -> Head

-- | Make head from term names.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["a", "b"]
--   Head { headType = TypeRel [("a", TypeAny), ("b", TypeAny)] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.mixEncode $ headFrom ["a", "b"]
--   MixText "/a /b"
--   </pre>
headFrom :: [TermName] -> Head

-- | Test two heads are equivalent.
headEquiv :: Head -> Head -> Bool

-- | Test heading is subset of another heading.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["a", "b"] `isSubhead` headFrom ["a", "b", "c"]
--   True
--   
--   &gt;&gt;&gt; headFrom ["a", "e"] `isSubhead` headFrom ["a", "b", "c"]
--   False
--   </pre>
isSubhead :: Head -> Head -> Bool

-- | Test heading is superset of another heading.
isSuperhead :: Head -> Head -> Bool

-- | Degree of relation, i.e., number of terms.
--   
--   <pre>
--   &gt;&gt;&gt; headDegree $ headFrom ["a", "b"]
--   2
--   </pre>
headDegree :: Head -> Int

-- | Select nested terms.
headNested :: Head -> [(TermName, Head)]

-- | Index of a term.
headIndex1 :: Head -> TermPath -> [Int]
headTypes :: Head -> [Type]

-- | Add term name to head.
headCons :: TermName -> Map Head

-- | Add term names to head.
headAppend :: [TermName] -> Map Head
headConsNest :: TermName -> Head -> Map Head
headNests :: [TermName] -> Map Head

-- | Reconstruct head.
headMap :: Map [NamedType] -> Map Head
headMapName :: Map TermName -> Map Head

-- | Move up nested relation.
headUp :: Map Head
bodyAlign :: Head -> Head -> Map [[c]]
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Show.Show Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Base.Monoid Koshucode.Baala.Data.Type.Rel.Head.Head
instance Koshucode.Baala.Data.Type.Judge.GetTermNames Koshucode.Baala.Data.Type.Rel.Head.Head
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Rel.Head.Head


-- | Relation type
module Koshucode.Baala.Data.Type.Rel.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Head -> Body c -> Rel c

-- | Heading of relation
[relHead] :: Rel c -> Head

-- | Body of relation
[relBody] :: Rel c -> Body c

-- | Body of relation, i.e., a list of tuples. Tuple is a list of contents.
type Body c = [[c]]

-- | Sort head and body of relation.
relSort :: (Ord c) => Map (Rel c)
relBodyOrder :: (Ord c) => [SignedTermName] -> Head -> Map [[c]]

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldum :: Rel Bool)
--   {= =}
--   </pre>
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldee :: Rel Bool)
--   {= [] =}
--   </pre>
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c
class SelectRel r

-- | Convert judges to relation.
selectRel :: SelectRel r => r c -> JudgeClass -> [TermName] -> Rel c

-- | Convert relation to list of judges.
judgesFromRel :: JudgeOf c -> JudgeClass -> Rel c -> [Judge c]
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Base.Functor Koshucode.Baala.Data.Type.Rel.Rel.Rel
instance Koshucode.Baala.Data.Type.Judge.GetTermNames (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance Koshucode.Baala.Base.Text.MixEncode.MixShortEncode c => Koshucode.Baala.Base.Text.MixEncode.MixShortEncode (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)


-- | Content type for nested relations.
module Koshucode.Baala.Data.Type.Rel.Mono

-- | Monotype relation.
data Mono c

-- | Terminal content
MonoTerm :: c -> Mono c

-- | Nested relation
MonoNest :: (RelMono c) -> Mono c
type RelMono c = Rel (Mono c)

-- | Text relation.
type RelText = RelMono String

-- | Test terminal content.
isMonoTerm :: Mono c -> Bool

-- | Test nested relation.
isMonoNest :: Mono c -> Bool

-- | Get terminal content.
gMonoTerm :: Mono c -> c

-- | Get nested relation.
gMonoNest :: Mono c -> RelMono c

-- | Put terminal content.
pMonoTerm :: c -> Mono c

-- | Put nested relation.
pMonoNest :: RelMono c -> Mono c
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)


-- | Shared and side terms.
module Koshucode.Baala.Data.Type.Rel.ShareSide

-- | Shared and side terms.
data ShareSide c
ShareSide :: [Int] -> [Int] -> Bool -> [TermName] -> [TermName] -> [TermName] -> [TermName] -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> ([c], [c])) -> ([c] -> ([c], [c])) -> ([c] -> [c]) -> ([c] -> [c]) -> ShareSide c

-- | Indicies of right-shared part
[ssLShareIndex] :: ShareSide c -> [Int]

-- | Indicies of left-shared part
[ssRShareIndex] :: ShareSide c -> [Int]

-- | Whether shared part is empty
[ssDisjoint] :: ShareSide c -> Bool

-- | Left-side term names
[ssLSideNames] :: ShareSide c -> [TermName]

-- | Left-shared term names
[ssLShareNames] :: ShareSide c -> [TermName]

-- | Right-shared term names
[ssRShareNames] :: ShareSide c -> [TermName]

-- | Right-side term names
[ssRSideNames] :: ShareSide c -> [TermName]

-- | Pick left-side part from left contents
[ssLSide] :: ShareSide c -> [c] -> [c]

-- | Pick left-shared part from left contents
[ssLShare] :: ShareSide c -> [c] -> [c]

-- | Pick right-shared part from right contents
[ssRShare] :: ShareSide c -> [c] -> [c]

-- | Pick right-side part from right contents
[ssRSide] :: ShareSide c -> [c] -> [c]

-- | Pick right-shared and right-side part
[ssRSplit] :: ShareSide c -> [c] -> ([c], [c])

-- | Pick right-shared part and right contents
[ssRAssoc] :: ShareSide c -> [c] -> ([c], [c])
[ssRForward] :: ShareSide c -> [c] -> [c]
[ssRBackward] :: ShareSide c -> [c] -> [c]
type ShareSideMap c = ShareSide c -> [c] -> [c]
type ShareSideMap2 a b = (ShareSideMap a, ShareSideMap b)

-- | Create share-side structure from left and right term names.
--   
--   <pre>
--   &gt;&gt;&gt; let ss = shareSide ["a", "b", "c"] ["b", "c", "d", "e"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssDisjoint ss
--   False
--   </pre>
--   
--   Left terms.
--   
--   <pre>
--   &gt;&gt;&gt; ssLShareIndex ss
--   [1, 2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssLShareNames ss
--   ["b", "c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssLSide ss "ABC"
--   "A"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssLShare ss "ABC"
--   "BC"
--   </pre>
--   
--   Right terms.
--   
--   <pre>
--   &gt;&gt;&gt; ssRShareIndex ss
--   [0, 1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRShareNames ss
--   ["b", "c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRSideNames ss
--   ["d", "e"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRShare ss "BCDE"
--   "BC"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRSide ss "BCDE"
--   "DE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRSplit ss "BCDE"
--   ("BC", "DE")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRAssoc ss "BCDE"
--   ("BC", "BCDE")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRForward ss "BCDE"
--   "BCDE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRBackward ss "BCDE"
--   "DEBC"
--   </pre>
shareSide :: (GetTermNames l, GetTermNames r) => l -> r -> ShareSide c
shareSideOrd :: (GetTermNames l, GetTermNames r) => l -> r -> ShareSide c


-- | Relation type.
module Koshucode.Baala.Data.Type.Rel


-- | Type for data interpretation.
module Koshucode.Baala.Data.Type.Interp

-- | Data interpretation.
data Interp
Interp :: [InterpWord] -> [TermName] -> Interp

-- | Sentence which interpret data.
[interpWords] :: Interp -> [InterpWord]

-- | Terms in sentence.
[interpTerms] :: Interp -> [TermName]
data InterpWord
InterpText :: String -> InterpWord
InterpTerm :: TermName -> InterpWord
interp :: [InterpWord] -> Interp
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Show.Show Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Interp.InterpWord
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Interp.InterpWord
instance GHC.Show.Show Koshucode.Baala.Data.Type.Interp.InterpWord
instance Koshucode.Baala.Data.Type.Judge.GetTermNames Koshucode.Baala.Data.Type.Interp.Interp
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Interp.Interp
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Interp.InterpWord

module Koshucode.Baala.Data.Type.Message

-- | Divide by zero
divideByZero :: Ab a

-- | Different decimal length
heteroDecimal :: String -> String -> Ab a

-- | Can't read as date
notDate :: Integer -> Int -> Int -> Ab a

-- | Too large digit
tooLargeDigit :: String -> Ab a

-- | Can't read as number
notNumber :: String -> Ab a


-- | Decode and encode of decimals.
--   
--   <ul>
--   <li><i>Decimal</i> Head Int Frac ? Tail</li>
--   <li><i>Head</i> Sign ...</li>
--   <li><i>Int</i> Digit ...</li>
--   <li><i>Frac</i> Separator Digit ...</li>
--   <li><i>Tail</i> Sign ...</li>
--   <li><i>Sign</i> Space | <tt>"-"</tt> | <tt>"+"</tt></li>
--   <li><i>Digit</i> Space | <tt>"0"</tt> | ... | <tt>"9"</tt> |
--   <tt>"a"</tt> | ... | <tt>"z"</tt> | <tt>"A"</tt> | ... |
--   <tt>"Z"</tt></li>
--   <li><i>Separator</i> <tt>"."</tt></li>
--   <li><i>Space</i> <tt>" "</tt></li>
--   </ul>
module Koshucode.Baala.Data.Type.Decimal.Coder

-- | Decode to <tt>a</tt>.
type DecodeAb a = String -> Ab a

-- | Decode base-2 digits to decimal.
decodeBinary :: DecodeAb Decimal

-- | Decode base-8 digits to decimal.
decodeOctal :: DecodeAb Decimal

-- | Decode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11"
--   Right Decimal (0) 11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "-12 345.00"
--   Right Decimal (2) -12345
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11.250 +"
--   Right Decimal (3) 11 + 1 % 4
--   </pre>
decodeDecimal :: DecodeAb Decimal

-- | Decode base-16 digits to decimal.
decodeHex :: DecodeAb Decimal

-- | Decode digits to number.
decodeBase :: Integer -> DecodeAb Decimal

-- | Encode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal 0 (12345 D.%% 10)
--   "1 234"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal 2 (12345 D.%% 10)
--   "1 234.50"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal (-2) (12345 D.%% 10)
--   "1 2oo"
--   </pre>
encodeDecimal :: Decimal -> String

-- | Encode decimals without spaces.
encodeDecimalCompact :: Decimal -> String


-- | Arithmetics on decimals.
module Koshucode.Baala.Data.Type.Decimal.BinaryAb
data FracleSide

-- | Select longer fracle
FracleLong :: FracleSide

-- | Select left fracle
FracleLeft :: FracleSide

-- | Select right fracle
FracleRight :: FracleSide

-- | Check same fracles
FracleStrict :: FracleSide

-- | Addition: <i>x</i> + <i>y</i>
decimalAdd :: FracleSide -> BinAbDecimal

-- | Add all decimals.
decimalSum :: [Decimal] -> Ab Decimal

-- | Subtruction: <i>x</i> - <i>y</i>
decimalSub :: FracleSide -> BinAbDecimal

-- | Multiplication: <i>x</i> × <i>y</i>
decimalMul :: BinAbDecimal

-- | Division: <i>x</i> ÷ <i>y</i>
decimalDiv :: BinAbDecimal

-- | Quotient: integral part of <i>x</i> ÷ <i>y</i>
decimalQuo :: BinAbDecimal

-- | Remainder: <i>y</i> × fractional part of <i>x</i> ÷ <i>y</i>
decimalRem :: BinAbDecimal
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Decimal.BinaryAb.FracleSide
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Decimal.BinaryAb.FracleSide
instance GHC.Show.Show Koshucode.Baala.Data.Type.Decimal.BinaryAb.FracleSide

module Koshucode.Baala.Data.Type.Decimal

module Koshucode.Baala.Data.Type.Time.Date
data Date

-- | Date in <i>YYYY-MM-DD</i>
Monthly :: MJDay -> Date

-- | Date in <i>YYYY-#W-D</i>
Weekly :: MJDay -> Date

-- | Date in <i>YYYY-##D</i>
Yearly :: MJDay -> Date
type MJDay = Day  The Modified Julian Day
type YmdTuple = (Year, Month, Day)
type Year = Integer
type Month = Int
type Week = Int
type Day = Int

-- | Create date from year, month, and day.
dateFromYmdAb :: Year -> Month -> Day -> Ab Date

-- | Create date from year, week, and day.
dateFromYwdAb :: Year -> Week -> Day -> Ab Date

-- | Create date from year and day.
dateFromYdAb :: Year -> Day -> Ab Date

-- | Get the internal Modified Julian Day.
dateDay :: Date -> MJDay
dateMapDay :: Map MJDay -> Map Date
dateAdd :: (Integral n) => n -> Map Date

-- | Convert into monthly date.
monthly :: Map Date

-- | Convert into weekly date.
weekly :: Map Date

-- | Convert into yearly date.
yearly :: Map Date
mix02 :: Int -> MixText
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Date.Date
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Date.Date
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Date.Date
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Time.Date.Date

module Koshucode.Baala.Data.Type.Time.Clock
data Clock

-- | Clock represented by multiple of second
ClockDhms :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of minute
ClockDhm :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of hour
ClockDh :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of day
ClockD :: DayCount -> Clock
type DayCount = Integer
type Hour = Int
type Min = Int
type Sec = Int

-- | Type for abortable binary operator.
type AbBin a = a -> a -> Ab a
clockBodyToMix :: Clock -> MixText
clockFromDhms :: DayCount -> Hour -> Min -> Sec -> Clock
clockFromDhm :: DayCount -> Hour -> Min -> Clock
clockFromDh :: DayCount -> Hour -> Clock
clockFromD :: DayCount -> Clock
clockFromHms :: Hour -> Min -> Maybe Sec -> Clock

-- | Decompose second into day-count, hour, minute and second parts.
dhmsFromSec :: Sec -> (DayCount, Hour, Min, Sec)

-- | Aggregate hour, minute, and second into single second.
secFromHms :: (Hour, Min, Sec) -> Sec

-- | Sign of clock as <tt>-1</tt>, <tt>0</tt>, <tt>1</tt>.
clockSign :: Clock -> Int

-- | Day-count part of clock.
clockDayCount :: Clock -> DayCount

-- | Second part of clock.
clockSec :: Clock -> Sec
clockPrecision :: Clock -> String
clockDhms :: Clock -> (DayCount, Maybe Hour, Maybe Min, Maybe Sec)
clockAlter :: Maybe DayCount -> Maybe Hour -> Maybe Min -> Maybe Sec -> Map Clock

-- | Convert clock to positive clock.
clockPos :: Map Clock

-- | Convert clock to negative clock.
clockNeg :: Map Clock

-- | Set day-count to zero.
clockCutDay :: Map Clock

-- | Add day-count.
clockAddDay :: DayCount -> Map Clock

-- | Add second.
clockAddSec :: Sec -> Map Clock

-- | Calculation of clock plus clock.
clockAdd :: AbBin Clock

-- | Calculation of clock minus clock.
clockSub :: AbBin Clock
clockTimes :: Int -> Map Clock
clockRangeBy :: Map (DayCount, Sec) -> RangeBy Clock
clockStep :: Sec -> Map (DayCount, Sec)
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Clock.Clock
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Clock.Clock
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Clock.Clock
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Time.Clock.Clock

module Koshucode.Baala.Data.Type.Time.Time
data Time

-- | Date and time with time zone
TimeYmdcz :: Date -> Clock -> Sec -> Time

-- | Date and time
TimeYmdc :: Date -> Clock -> Time

-- | Year, month, and day
TimeYmd :: Date -> Time

-- | Year and week
TimeYw :: MJDay -> Time

-- | Year and month
TimeYm :: MJDay -> Time
timeYmd :: MJDay -> Time
timeYmdc :: MJDay -> Clock -> Time

-- | Create time data from year and month.
timeFromYmAb :: Year -> Month -> Ab Time

-- | Create time data from year and week.
timeFromYwAb :: Year -> Week -> Ab Time

-- | Create time data from date, clock, and time zone.
timeFromDczAb :: Date -> Clock -> Maybe Sec -> Ab Time

-- | Create time data form modified Julian date.
timeFromMjd :: DayCount -> Time
timeMjd :: Time -> DayCount
timeMapDate :: Map Date -> Map Time
timeMapMjd :: Map DayCount -> Map Time
timePrecision :: Time -> String
timeFloorMonth :: Map Time
timeFloorYear :: Map Time
timeCeilMonth :: Map Time
timeCeilYaer :: Map Time
timeRangeDay :: RangeBy Time
timeRangeMonth :: RangeBy Time
timeRangeYear :: RangeBy Time

-- | Add days to time.
timeAddDay :: DayCount -> Map Time

-- | Add weeks to time.
timeAddWeek :: Integer -> Map Time

-- | Add months to time.
timeAddMonth :: Integer -> Map Time

-- | Add years to time.
timeAddYear :: Year -> Map Time

-- | Add clock to time.
timeAddClock :: Clock -> AbMap Time

-- | Calculate clock from time to time.
timeDiff :: Time -> Time -> Ab Clock
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Time.Time
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Time.Time
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Time.Time
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode Koshucode.Baala.Data.Type.Time.Time.Time

module Koshucode.Baala.Data.Type.Time

module Koshucode.Baala.Data.Content.Message
abLiteral :: TTreeTo (Map (Ab b))

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Int -> Int -> Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require tuple in list
reqRelTuple :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown type name
unkType :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a
unmatchType :: String -> Ab a
expectActual :: String -> String -> [String]
expect2Actual :: String -> String -> String -> [String]


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Data.Type

module Koshucode.Baala.Data.Church.Message
abCoxBuild :: TTreeTo (Map (Ab b))
abCoxCalc :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxFill :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxIrrep :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxPosition :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxPrefix :: TTreeTo (Map (Ab b))
abCoxReduce :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxSyntax :: TTreeTo (Map (Ab b))

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown object
unkShow :: (Show x) => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Head -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a
detailTermRel :: String -> [String] -> Head -> [String]

module Koshucode.Baala.Data.Message


-- | Term-content expression.
module Koshucode.Baala.Data.Church.Cox

-- | Term-content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Content calculator
CoxCalc :: [CodePt] -> BlankName -> (CopCalc c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> CoxTag -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c
type Cox2 c = (Cox c, Cox c)
type Cox3 c = (Cox c, Cox c, Cox c)
type Cox4 c = (Cox c, Cox c, Cox c, Cox c)
type MaybeCox c = Maybe (Cox c)
type NamedCox c = Named (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c
type CoxTag = Maybe String
coxLit :: c -> Cox c
coxSyntacticArity :: Cox c -> Int
coxMap :: Map (Map (Cox c))
coxCall :: Cox c -> (Map (Cox c)) -> Cox c
checkIrreducible :: AbMap (Cox c)
instance Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Data.Church.Cox.Cox c)
instance Koshucode.Baala.Base.Text.MixEncode.MixShortEncode c => GHC.Show.Show (Koshucode.Baala.Data.Church.Cox.Cox c)


-- | Term-content operator.
module Koshucode.Baala.Data.Church.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TTree] -> Ab TTree
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
[copsetCopList] :: CopSet c -> [Cop c]
[copsetInfixList] :: CopSet c -> [Named InfixHeight]
[copsetCalcList] :: CopSet c -> [Named (Cop c)]
[copsetCoxList] :: CopSet c -> [Named (Cop c)]
[copsetTreeList] :: CopSet c -> [Named (Cop c)]
[copsetFindCalc] :: CopSet c -> CopFind (Cox c)
[copsetFindCox] :: CopSet c -> CopFind (CopCox c)
[copsetFindTree] :: CopSet c -> CopFind CopTree
[copsetDerived] :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Empty operator set.
copset :: CopSet c
copsetFill :: Map (CopSet c)
instance GHC.Show.Show (Koshucode.Baala.Data.Church.Cop.Cop c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Data.Church.Cop.Cop c)


-- | Singleton content type.
module Koshucode.Baala.Data.Content.Singleton
class CTypeOf c
typeOf :: CTypeOf c => c -> Type
getAbAb :: (CTypeOf c) => (c -> Bool) -> (c -> b) -> Ab c -> Ab b

-- | Empty: the minimum content.
class (CTypeOf c) => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c
maybeEmpty :: (CEmpty c) => (a -> c) -> Maybe a -> c
omitEmpty :: (CEmpty c) => Map [(a, c)]

-- | End of everything: the maximum content.
class (CTypeOf c) => CEnd c
isEnd :: CEnd c => c -> Bool
end :: CEnd c => c


-- | Complex content type.
module Koshucode.Baala.Data.Content.Complex

-- | List of contents.
class (CTypeOf c) => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Set of contents.
class (CTypeOf c) => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
gSetSort :: (Ord c, CSet c) => c -> [c]

-- | Tie of terms.
class (CTypeOf c) => CTie c where getTie = getAbAb isTie gTie putTie = Right . pTie
isTie :: CTie c => c -> Bool
gTie :: CTie c => c -> [Term c]
pTie :: CTie c => [Term c] -> c
getTie :: CTie c => Ab c -> Ab [Term c]
putTie :: CTie c => [Term c] -> Ab c

-- | Relation of terms.
class (CTypeOf c) => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c

-- | Nullary full relation.
dee :: (CRel c) => c

-- | Nullary empty relation.
dum :: (CRel c) => c

-- | Data intepretation.
class (CTypeOf c) => CInterp c where getInterp = getAbAb isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => Ab c -> Ab Interp
putInterp :: CInterp c => Interp -> Ab c

-- | Type of content.
class (CTypeOf c) => CType c where getType = getAbAb isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => Ab c -> Ab Type
putType :: CType c => Type -> Ab c


-- | Simple content type.
module Koshucode.Baala.Data.Content.Simple

-- | True or false, affirmed or denied.
class (CTypeOf c) => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: (CBool c) => c
false :: (CBool c) => c
putTrue :: (CBool c) => Ab c
putFalse :: (CBool c) => Ab c

-- | Decimal number.
class (CTypeOf c) => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pInt :: (CDec c) => Int -> c
pInteger :: (CDec c) => Integer -> c
pDecFromInt :: (CDec c) => Int -> c
pDecFromInteger :: (CDec c) => Integer -> c

-- | Distance between two points in timeline.
class (CTypeOf c) => CClock c where getClock = getAbAb isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => Ab c -> Ab Clock
putClock :: CClock c => Clock -> Ab c

-- | Point in timeline.
class (CTypeOf c) => CTime c where getTime = getAbAb isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => Ab c -> Ab Time
putTime :: CTime c => Time -> Ab c

-- | Code.
class (CTypeOf c) => CCode c where getCode = getAbAb isCode gCode putCode = Right . pCode
isCode :: CCode c => c -> Bool
gCode :: CCode c => c -> String
pCode :: CCode c => String -> c
getCode :: CCode c => Ab c -> Ab String
putCode :: CCode c => String -> Ab c

-- | Term name.
class (CTypeOf c) => CTerm c where getTerm = getAbAb isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c

-- | Double-quoted text content.
class (CTypeOf c) => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pMaybeText :: (CText c, CEmpty c) => String -> c


-- | Utilities for token trees.
module Koshucode.Baala.Data.Content.Tree

-- | Get text from token tree.
treeToText :: Bool -> TTreeToAb String

-- | Get digits from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "-123 450.00" &gt;&gt;= treesToDigits
--   Right "-123450.00"
--   </pre>
treesToDigits :: TTreesToAb String

-- | Get clock from token.
tokenClock :: Token -> Ab Clock

-- | Get time from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "2013-04-18 12:00" &gt;&gt;= treesToTime
--   Right (TimeYmdc (Monthly 2013-04-18) (ClockDhm 0 43200))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "2013-04-18" &gt;&gt;= treesToTime
--   Right (TimeYmd (Monthly 2013-04-18))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "2013-#16" &gt;&gt;= treesToTime
--   Right (TimeYw 2013-04-15)
--   </pre>
treesToTime :: TTreesToAb Time

-- | Get interpretation from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "term /a" &gt;&gt;= treesToInterp
--   Right (Interp { interpWords = [InterpText "term", InterpTerm "a"],
--                   interpTerms = ["a"] })
--   </pre>
treesToInterp :: TTreesToAb Interp

-- | Get flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
treeToFlatTerm :: TTreeToAb TermName

-- | Get list of named token trees from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "/a 'A3 /b 10" &gt;&gt;= treesToTerms
--   Right [("a", [TreeL ...]),
--          ("b", [TreeL ...])]
--   </pre>
treesToTerms :: TTreesToAb [NamedTrees]

-- | Get list of named token trees from token trees. This function wraps
--   long branches into group.
treesToTerms1 :: TTreesToAb [NamedTree]

module Koshucode.Baala.Data.Content.Utility
class (Ord c, Show c, MixShortEncode c, CTypeOf c, CEmpty c, CEnd c, CBool c, CCode c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CTie c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
typeOrder :: (CContent c) => c -> Int

-- | Pair of get and put.
type CGetPut a c = (c -> a, a -> c)

-- | <tt>gText</tt> and <tt>pText</tt>.
gpText :: (CText c) => CGetPut [Char] c

-- | <tt>gList</tt> and <tt>pList</tt>.
gpList :: (CList c) => CGetPut [c] c

-- | <tt>gSet</tt> and <tt>pSet</tt>.
gpSet :: (CSet c) => CGetPut [c] c

-- | <tt>gSetSort</tt> and <tt>pSet</tt>.
gpSetSort :: (Ord c, CSet c) => CGetPut [c] c

-- | Test membership between element and collection contents.
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool

-- | Apply function to internal value of content.
contAp :: (c -> a) -> (b -> d) -> (a -> b) -> c -> d

-- | Map function to internal value of content.
contMap :: (c -> [a]) -> ([b] -> d) -> (a -> b) -> c -> d
contApTextToText :: (CText c) => Map String -> AbMap c
contMapTextToList :: (CList c, CText c) => (Char -> c) -> AbMap c
judgeContString :: (CContent c) => Judge c -> Judge String

-- | Convert content to string value.
contString :: (CContent c) => c -> String
mixBracketList :: MixText -> MixText
mixBracketSet :: MixText -> MixText

-- | Minimum content of contents list.
contMinimum :: (Ord c, CEnd c) => [c] -> c

-- | Maximum content of contents list.
contMaximum :: (Ord c, CEmpty c) => [c] -> c
pTermSet :: (CTerm c, CSet c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
pTextList :: (CText c, CList c) => [String] -> c


-- | Baala content type.
module Koshucode.Baala.Data.Content.BaalaC

-- | Vanilla content type
data BaalaC

-- | Boolean type
VBool :: Bool -> BaalaC

-- | Code type
VCode :: String -> BaalaC

-- | String type
VText :: String -> BaalaC

-- | Term name type
VTerm :: String -> BaalaC

-- | Decimal number type
VDec :: Decimal -> BaalaC

-- | Clock type
VClock :: Clock -> BaalaC

-- | Time type
VTime :: Time -> BaalaC

-- | Sign of no ordinary type
VEmpty :: BaalaC

-- | The end of everything
VEnd :: BaalaC

-- | Interpretation type
VInterp :: Interp -> BaalaC

-- | Type for type
VType :: Type -> BaalaC

-- | List type (objective collection)
VList :: [BaalaC] -> BaalaC

-- | Set type (informative collection)
VSet :: [BaalaC] -> BaalaC

-- | Tie type (set of terms)
VTie :: [Named BaalaC] -> BaalaC

-- | Relation type
VRel :: (Rel BaalaC) -> BaalaC
instance GHC.Show.Show Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Singleton.CTypeOf Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Utility.CContent Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Base.Text.MixEncode.MixShortEncode Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CBool Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CDec Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CClock Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CTime Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CCode Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CText Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Complex.CList Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Singleton.CEmpty Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Singleton.CEnd Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Simple.CTerm Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Complex.CInterp Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Complex.CType Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Complex.CSet Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Complex.CTie Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Complex.CRel Koshucode.Baala.Data.Content.BaalaC.BaalaC


-- | Decode token trees to contents.
module Koshucode.Baala.Data.Content.Decode

-- | Content constructor.
type ContentCons c = TTreeToAb c

-- | Content calculator.
type ContentCalc c = TTreeToAb c

-- | Convert token tree into internal form of content.
contentCons :: (CContent c) => ContentCalc c -> ContentCons c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of resources.
treesToJudge :: (CContent c) => ContentCalc c -> AssertType -> JudgeClass -> TTreesToAb (Judge c)

-- | Type of assertions.
data AssertType

-- | <tt>|==</tt> <i>C</i> <tt>:</tt> <i>R</i> generates affirmative
--   judges.
AssertAffirm :: AssertType

-- | <tt>|=x</tt> <i>C</i> <tt>:</tt> <i>R</i> generates denial judges.
AssertDeny :: AssertType

-- | <tt>|=xx</tt> <i>C</i> <tt>:</tt> <i>R</i> generates multiple-denial
--   judges.
AssertMultiDeny :: AssertType

-- | <tt>|=c</tt> <i>C</i> <tt>:</tt> <i>R</i> generates changement judges.
AssertChange :: AssertType

-- | <tt>|=cc</tt> <i>C</i> <tt>:</tt> <i>R</i> generates
--   multiple-changement judges.
AssertMultiChange :: AssertType

-- | <tt>|=v</tt> <i>C</i> <tt>:</tt> <i>R</i> generates violation judges.
AssertViolate :: AssertType
assertAs :: AssertType -> JudgeOf c

-- | Frege's stroke and various assertion lines.
assertSymbol :: AssertType -> String
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Show.Show Koshucode.Baala.Data.Content.Decode.AssertType


-- | Content of term in judgement.
module Koshucode.Baala.Data.Content


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Build

-- | Construct content expression from token tree
coxBuild :: (CContent c) => ContentCalc c -> CopSet c -> TTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Run
type RunCox c = Cox c -> Ab c
type RunList c = [c] -> Ab c
coxRunCox :: (CContent c) => CopSet c -> Head -> [c] -> RunCox c
coxRunList :: (CContent c) => CopSet c -> Head -> Cox c -> RunList c
calcContent :: (CContent c) => CopSet c -> ContentCalc c
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)
getRightArg1 :: [Ab c] -> Ab c
getRightArg2 :: [Ab c] -> Ab (c, c)
getRightArg3 :: [Ab c] -> Ab (c, c, c)
instance Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Data.Church.Run.Beta c)

module Koshucode.Baala.Data.Church

module Koshucode.Baala.Data
