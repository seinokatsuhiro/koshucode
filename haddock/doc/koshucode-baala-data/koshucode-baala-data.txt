-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-data
@version 0.166.0.0


-- | Extra functions for rational numbers.
module Koshucode.Baala.Data.Type.Decimal.Rational

-- | <a>Rational</a> version of <a>%</a>.
(%%) :: Integer -> Integer -> Rational

-- | Integer part and proper fraction part of ratio of two numbers, i.e.,
--   <i>x</i> <a>//.</a> <i>y</i> == (<i>integer</i>,
--   <i>proper-fraction</i>) of <i>x</i> <a>%</a> <i>y</i>.
(//.) :: (Integral n) => n -> n -> (n, Ratio n)

-- | Synonym of <a>quotRem</a>.
(//) :: (Integral n) => n -> n -> (n, n)

-- | 1 <a>%</a> 2
ratioHalf :: (Integral n) => Ratio n

-- | Unit rational number for decimal fractional length.
ratioFracle :: (Integral i, Integral n) => i -> Ratio n

-- | Round rational number at decimal fractional length.
ratioRoundAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round-to-even rational number at decimal fractional length.
ratioRoundEvenAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round rational number per unit rational number.
ratioRoundPer :: (Integral n) => Bin (Ratio n)

-- | Round-to-even rational number per unit rational number.
ratioRoundEvenPer :: (Integral n) => Bin (Ratio n)

-- | Truncate rational number at decimal fractional length.
ratioTruncAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Truncate rational number per unit rational number.
ratioTruncPer :: (Integral n) => Bin (Ratio n)

-- | Round out (toward infinity) rational number at decimal fractional
--   length.
ratioRoundOutAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round out (toward infinity) rational number per unit rational number.
ratioRoundOutPer :: (Integral n) => Bin (Ratio n)

-- | Floor rational number at decimal fractional length.
ratioFloorAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Floor rational number per unit rational number.
ratioFloorPer :: (Integral n) => Bin (Ratio n)

-- | Ceiling rational number at decimal fractional length.
ratioCeilAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Ceiling rational number per unit rational number.
ratioCeilPer :: (Integral n) => Bin (Ratio n)
ratioQuo :: (Integral n) => Bin (Ratio n)
ratioRem :: (Integral n) => Bin (Ratio n)
ratioQuoRem :: (Integral n) => Ratio n -> Ratio n -> (Ratio n, Ratio n)


-- | Decimal number.
--   
--   A decimal number in Koshucode is internally represented using a
--   rational number (<a>decimalRatio</a>) with a length of fractional part
--   (<a>decimalFracle</a>) . For example, the decimal number 11.250
--   correnponds to the rational number 45/4 with the fraction length 3.
--   
--   <ul>
--   <li><i>Decimal number</i> Number represented using 10 digits and the
--   decimal separator.</li>
--   <li><i>Decimal separator</i> Symbol between integer part and
--   fractional part.</li>
--   <li><i>Fractional part</i> The right part of decimal numbers, e.g.,
--   250 for 11.250.</li>
--   <li><i>Integer part</i> The left part of decimal numbers, e.g., 11 for
--   11.250.</li>
--   <li><i>Integral decimal</i> Decimal number without fractional
--   part.</li>
--   </ul>
module Koshucode.Baala.Data.Type.Decimal.Decimal

-- | Type for numerator or denominator for decimal numbers.
type DecimalInteger = Integer

-- | Rational number of decimal type.
type DecimalRatio = Ratio DecimalInteger

-- | Length of fractional part.
type DecimalFracle = Int

-- | Decimal number.
data Decimal
Decimal :: DecimalFracle -> DecimalRatio -> Decimal

-- | Length of the fractional part
[decimalFracle] :: Decimal -> DecimalFracle

-- | Rational number for the decimal number
[decimalRatio] :: Decimal -> DecimalRatio

-- | Change decimal fracle.
decimalFracleSet :: DecimalFracle -> AbMap Decimal

-- | Map function to rational number in decimal.
decimalRatioMap :: Map DecimalRatio -> Map Decimal

-- | Binary operation for two decimals.
type BinDecimal = Bin Decimal

-- | Abortable binary operation for two decimals.
type BinAbDecimal = BinAb Decimal

-- | Combinate fracle.
type BinFracle = Bin DecimalFracle

-- | Combinate rational number.
type BinRatio = Bin DecimalRatio

-- | Binary operation for two decimals.
decimalBin :: BinFracle -> BinRatio -> BinDecimal

-- | Abortable binary operation for two decimals.
decimalBinAb :: BinFracle -> BinRatio -> BinAbDecimal

-- | Convert integral number to integral decimal number.
integralDecimal :: (Integral n) => n -> Decimal

-- | Convert real number to decimal number.
realDecimal :: (Real n) => DecimalFracle -> n -> Decimal

-- | Convert decimal number to fractional number.
decimalFractional :: (Fractional n) => Decimal -> n
instance GHC.Show.Show Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Enum.Enum Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Num.Num Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.Real Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.Fractional Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.RealFrac Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal


-- | Decimal functions.
module Koshucode.Baala.Data.Type.Decimal.Fraction

-- | Integer part of decimals.
decimalIntPart :: Map Decimal

-- | Fractional part of decimals.
decimalFracPart :: Map Decimal
decimalIntFrac :: Decimal -> (Decimal, Decimal)

-- | Numerator part of decimal number.
decimalNum :: Decimal -> DecimalInteger

-- | Denominator part of decimal number.
decimalDenom :: Decimal -> DecimalInteger

-- | Round decimal per self fractional length.
decimalRound :: Map Decimal

-- | Round decimal per fractional length.
decimalRoundAt :: Bin Decimal

-- | Round decimal per unit decimal.
decimalRoundPer :: Bin Decimal

-- | Round decimal to even per self fractional length.
decimalRoundEven :: Map Decimal

-- | Round decimal to even per fractional length.
decimalRoundEvenAt :: Bin Decimal

-- | Round decimal to even per unit decimal.
decimalRoundEvenPer :: Bin Decimal

-- | Truncate decimal per self fractional length.
decimalTrunc :: Map Decimal

-- | Truncate decimal per fractional length.
decimalTruncAt :: Bin Decimal

-- | Truncate decimal per unit decimal.
decimalTruncPer :: Bin Decimal

-- | Truncation error of decimal.
decimalTruncError :: Map Decimal

-- | Round out (toward infinity) decimal to even per self fractional
--   length.
decimalRoundOut :: Map Decimal

-- | Round out (toward infinity) decimal to even per fractional length.
decimalRoundOutAt :: Bin Decimal

-- | Round out (toward infinity) decimal to even per unit decimal.
decimalRoundOutPer :: Bin Decimal

-- | Floor decimal per self fractional length.
decimalFloor :: Map Decimal

-- | Floor decimal per fractional length.
decimalFloorAt :: Bin Decimal

-- | Floor decimal per unit decimal.
decimalFloorPer :: Bin Decimal

-- | Ceiling decimal per self fractional length.
decimalCeil :: Map Decimal

-- | Ceiling decimal per fractional length.
decimalCeilAt :: Bin Decimal

-- | Ceiling decimal per unit decimal.
decimalCeilPer :: Bin Decimal

-- | <tt>chopDigitsTrancate</tt> <i>d</i> <i>n</i> returns a number which
--   does not have the tailing <i>d</i> digits. If <i>d</i> is zero or
--   negative, it returns just <i>n</i>.
chopDigitsTrancate :: (Integral d, Integral n) => d -> n -> n

-- | <tt>chopDigitsRound</tt> is similar to <a>chopDigitsTrancate</a>, but
--   rounds chopped digit.
chopDigitsRound :: (Integral d, Integral n) => d -> n -> n

-- | Round the last (least significant) digit.
roundLastDigit :: (Integral n) => n -> n


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Data.Type.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of class, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement class represents certain sentence class
--   that gives intepretation of data. Sentence class has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c

-- | <pre>
--   |-- P /x 10 /y 20
--   </pre>
JudgeAffirm :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-x P /x 10 /y 20
--   </pre>
JudgeDeny :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-xx P /x 10 /y 20
--   </pre>
JudgeMultiDeny :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-c P /x 10 +/y 20
--   </pre>
JudgeChange :: JudgeClass -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-cc P /x 10 +/y 20
--   </pre>
JudgeMultiChange :: JudgeClass -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-v P /x 10 /y 20
--   </pre>
JudgeViolate :: JudgeClass -> [Term c] -> Judge c

-- | Name of judgement class, in other words, name of propositional
--   function.
type JudgeClass = String

-- | Map function to terms.
judgeTermsMap :: ([Term a] -> [Term b]) -> Judge a -> Judge b

-- | Prepend a term into judgement.
judgeCons :: Term c -> Map (Judge c)

-- | Construct judgement from its class and terms.
type JudgeOf c = JudgeClass -> [Term c] -> Judge c

-- | Construct affirmative judgement.
affirm :: JudgeOf c

-- | Construct denial judgement.
deny :: JudgeOf c

-- | Affirm judgement, i.e., change logical quality to affirmative.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to denial.
denyJudge :: Map (Judge c)

-- | Test which judgement is affirmed.
isAffirmative :: Judge c -> Bool

-- | Test which judgement is denied.
isDenial :: Judge c -> Bool

-- | Test which judgement is for violation.
isViolative :: Judge c -> Bool

-- | Get judge class.
class GetClass a
getClass :: GetClass a => a -> JudgeClass

-- | Get list of term names.
class GetTermNames a
getTermNames :: GetTermNames a => a -> [TermName]

-- | Get term list.
class GetTerms a
getTerms :: GetTerms a => a c -> [Term c]

-- | Conventional line-break setting for judges: 4-spaces indent and
--   120-columns line.
judgeBreak :: LineBreak

-- | Encode term name.
termNameToMix :: TermName -> MixText

-- | Encode term list with one-space separator.
termsToMix1 :: (MixShortEncode c) => Shorten -> [Term c] -> MixText

-- | Encode term list with two-spaces separator.
termsToMix2 :: (MixShortEncode c) => Shorten -> [Term c] -> MixText
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Base.Functor Koshucode.Baala.Data.Type.Judge.Judge
instance Koshucode.Baala.Data.Type.Judge.GetClass (Koshucode.Baala.Data.Type.Judge.Judge c)
instance Koshucode.Baala.Data.Type.Judge.GetTermNames (Koshucode.Baala.Data.Type.Judge.Judge c)
instance Koshucode.Baala.Data.Type.Judge.GetTermNames [Koshucode.Baala.Syntax.Symbol.Term.TermName]
instance Koshucode.Baala.Data.Type.Judge.GetTerms Koshucode.Baala.Data.Type.Judge.Judge
instance Koshucode.Baala.Base.MixText.MixEncode.MixShortEncode c => Koshucode.Baala.Base.MixText.MixEncode.MixShortEncode (Koshucode.Baala.Data.Type.Judge.Judge c)

module Koshucode.Baala.Data.Type.Type

-- | Type for types.
data Type

-- | Everything
TypeAny :: Type

-- | Type of types
TypeType :: Type

-- | Term name
TypeTerm :: Type

-- | Data interpreation
TypeInterp :: Type

-- | Empty
TypeEmpty :: Type

-- | End
TypeEnd :: Type

-- | Boolean
TypeBool :: Type

-- | Text
TypeText :: Type

-- | Code
TypeCode :: Type

-- | Decimal
TypeDec :: Type

-- | Clock
TypeClock :: (Maybe String) -> Type

-- | Time
TypeTime :: (Maybe String) -> Type

-- | Binary data
TypeBin :: Type

-- | List
TypeList :: Type -> Type

-- | Set
TypeSet :: Type -> Type

-- | Tagged type
TypeTag :: String -> Type -> Type

-- | Tie
TypeTie :: [NamedType] -> Type

-- | Relation
TypeRel :: [NamedType] -> Type

-- | Tuple (Product type)
TypeTuple :: [Type] -> Type

-- | Sum type
TypeSum :: [Type] -> Type
type NamedType = Named Type

-- | Print type as tree.
typeExplain :: Type -> Doc

-- | Encode term types.
typeTermMix :: Type -> MixText

-- | Create relation type from term names.
typeFlatRel :: [TermName] -> Type

-- | Add term name to relation type.
typeConsRel :: TermName -> Map Type

-- | Add term name and type to relation type.
typeConsNest :: TermName -> Type -> Map Type

-- | Add term names to relation type.
typeAppendRel :: [TermName] -> Map Type

-- | Get term names from relation type.
typeRelTermNames :: Type -> [TermName]

-- | Get degree of relation type.
typeRelDegree :: Type -> Int

-- | Get named type from relation type or tie type.
typeTerms :: Type -> [NamedType]

-- | Test type is relational.
isTypeRel :: Type -> Bool

-- | Calculate term index.
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeConsNest "r" (typeFlatRel ["a", "b"]) (typeFlatRel [])) ["r", "b"]
--   [0, 1]
--   </pre>
typeRelIndex :: Type -> TermPath -> [Int]

-- | Modify terms of relation type.
typeRelMapTerms :: Map [NamedType] -> Map Type

-- | Modify term of relation type.
typeRelMapTerm :: Map NamedType -> Map Type

-- | Modify term name of relation type.
typeRelMapName :: Map TermName -> Map Type
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Type.Type
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Type.Type
instance GHC.Show.Show Koshucode.Baala.Data.Type.Type.Type
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Type.Type


-- | Heading of relations
module Koshucode.Baala.Data.Type.Rel.Head

-- | Heading of relations.
data Head
Head :: Type -> Head
[headType] :: Head -> Type

-- | Pretty print head of relation.
--   
--   <pre>
--   &gt;&gt;&gt; headExplain $ headFrom ["a", "b"]
--   rel /a any
--       /b any
--   </pre>
headExplain :: Head -> Doc

-- | Make head of given type..
headOf :: Type -> Head

-- | Make head from term names.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["a", "b"]
--   Head { headType = TypeRel [("a", TypeAny), ("b", TypeAny)] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.mixEncode $ headFrom ["a", "b"]
--   MixText "/a /b"
--   </pre>
headFrom :: [TermName] -> Head

-- | Test two heads are equivalent.
headEquiv :: Head -> Head -> Bool

-- | Test heading is subset of another heading.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["a", "b"] `isSubhead` headFrom ["a", "b", "c"]
--   True
--   
--   &gt;&gt;&gt; headFrom ["a", "e"] `isSubhead` headFrom ["a", "b", "c"]
--   False
--   </pre>
isSubhead :: Head -> Head -> Bool

-- | Test heading is superset of another heading.
isSuperhead :: Head -> Head -> Bool

-- | Degree of relation, i.e., number of terms.
--   
--   <pre>
--   &gt;&gt;&gt; headDegree $ headFrom ["a", "b"]
--   2
--   </pre>
headDegree :: Head -> Int

-- | Select nested terms.
headNested :: Head -> [(TermName, Head)]

-- | Index of a term.
headIndex1 :: Head -> TermPath -> [Int]

-- | Get types of relation terms.
headTypes :: Head -> [Type]

-- | Add term name to head.
--   
--   <pre>
--   &gt;&gt;&gt; headCons "c" $ headFrom ["a", "b"]
--   Head { headType = TypeRel [("c",TypeAny), ("a",TypeAny), ("b",TypeAny)] }
--   </pre>
headCons :: TermName -> Map Head

-- | Add term names to head.
headAppend :: [TermName] -> Map Head

-- | Add term name for nested relation.
headConsNest :: TermName -> Head -> Map Head

-- | Create nested relation terms.
--   
--   <pre>
--   &gt;&gt;&gt; headNests ["x", "y"] $ headFrom ["a"]
--   Head { headType = TypeRel [("x", TypeRel [("a",TypeAny)]), ("y", TypeRel [("a",TypeAny)])] }
--   </pre>
headNests :: [TermName] -> Map Head

-- | Reconstruct head.
--   
--   <pre>
--   &gt;&gt;&gt; headMap reverse $ headFrom ["a", "b"]
--   Head {headType = TypeRel [("b",TypeAny),("a",TypeAny)]}
--   </pre>
headMap :: Map [NamedType] -> Map Head

-- | Convert term names.
--   
--   <pre>
--   &gt;&gt;&gt; headMapName ("x" ++) $ headFrom ["a", "b"]
--   Head { headType = TypeRel [("xa",TypeAny), ("xb",TypeAny)] }
--   </pre>
headMapName :: Map TermName -> Map Head

-- | Move up nested relation.
headUp :: Map Head

-- | Change order of terms.
bodyAlign :: Head -> Head -> Map [[c]]
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Show.Show Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Base.Monoid Koshucode.Baala.Data.Type.Rel.Head.Head
instance Koshucode.Baala.Data.Type.Judge.GetTermNames Koshucode.Baala.Data.Type.Rel.Head.Head
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Rel.Head.Head


-- | Relation type
module Koshucode.Baala.Data.Type.Rel.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Head -> Body c -> Rel c

-- | Heading of relation
[relHead] :: Rel c -> Head

-- | Body of relation
[relBody] :: Rel c -> Body c

-- | Body of relation, i.e., a list of tuples. Tuple is a list of contents.
type Body c = [[c]]

-- | Sort head and body of relation.
relSort :: (Ord c) => Map (Rel c)

-- | Sort relation body according to order specification.
relBodyOrder :: (Ord c) => [SignedTermName] -> Head -> Map [[c]]

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldum :: Rel Bool)
--   {= =}
--   </pre>
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldee :: Rel Bool)
--   {= [] =}
--   </pre>
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c

-- | Type for having relations.
class SelectRel r

-- | Convert judges to relation.
selectRel :: SelectRel r => r c -> JudgeClass -> [TermName] -> Rel c

-- | Convert relation to list of judges.
judgesFromRel :: JudgeOf c -> JudgeClass -> Rel c -> [Judge c]
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Base.Functor Koshucode.Baala.Data.Type.Rel.Rel.Rel
instance Koshucode.Baala.Data.Type.Judge.GetTermNames (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance Koshucode.Baala.Base.MixText.MixEncode.MixShortEncode c => Koshucode.Baala.Base.MixText.MixEncode.MixShortEncode (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)


-- | Content type for nested relations.
module Koshucode.Baala.Data.Type.Rel.Mono

-- | Content type for monotype relation.
data Mono c

-- | Terminal content
MonoTerm :: c -> Mono c

-- | Nested relation
MonoNest :: (RelMono c) -> Mono c

-- | Monotype relation.
type RelMono c = Rel (Mono c)

-- | Text relation.
type RelText = RelMono String

-- | Test terminal content.
isMonoTerm :: Mono c -> Bool

-- | Test nested relation.
isMonoNest :: Mono c -> Bool

-- | Get terminal content.
gMonoTerm :: Mono c -> c

-- | Get nested relation.
gMonoNest :: Mono c -> RelMono c

-- | Put terminal content.
pMonoTerm :: c -> Mono c

-- | Put nested relation.
pMonoNest :: RelMono c -> Mono c
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)


-- | Shared and side terms.
module Koshucode.Baala.Data.Type.Rel.ShareSide

-- | Shared and side terms.
data ShareSide c
ShareSide :: [Int] -> [Int] -> Bool -> [TermName] -> [TermName] -> [TermName] -> [TermName] -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> ([c], [c])) -> ([c] -> ([c], [c])) -> ([c] -> [c]) -> ([c] -> [c]) -> ShareSide c

-- | Indicies of right-shared part
[ssLShareIndex] :: ShareSide c -> [Int]

-- | Indicies of left-shared part
[ssRShareIndex] :: ShareSide c -> [Int]

-- | Whether shared part is empty
[ssDisjoint] :: ShareSide c -> Bool

-- | Left-side term names
[ssLSideNames] :: ShareSide c -> [TermName]

-- | Left-shared term names
[ssLShareNames] :: ShareSide c -> [TermName]

-- | Right-shared term names
[ssRShareNames] :: ShareSide c -> [TermName]

-- | Right-side term names
[ssRSideNames] :: ShareSide c -> [TermName]

-- | Pick left-side part from left contents
[ssLSide] :: ShareSide c -> [c] -> [c]

-- | Pick left-shared part from left contents
[ssLShare] :: ShareSide c -> [c] -> [c]

-- | Pick right-shared part from right contents
[ssRShare] :: ShareSide c -> [c] -> [c]

-- | Pick right-side part from right contents
[ssRSide] :: ShareSide c -> [c] -> [c]

-- | Pick right-shared and right-side part
[ssRSplit] :: ShareSide c -> [c] -> ([c], [c])

-- | Pick right-shared part and right contents
[ssRAssoc] :: ShareSide c -> [c] -> ([c], [c])
[ssRForward] :: ShareSide c -> [c] -> [c]
[ssRBackward] :: ShareSide c -> [c] -> [c]
type ShareSideMap c = ShareSide c -> [c] -> [c]
type ShareSideMap2 a b = (ShareSideMap a, ShareSideMap b)

-- | Create share-side structure from left and right term names.
--   
--   <pre>
--   &gt;&gt;&gt; let ss = shareSide ["a", "b", "c"] ["b", "c", "d", "e"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssDisjoint ss
--   False
--   </pre>
--   
--   Left terms.
--   
--   <pre>
--   &gt;&gt;&gt; ssLShareIndex ss
--   [1, 2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssLShareNames ss
--   ["b", "c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssLSide ss "ABC"
--   "A"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssLShare ss "ABC"
--   "BC"
--   </pre>
--   
--   Right terms.
--   
--   <pre>
--   &gt;&gt;&gt; ssRShareIndex ss
--   [0, 1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRShareNames ss
--   ["b", "c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRSideNames ss
--   ["d", "e"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRShare ss "BCDE"
--   "BC"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRSide ss "BCDE"
--   "DE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRSplit ss "BCDE"
--   ("BC", "DE")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRAssoc ss "BCDE"
--   ("BC", "BCDE")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRForward ss "BCDE"
--   "BCDE"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssRBackward ss "BCDE"
--   "DEBC"
--   </pre>
shareSide :: (GetTermNames l, GetTermNames r) => l -> r -> ShareSide c
shareSideOrd :: (GetTermNames l, GetTermNames r) => l -> r -> ShareSide c


-- | Relation type.
module Koshucode.Baala.Data.Type.Rel


-- | Type for data interpretation.
module Koshucode.Baala.Data.Type.Interp

-- | Data interpretation.
data Interp
Interp :: [InterpWord] -> [TermName] -> Interp

-- | Sentence which interpret data.
[interpWords] :: Interp -> [InterpWord]

-- | Terms in sentence.
[interpTerms] :: Interp -> [TermName]
data InterpWord
InterpText :: String -> InterpWord
InterpTerm :: TermName -> InterpWord
interp :: [InterpWord] -> Interp
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Show.Show Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Interp.InterpWord
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Interp.InterpWord
instance GHC.Show.Show Koshucode.Baala.Data.Type.Interp.InterpWord
instance Koshucode.Baala.Data.Type.Judge.GetTermNames Koshucode.Baala.Data.Type.Interp.Interp
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Interp.Interp
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Interp.InterpWord


-- | Message list.
module Koshucode.Baala.Data.Type.Message

-- | Divide by zero
divideByZero :: Ab a

-- | Different decimal length
heteroDecimal :: String -> String -> Ab a

-- | Can't read as date
notDate :: Integer -> Int -> Int -> Ab a

-- | Too large digit
tooLargeDigit :: String -> Ab a

-- | Can't read as number
notNumber :: String -> Ab a


-- | Decode and encode of decimals.
--   
--   <ul>
--   <li><i>Decimal</i> Head Int Frac ? Tail</li>
--   <li><i>Head</i> Sign ...</li>
--   <li><i>Int</i> Digit ...</li>
--   <li><i>Frac</i> Separator Digit ...</li>
--   <li><i>Tail</i> Sign ...</li>
--   <li><i>Sign</i> Space | <tt>"-"</tt> | <tt>"+"</tt></li>
--   <li><i>Digit</i> Space | <tt>"0"</tt> | ... | <tt>"9"</tt> |
--   <tt>"a"</tt> | ... | <tt>"z"</tt> | <tt>"A"</tt> | ... |
--   <tt>"Z"</tt></li>
--   <li><i>Separator</i> <tt>"."</tt></li>
--   <li><i>Space</i> <tt>" "</tt></li>
--   </ul>
module Koshucode.Baala.Data.Type.Decimal.Coder

-- | Decode to <tt>a</tt>.
type DecodeAb a = String -> Ab a

-- | Decode base-2 digits to decimal.
decodeBinary :: DecodeAb Decimal

-- | Decode base-8 digits to decimal.
decodeOctal :: DecodeAb Decimal

-- | Decode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11"
--   Right Decimal (0) 11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "-12 345.00"
--   Right Decimal (2) -12345
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11.250 +"
--   Right Decimal (3) 11 + 1 % 4
--   </pre>
decodeDecimal :: DecodeAb Decimal

-- | Decode base-16 digits to decimal.
decodeHex :: DecodeAb Decimal

-- | Decode digits to number.
decodeBase :: Integer -> DecodeAb Decimal

-- | Encode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal 0 (12345 D.%% 10)
--   "1 234"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal 2 (12345 D.%% 10)
--   "1 234.50"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal (-2) (12345 D.%% 10)
--   "1 2oo"
--   </pre>
encodeDecimal :: Decimal -> String

-- | Encode decimals without spaces.
encodeDecimalCompact :: Decimal -> String


-- | Arithmetics on decimals.
module Koshucode.Baala.Data.Type.Decimal.BinaryAb
data FracleSide

-- | Select longer fracle
FracleLong :: FracleSide

-- | Select left fracle
FracleLeft :: FracleSide

-- | Select right fracle
FracleRight :: FracleSide

-- | Check same fracles
FracleStrict :: FracleSide

-- | Addition: <i>x</i> + <i>y</i>
decimalAdd :: FracleSide -> BinAbDecimal

-- | Add all decimals.
decimalSum :: [Decimal] -> Ab Decimal

-- | Subtruction: <i>x</i> - <i>y</i>
decimalSub :: FracleSide -> BinAbDecimal

-- | Multiplication: <i>x</i> × <i>y</i>
decimalMul :: BinAbDecimal

-- | Division: <i>x</i> ÷ <i>y</i>
decimalDiv :: BinAbDecimal

-- | Quotient: integral part of <i>x</i> ÷ <i>y</i>
decimalQuo :: BinAbDecimal

-- | Remainder: <i>y</i> × fractional part of <i>x</i> ÷ <i>y</i>
decimalRem :: BinAbDecimal
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Decimal.BinaryAb.FracleSide
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Decimal.BinaryAb.FracleSide
instance GHC.Show.Show Koshucode.Baala.Data.Type.Decimal.BinaryAb.FracleSide

module Koshucode.Baala.Data.Type.Decimal


-- | Date.
module Koshucode.Baala.Data.Type.Time.Date

-- | Type for the Modified Julian Day.
type Mjd = Day

-- | Create MJD.
mjd :: Integer -> Mjd

-- | Extract MJD integer value.
unMjd :: Mjd -> Integer

-- | Date.
data Date

-- | Date in <i>YYYY-MM-DD</i>
Monthly :: Mjd -> Date

-- | Date in <i>YYYY-#W-D</i>
Weekly :: Mjd -> Date

-- | Date in <i>YYYY-##D</i>
Yearly :: Mjd -> Date

-- | Type for year, month, and day.
type Ymd = (Year, Month, Day)

-- | Year type.
type Year = Integer

-- | Month type.
type Month = Int

-- | Week type.
type Week = Int

-- | Day type.
type Day = Int

-- | Create date from the Modified Julian Day.
--   
--   <pre>
--   &gt;&gt;&gt; dateFromMjd 55555
--   Date 2010-12-25
--   </pre>
dateFromMjd :: Integer -> Date

-- | Create date from year, month, and day.
--   
--   <pre>
--   &gt;&gt;&gt; dateFromYmdAb 2013 4 18
--   Right Date 2013-04-18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dateFromYmdAb 2013 4 31
--   Left ...
--   </pre>
dateFromYmdAb :: Year -> Month -> Day -> Ab Date

-- | Create date from year, week, and day.
dateFromYwdAb :: Year -> Week -> Day -> Ab Date

-- | Create date from year and day.
dateFromYdAb :: Year -> Day -> Ab Date

-- | Convert into monthly date.
--   
--   <pre>
--   &gt;&gt;&gt; monthly $ dateFromMjd 55555
--   Date 2010-12-25
--   </pre>
monthly :: Map Date

-- | Convert into weekly date.
--   
--   <pre>
--   &gt;&gt;&gt; weekly $ dateFromMjd 55555
--   Date 2010-#51-6
--   </pre>
weekly :: Map Date

-- | Convert into yearly date.
--   
--   <pre>
--   &gt;&gt;&gt; yearly $ dateFromMjd 55555
--   Date 2010-##359
--   </pre>
yearly :: Map Date

-- | Get the internal Modified Julian Day.
dateMjd :: Date -> Mjd

-- | Alter the Modified Julian Day of date.
dateAltMjd :: Map Mjd -> Map Date

-- | Add days.
--   
--   <pre>
--   &gt;&gt;&gt; dateAdd 7 $ dateFromMjd 55555
--   Date 2011-01-01
--   </pre>
dateAdd :: (Integral n) => n -> Map Date

-- | Create mix text with two-width zeros.
--   
--   <pre>
--   &gt;&gt;&gt; mix02 5
--   MixText "05"
--   </pre>
mix02 :: Int -> MixText
instance GHC.Num.Num Data.Time.Calendar.Days.Day
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Date.Date
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Date.Date
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Date.Date
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Time.Date.Date


-- | Clock: distance between two times.
module Koshucode.Baala.Data.Type.Time.Clock

-- | Clock as distance between two times.
data Clock

-- | Clock represented by multiple of second
ClockDhms :: Days -> Sec -> Clock

-- | Clock represented by multiple of minute
ClockDhm :: Days -> Sec -> Clock

-- | Clock represented by multiple of hour
ClockDh :: Days -> Sec -> Clock

-- | Clock represented by multiple of day
ClockD :: Days -> Clock

-- | Integer type for the Modified Julian Day.
type Days = Integer

-- | Hour type.
type Hour = Int

-- | Minute type.
type Min = Int

-- | Second type.
type Sec = Int

-- | Convert clock to mix text.
--   
--   <pre>
--   &gt;&gt;&gt; clockBodyToMix $ clockFromDhm 0 9 40
--   MixText "09:40"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.mixEncode $ clockFromDhm 0 9 40
--   MixText "|09:40|"
--   </pre>
clockBodyToMix :: Clock -> MixText

-- | Create clock from days, hour, minute, and second.
--   
--   <pre>
--   &gt;&gt;&gt; clockFromDhms 1 9 40 20
--   |1'09:40:20|
--   </pre>
clockFromDhms :: Days -> Hour -> Min -> Sec -> Clock

-- | Create clock from days, hour, and minute.
clockFromDhm :: Days -> Hour -> Min -> Clock

-- | Create clock from days and hour.
clockFromDh :: Days -> Hour -> Clock

-- | Create clock from days.
clockFromD :: Days -> Clock

-- | Create clock from hour, minute, and optional second.
--   
--   <pre>
--   &gt;&gt;&gt; clockFromHms 9 40 Nothing
--   |09:40|
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clockFromHms 9 40 (Just 20)
--   |09:40:20|
--   </pre>
clockFromHms :: Hour -> Min -> Maybe Sec -> Clock

-- | Decompose second into days, hour, minute and second parts.
--   
--   <pre>
--   &gt;&gt;&gt; dhmsFromSec 333333
--   (3,9,15,33)
--   </pre>
dhmsFromSec :: Sec -> (Days, Hour, Min, Sec)

-- | Aggregate hour, minute, and second into single second.
secFromHms :: (Hour, Min, Sec) -> Sec

-- | Days and second of clock.
--   
--   <pre>
--   &gt;&gt;&gt; clockDaysSec $ clockFromDhms 1 9 15 33
--   (1, 33333)
--   </pre>
clockDaysSec :: Clock -> DaysSec

-- | Split days part from clock.
--   
--   <pre>
--   &gt;&gt;&gt; clockDaysClock $ clockFromDhms 1 9 15 33
--   (1, |09:15:33|)
--   </pre>
clockDaysClock :: Clock -> (Days, Clock)

-- | Sign of clock as <tt>-1</tt>, <tt>0</tt>, <tt>1</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clockSign $ clockFromDhms 1 9 15 33
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clockSign $ clockFromDhms 0 0 0 0
--   0
--   </pre>
clockSign :: Clock -> Int

-- | Precision string of clock.
clockPrecision :: Clock -> String

-- | Extract elements of clock.
clockDhms :: Clock -> (Days, Maybe Hour, Maybe Min, Maybe Sec)

-- | Replace elements of clock.
clockAlter :: Maybe Days -> Maybe Hour -> Maybe Min -> Maybe Sec -> Map Clock

-- | Map MDJ and second of clock.
clockMap :: Map Days -> Map Sec -> Map Clock

-- | Combine MDJ and second of two clocks.
clockMap2 :: Bin Days -> Bin Sec -> BinAb Clock

-- | Days and seconds.
type DaysSec = (Days, Sec)

-- | Calculate days and seconds.
--   
--   <pre>
--   &gt;&gt;&gt; daysSec 777777
--   (9, 177)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; daysSec (-777777)
--   (-10, 86223)
--   </pre>
daysSec :: Sec -> DaysSec

-- | Seconds in a day, i.e., 86400 seconds.
--   
--   <pre>
--   &gt;&gt;&gt; daySeconds :: Int
--   86400
--   </pre>
daySeconds :: (Num a) => a
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Clock.Clock
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Clock.Clock
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Clock.Clock
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Time.Clock.Clock


-- | Calculation on clock.
module Koshucode.Baala.Data.Type.Time.ClockCalc

-- | Convert clock to positive clock.
clockPos :: Map Clock

-- | Convert clock to negative clock.
clockNeg :: Map Clock

-- | Set MJD to zero.
clockCutDay :: Map Clock

-- | Add MJD.
clockAddDay :: Days -> Map Clock

-- | Add second.
clockAddSec :: Sec -> Map Clock

-- | Calculation of clock plus clock.
clockAdd :: BinAb Clock

-- | Calculation of clock minus clock.
clockSub :: BinAb Clock

-- | Multiplication of clock.
clockTimes :: Int -> Map Clock

-- | Create sequence between two clocks.
--   
--   <pre>
--   &gt;&gt;&gt; clockRangeBy (clockStep 120) (clockFromDhm 0 0 0) (clockFromDhm 0 0 5)
--   [|00:00:00|, |00:02:00|, |00:04:00|]
--   </pre>
clockRangeBy :: Map (Days, Sec) -> RangeBy Clock

-- | Create clock step of given second.
clockStep :: Sec -> Map (Days, Sec)


-- | Time
module Koshucode.Baala.Data.Type.Time.Time

-- | Time is a small duration on timeline.
data Time

-- | Date and clock with time zone
TimeYmdcz :: Date -> Clock -> Zone -> Time

-- | Date and clock
TimeYmdc :: Date -> Clock -> Time

-- | Year, month, and day
TimeYmd :: Date -> Time

-- | Year and week
TimeYw :: Mjd -> Time

-- | Year and month
TimeYm :: Mjd -> Time

-- | Time zone as offset from UTC.
type Zone = Sec

-- | Get integer content of the Modified Julian Day of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeMjd $ timeFromMjd 55555
--   55555
--   </pre>
timeMjd :: Time -> Days

-- | Convert time to year/month/day tuple.
--   
--   <pre>
--   &gt;&gt;&gt; timeYmdTuple $ timeFromMjd 55555
--   (2010,12,25)
--   </pre>
timeYmdTuple :: Time -> Ymd

-- | Get the name of time precision.
timePrecision :: Time -> String

-- | Create monthly date from the Modified Julian Day.
timeYmd :: Mjd -> Time

-- | Create monthly time from the Modified Julian Day and clock.
timeYmdc :: Mjd -> Clock -> Time

-- | Create time data form modified Julian date.
--   
--   <pre>
--   &gt;&gt;&gt; timeFromMjd 55555
--   2010-12-25
--   </pre>
timeFromMjd :: Days -> Time

-- | Create time data from year and month.
timeFromYmAb :: Year -> Month -> Ab Time

-- | Create time data from year and week.
timeFromYwAb :: Year -> Week -> Ab Time

-- | Create time data from date, clock, and time zone.
timeFromDczAb :: Date -> Clock -> Maybe Zone -> Ab Time
timeFromYmd :: Year -> Month -> Day -> Time
timeFromYmdTuple :: Ymd -> Time

-- | Get UTC.
--   
--   <pre>
--   &gt;&gt;&gt; nowUtc
--   2013-04-18 08:37:36 UTC
--   </pre>
nowUtc :: IO Time

-- | Get current time with time zone.
--   
--   <pre>
--   &gt;&gt;&gt; nowZoned
--   2013-04-18 17:37:36 +09:00
--   </pre>
nowZoned :: IO Time

-- | Get current local time without time zone.
--   
--   <pre>
--   &gt;&gt;&gt; now
--   2013-04-18 17:37:36
--   </pre>
now :: IO Time

-- | Get today.
--   
--   <pre>
--   &gt;&gt;&gt; today
--   2013-04-18
--   </pre>
today :: IO Time

-- | Cut clock part.
timeCutClock :: Map Time

-- | Alter time zone part.
timeAltZone :: Map Zone -> Map Time

-- | Cut timezone.
timeCutZone :: Map Time

-- | Cut timezone and convert to local time, i.e., addition of UTC and time
--   zone.
timeLocalize :: Map Time

-- | Alter day part.
timeAltDate :: Map Date -> Map Time

-- | Alter integer content of the Modified Julian Day.
timeAltDays :: Map Days -> Map Time

-- | Convert local time to Koshu time content.
timeFromZonedTime :: ZonedTime -> Time

-- | Days and seconds of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeDaysSec $ timeFromMjd 55555
--   (55555,0)
--   </pre>
timeDaysSec :: Time -> DaysSec
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Time.Time
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Time.Time
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Time.Time
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Data.Type.Time.Time.Time


-- | Calculation on time.
module Koshucode.Baala.Data.Type.Time.TimeCalc

-- | Add days to time.
timeAddDay :: Days -> Map Time

-- | Add weeks to time.
timeAddWeek :: Integer -> Map Time

-- | Add months to time.
timeAddMonth :: Integer -> Map Time

-- | Add years to time.
timeAddYear :: Year -> Map Time

-- | Add clock to time.
timeAddClock :: Clock -> AbMap Time

-- | Calculate clock from time to time.
timeDiff :: Time -> Time -> Ab Clock

-- | Convert to the first day of month.
--   
--   <pre>
--   &gt;&gt;&gt; timeFloorMonth $ timeFromYmd 2014 11 3
--   2014-11-01
--   </pre>
timeFloorMonth :: Map Time

-- | Convert to the first day of year.
--   
--   <pre>
--   &gt;&gt;&gt; timeFloorYear $ timeFromYmd 2014 11 3
--   2014-01-01
--   </pre>
timeFloorYear :: Map Time

-- | Convert to the first day of next month.
--   
--   <pre>
--   &gt;&gt;&gt; timeCeilMonth $ timeFromYmd 2014 11 3
--   2014-12-01
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timeCeilMonth $ timeFromYmd 2014 12 25
--   2015-01-01
--   </pre>
timeCeilMonth :: Map Time

-- | Convert to the first day of next year.
--   
--   <pre>
--   &gt;&gt;&gt; timeCeilYaer $ timeFromYmd 2014 11 3
--   2015-01-01
--   </pre>
timeCeilYaer :: Map Time

-- | Create range of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeRangeDay (timeFromYmd 2014 11 3) (timeFromYmd 2014 11 5)
--   [2014-11-03, 2014-11-04, 2014-11-05]
--   </pre>
timeRangeDay :: RangeBy Time

-- | Create range of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeRangeMonth (timeFromYmd 2014 12 31) (timeFromYmd 2015 03 5)
--   [2014-12-31, 2015-01-31, 2015-02-28]
--   </pre>
timeRangeMonth :: RangeBy Time

-- | Create range of time.
timeRangeYear :: RangeBy Time


-- | Bundle of time modules.
module Koshucode.Baala.Data.Type.Time


-- | Message list.
module Koshucode.Baala.Data.Content.Message

-- | Abortable scope for literal.
abLiteral :: TTreeTo (Map (Ab b))

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Int -> Int -> Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require tuple in list
reqRelTuple :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown type name
unkType :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a

-- | Expect and actual.
expectActual :: String -> String -> [String]

-- | Expect (2 lines) and actual.
expect2Actual :: String -> String -> String -> [String]


-- | Message list.
module Koshucode.Baala.Data.Class.Message

-- | Type unmatch
unmatchType :: String -> Ab a


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Data.Type


-- | Message list.
module Koshucode.Baala.Data.Church.Message

-- | Abortable scope for cox building.
abCoxBuild :: TTreeTo (MapAb b)

-- | Abortable scope for cox calculation.
abCoxCalc :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for cox filling.
abCoxFill :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for irreducible expression.
abCoxIrrep :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for cox position.
abCoxPosition :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for cox prefix.
abCoxPrefix :: TTreeTo (MapAb b)

-- | Abortable scope for cox reduction.
abCoxReduce :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for cox syntax.
abCoxSyntax :: TTreeTo (MapAb b)

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown object
unkShow :: (Show x) => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Head -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a

-- | Terms and input relation heading.
detailTermRel :: String -> [TermName] -> Head -> [String]


-- | Bundle of message modules.
module Koshucode.Baala.Data.Message


-- | Term-content expression.
module Koshucode.Baala.Data.Church.Cox

-- | Term-content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Content calculator
CoxCalc :: [CodePt] -> BlankName -> (CopCalc c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> CoxTag -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c

-- | Expression pair.
type Cox2 c = (Cox c, Cox c)

-- | Expression triple.
type Cox3 c = (Cox c, Cox c, Cox c)

-- | Expression quadruple.
type Cox4 c = (Cox c, Cox c, Cox c, Cox c)

-- | Maybe expression.
type MaybeCox c = Maybe (Cox c)

-- | Named expression.
type NamedCox c = Named (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c

-- | Expression tag.
type CoxTag = Maybe String

-- | Create literal expression.
coxLit :: c -> Cox c

-- | Get arity of expression.
coxSyntacticArity :: Cox c -> Int

-- | Map expression form.
coxMap :: Map (Map (Cox c))

-- | Fill expression form.
coxCall :: Cox c -> (Map (Cox c)) -> Cox c

-- | Check irreducible expression.
checkIrreducible :: AbMap (Cox c)
instance Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Data.Church.Cox.Cox c)
instance Koshucode.Baala.Base.MixText.MixEncode.MixShortEncode c => GHC.Show.Show (Koshucode.Baala.Data.Church.Cox.Cox c)


-- | Term-content operator.
module Koshucode.Baala.Data.Church.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TTree] -> Ab TTree

-- | Name of content operator.
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName

-- | Set of content operators.
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
[copsetCopList] :: CopSet c -> [Cop c]
[copsetInfixList] :: CopSet c -> [Named InfixHeight]
[copsetCalcList] :: CopSet c -> [Named (Cop c)]
[copsetCoxList] :: CopSet c -> [Named (Cop c)]
[copsetTreeList] :: CopSet c -> [Named (Cop c)]
[copsetFindCalc] :: CopSet c -> CopFind (Cox c)
[copsetFindCox] :: CopSet c -> CopFind (CopCox c)
[copsetFindTree] :: CopSet c -> CopFind CopTree
[copsetDerived] :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Empty operator set.
copset :: CopSet c

-- | Complete operator set.
copsetFill :: Map (CopSet c)
instance GHC.Show.Show (Koshucode.Baala.Data.Church.Cop.Cop c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Data.Church.Cop.Cop c)


-- | Term content parsers.
module Koshucode.Baala.Data.Content.Tree

-- | Get text from token tree.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt1 "aa" &gt;&gt;= treeToText False
--   Right "aa"
--   </pre>
treeToText :: Bool -> TTreeToAb String

-- | Get digits from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "-123 450.00" &gt;&gt;= treesToDigits
--   Right "-123450.00"
--   </pre>
treesToDigits :: TTreesToAb String

-- | Get clock from token.
--   
--   <pre>
--   &gt;&gt;&gt; tokenClock $ head $ S.toks "|12:00|"
--   Right |12:00|
--   </pre>
tokenClock :: Token -> Ab Clock

-- | Get time from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "2013-04-18 12:00" &gt;&gt;= treesToTime
--   Right 2013-04-18 12:00
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "2013-04-18" &gt;&gt;= treesToTime
--   Right 2013-04-18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "2013-#16" &gt;&gt;= treesToTime
--   Right 2013-#16
--   </pre>
treesToTime :: TTreesToAb Time

-- | Get time from string.
--   
--   <pre>
--   &gt;&gt;&gt; ttTime "2013-04-18 12:00"
--   Right 2013-04-18 12:00
--   </pre>
ttTime :: String -> Ab Time

-- | Get interpretation from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "term /a" &gt;&gt;= treesToInterp
--   Right (Interp { interpWords = [InterpText "term", InterpTerm "a"],
--                   interpTerms = ["a"] })
--   </pre>
treesToInterp :: TTreesToAb Interp

-- | Get flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt1 "/a" &gt;&gt;= treeToFlatTerm
--   Right "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.tt1 "/a/x" &gt;&gt;= treeToFlatTerm
--   Left ...
--   </pre>
treeToFlatTerm :: TTreeToAb TermName

-- | Get list of named token trees from token trees.
--   
--   <pre>
--   &gt;&gt;&gt; S.tt "/a 'A3 /b 10" &gt;&gt;= treesToTerms
--   Right [("a", [TreeL ...]),
--          ("b", [TreeL ...])]
--   </pre>
treesToTerms :: TTreesToAb [NamedTrees]

-- | Get list of named token trees from token trees. This function wraps
--   long branches into group.
treesToTerms1 :: TTreesToAb [NamedTree]


-- | Singleton content type.
module Koshucode.Baala.Data.Class.Singleton

-- | Classifiable into <a>Type</a>.
class CTypeOf c

-- | Get type of content.
typeOf :: CTypeOf c => c -> Type

-- | Get content which may be aborted.
getContent :: (CTypeOf c) => Test c -> (c -> b) -> Ab c -> Ab b

-- | Empty: the minimum content.
class (CTypeOf c) => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c

-- | Create empty or non-empty content.
maybeEmpty :: (CEmpty c) => (a -> c) -> Maybe a -> c

-- | Cut empty terms.
omitEmpty :: (CEmpty c) => Map [Term c]

-- | Maximum content of contents list.
contMaximum :: (Ord c, CEmpty c) => [c] -> c

-- | End of everything: the maximum content.
class (CTypeOf c) => CEnd c
isEnd :: CEnd c => c -> Bool
end :: CEnd c => c

-- | Minimum content of contents list.
contMinimum :: (Ord c, CEnd c) => [c] -> c


-- | Simple content type.
module Koshucode.Baala.Data.Class.Simple

-- | True or false, affirmed or denied.
class (CTypeOf c) => CBool c where getBool = getContent isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c

-- | Boolean constant true.
true :: (CBool c) => c

-- | Boolean constant false.
false :: (CBool c) => c

-- | Boolean constant true.
putTrue :: (CBool c) => Ab c

-- | Boolean constant false.
putFalse :: (CBool c) => Ab c

-- | Decimal number.
class (CTypeOf c) => CDec c where getDec = getContent isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c

-- | Create decimal content.
pInt :: (CDec c) => Int -> c

-- | Create decimal content.
pInteger :: (CDec c) => Integer -> c

-- | Create decimal content.
pIntegral :: (CDec c, Integral n) => n -> c

-- | Distance between two points in timeline.
class (CTypeOf c) => CClock c where getClock = getContent isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => Ab c -> Ab Clock
putClock :: CClock c => Clock -> Ab c

-- | Point in timeline.
class (CTypeOf c) => CTime c where getTime = getContent isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => Ab c -> Ab Time
putTime :: CTime c => Time -> Ab c

-- | Code.
class (CTypeOf c) => CCode c where getCode = getContent isCode gCode putCode = Right . pCode
isCode :: CCode c => c -> Bool
gCode :: CCode c => c -> String
pCode :: CCode c => String -> c
getCode :: CCode c => Ab c -> Ab String
putCode :: CCode c => String -> Ab c

-- | Term name.
class (CTypeOf c) => CTerm c where getTerm = getContent isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c

-- | Double-quoted text content.
class (CTypeOf c) => CText c where getText = getContent isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c

-- | Create Text or empty content.
--   
--   <pre>
--   &gt;&gt;&gt; pMaybeText "a" :: BaalaC
--   VText "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pMaybeText "" :: BaalaC
--   VEmpty
--   </pre>
pMaybeText :: (CText c, CEmpty c) => String -> c


-- | Complex content type.
module Koshucode.Baala.Data.Class.Complex

-- | List of contents.
class (CTypeOf c) => CList c where getList = getContent isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Create list of text contents.
pTextList :: (CText c, CList c) => [String] -> c

-- | Set of contents.
class (CTypeOf c) => CSet c where getSet = getContent isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c

-- | Create set of term contents.
pTermSet :: (CTerm c, CSet c) => [String] -> c

-- | Create set of text contents.
pTextSet :: (CText c, CSet c) => [String] -> c

-- | Sorted version of <a>gSet</a>.
gSetSort :: (Ord c, CSet c) => c -> [c]

-- | Test membership between element and collection contents.
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool

-- | Tie of terms.
class (CTypeOf c) => CTie c where getTie = getContent isTie gTie putTie = Right . pTie
isTie :: CTie c => c -> Bool
gTie :: CTie c => c -> [Term c]
pTie :: CTie c => [Term c] -> c
getTie :: CTie c => Ab c -> Ab [Term c]
putTie :: CTie c => [Term c] -> Ab c

-- | Relation of terms.
class (CTypeOf c) => CRel c where getRel = getContent isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c

-- | The nullary full relation.
dee :: (CRel c) => c

-- | The nullary empty relation.
dum :: (CRel c) => c

-- | Data intepretation.
class (CTypeOf c) => CInterp c where getInterp = getContent isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => Ab c -> Ab Interp
putInterp :: CInterp c => Interp -> Ab c

-- | Type of content.
class (CTypeOf c) => CType c where getType = getContent isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => Ab c -> Ab Type
putType :: CType c => Type -> Ab c


-- | Generic content class.
module Koshucode.Baala.Data.Class.Content

-- | Generic content class.
class (Ord c, Show c, MixShortEncode c, CTypeOf c, CEmpty c, CEnd c, CBool c, CCode c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CTie c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c

-- | Order of type.
typeOrder :: (CContent c) => c -> Int


-- | Classes for term contents.
module Koshucode.Baala.Data.Class


-- | Decode token trees to contents.
module Koshucode.Baala.Data.Content.Decode

-- | Content constructor.
type ContentCons c = TTreeToAb c

-- | Content calculator.
type ContentCalc c = TTreeToAb c

-- | Convert token tree into internal form of content.
contentCons :: (CContent c) => ContentCalc c -> ContentCons c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of resources.
treesToJudge :: (CContent c) => ContentCalc c -> AssertType -> JudgeClass -> TTreesToAb (Judge c)

-- | Type of assertions.
data AssertType

-- | <tt>|==</tt> <i>C</i> <tt>:</tt> <i>R</i> generates affirmative
--   judges.
AssertAffirm :: AssertType

-- | <tt>|=x</tt> <i>C</i> <tt>:</tt> <i>R</i> generates denial judges.
AssertDeny :: AssertType

-- | <tt>|=xx</tt> <i>C</i> <tt>:</tt> <i>R</i> generates multiple-denial
--   judges.
AssertMultiDeny :: AssertType

-- | <tt>|=c</tt> <i>C</i> <tt>:</tt> <i>R</i> generates changement judges.
AssertChange :: AssertType

-- | <tt>|=cc</tt> <i>C</i> <tt>:</tt> <i>R</i> generates
--   multiple-changement judges.
AssertMultiChange :: AssertType

-- | <tt>|=v</tt> <i>C</i> <tt>:</tt> <i>R</i> generates violation judges.
AssertViolate :: AssertType
assertAs :: AssertType -> JudgeOf c

-- | Frege's stroke and various assertion lines.
assertSymbol :: AssertType -> String
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Show.Show Koshucode.Baala.Data.Content.Decode.AssertType


-- | Utilities for term contents.
module Koshucode.Baala.Data.Content.Utility

-- | Pair of get and put.
type CGetPut a c = (c -> a, a -> c)

-- | <tt>gText</tt> and <tt>pText</tt>.
gpText :: (CText c) => CGetPut [Char] c

-- | <tt>gList</tt> and <tt>pList</tt>.
gpList :: (CList c) => CGetPut [c] c

-- | <tt>gSet</tt> and <tt>pSet</tt>.
gpSet :: (CSet c) => CGetPut [c] c

-- | <tt>gSetSort</tt> and <tt>pSet</tt>.
gpSetSort :: (Ord c, CSet c) => CGetPut [c] c

-- | Apply function to internal value of content.
--   
--   <pre>
--   &gt;&gt;&gt; contAp gText pText reverse (pText "abc" :: BaalaC) :: BaalaC
--   VText "cba"
--   </pre>
contAp :: (a' -> a) -> (b -> b') -> (a -> b) -> a' -> b'

-- | Map function to internal value of content.
contMap :: (Functor f) => (a' -> f a) -> (f b -> b') -> (a -> b) -> a' -> b'
contApTextToText :: (CText c) => Map String -> AbMap c
contMapTextToList :: (CList c, CText c) => (Char -> c) -> AbMap c

-- | Convert term content to string value.
judgeContString :: (CContent c) => Judge c -> Judge String

-- | Convert content to string value.
--   
--   <pre>
--   &gt;&gt;&gt; contString (pText "a" :: BaalaC)
--   "a"
--   </pre>
contString :: (CContent c) => c -> String

-- | Enclose mix text in list brackets.
--   
--   <pre>
--   &gt;&gt;&gt; mixBracketList $ B.mixString "a"
--   MixText "[ a ]"
--   </pre>
mixBracketList :: MixText -> MixText

-- | Enclose mix text in set brackets.
--   
--   <pre>
--   &gt;&gt;&gt; mixBracketSet $ B.mixString "a"
--   MixText "{ a }"
--   </pre>
mixBracketSet :: MixText -> MixText


-- | The Baala content type.
module Koshucode.Baala.Data.Content.BaalaC

-- | Shorthand function for the Baala content type.
--   
--   <pre>
--   &gt;&gt;&gt; the $ D.pText "a"
--   VText "a"
--   </pre>
the :: BaalaC -> BaalaC

-- | The Baala content type.
data BaalaC

-- | Boolean type
VBool :: Bool -> BaalaC

-- | Code type
VCode :: String -> BaalaC

-- | String type
VText :: String -> BaalaC

-- | Term name type
VTerm :: String -> BaalaC

-- | Decimal number type
VDec :: Decimal -> BaalaC

-- | Clock type
VClock :: Clock -> BaalaC

-- | Time type
VTime :: Time -> BaalaC

-- | Sign of no ordinary type
VEmpty :: BaalaC

-- | The end of everything
VEnd :: BaalaC

-- | Interpretation type
VInterp :: Interp -> BaalaC

-- | Type for type
VType :: Type -> BaalaC

-- | List type (objective collection)
VList :: [BaalaC] -> BaalaC

-- | Set type (informative collection)
VSet :: [BaalaC] -> BaalaC

-- | Tie type (set of terms)
VTie :: [Named BaalaC] -> BaalaC

-- | Relation type
VRel :: (Rel BaalaC) -> BaalaC
instance GHC.Show.Show Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Singleton.CTypeOf Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Content.CContent Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Base.MixText.MixEncode.MixShortEncode Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CBool Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CDec Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CClock Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CTime Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CCode Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CText Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Complex.CList Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Singleton.CEmpty Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Singleton.CEnd Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Simple.CTerm Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Complex.CInterp Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Complex.CType Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Complex.CSet Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Complex.CTie Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Class.Complex.CRel Koshucode.Baala.Data.Content.BaalaC.BaalaC


-- | Content of term in judgement.
module Koshucode.Baala.Data.Content


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Build

-- | Construct content expression from token tree
coxBuild :: (CContent c) => ContentCalc c -> CopSet c -> TTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calculation.
module Koshucode.Baala.Data.Church.Run

-- | Tuple-to-content calculation.
type RunList c = [c] -> Ab c

-- | Calculate content expression with specific tuple.
coxRunCox :: (CContent c) => CopSet c -> Head -> [c] -> Cox c -> Ab c

-- | Calculate content expression with specific tuple.
coxRunList :: (CContent c) => CopSet c -> Head -> Cox c -> RunList c

-- | Calculate content expression.
calcContent :: (CContent c) => CopSet c -> ContentCalc c

-- | Extract single argument.
getArg1 :: [Ab c] -> Ab (Ab c)

-- | Extract two arguments.
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)

-- | Extract three arguments.
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)

-- | Extract single non-abortable argument.
getRightArg1 :: [Ab c] -> Ab c

-- | Extract two non-abortable arguments.
getRightArg2 :: [Ab c] -> Ab (c, c)

-- | Extract three non-abortable arguments.
getRightArg3 :: [Ab c] -> Ab (c, c, c)
instance Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Data.Church.Run.Beta c)


-- | Content calculation.
module Koshucode.Baala.Data.Church


-- | Bundle of data modules.
module Koshucode.Baala.Data
