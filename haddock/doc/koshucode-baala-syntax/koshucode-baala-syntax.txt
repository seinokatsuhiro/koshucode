-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Syntax for Koshucode
--   
--   Syntax for Koshucode
@package koshucode-baala-syntax
@version 0.158.0.0

module Koshucode.Baala.Syntax.Symbol.Term

-- | Name of term, e.g., <tt>"file"</tt> for the term name <tt>/file</tt>.
type TermName = String
type TermName2 = (String, String)
type TermName3 = (String, String, String)
type TermName4 = (String, String, String, String)
type TermName5 = (String, String, String, String, String)
type TermName6 = (String, String, String, String, String, String)

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]
type SignedTermName = (Ordering, TermName)
showTermName :: TermName -> String
showTermPath :: TermPath -> String
type Term c = (TermName, c)
term :: TermName -> c -> Term c

-- | Check present term.
termP :: Int -> Bool

-- | Check new term.
termN :: Int -> Bool
termPN :: Int -> Int -> Bool
termsP :: [Int] -> Bool
termsN :: [Int] -> Bool
termsPN :: [Int] -> [Int] -> Bool


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Syntax.Symbol.AngleText

-- | Convert string into double-quoted and angle-quoted form.
angleQuote :: Map String

-- | Table of coresspondences of angle text and its replacement.
angleTexts :: [(String, String)]


-- | Parameter type.
module Koshucode.Baala.Syntax.Para.Para
data Para n a
Para :: [String] -> [a] -> [a] -> ParaMap n a -> Para n a

-- | Parameter tags.
[paraTags] :: Para n a -> [String]

-- | All parameter elements.
[paraAll] :: Para n a -> [a]

-- | Positional parameters.
[paraPos] :: Para n a -> [a]

-- | Named parameters.
[paraName] :: Para n a -> ParaMap n a

-- | Mapping parameter name to its contents.
type ParaMap n a = Map n [[a]]

-- | Test and take parameter name.
type ParaName n a = a -> Maybe n

-- | Parse list into parameter.
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b"
--   Para { paraAll = ["a","b"], paraPos = ["a","b"], paraName = fromList [] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b -x c d"
--   Para { paraAll = ["a","b","-x","c"]
--        , paraPos = ["a","b"]
--        , paraName = fromList [("x",[["c","d"]])] }
--   </pre>
para :: (Ord n) => ParaName n a -> [a] -> Para n a

-- | Association list of named parameters.
paraNameList :: Para n a -> [(n, [[a]])]

-- | List of parameter names.
paraNames :: Para n a -> [n]

-- | List of names which appear more than once.
paraMultipleNames :: Para n a -> [n]

-- | Lookup named parameter.
paraLookup :: (Ord n) => n -> Para n a -> Maybe [[a]]

-- | Lookup single-occurence parameter.
paraLookupSingle :: (Ord n) => n -> Para n a -> Maybe [a]

-- | Give names to positional parameters.
paraPosName :: (Ord n, Monad m) => ([a] -> m [(n, [a])]) -> Para n a -> m (Para n a)

-- | Add named parameter.
paraNameAdd :: (Ord n) => n -> [a] -> Map (Para n a)

-- | Map names of named parameters.
paraNameMapKeys :: (Ord n2) => (n1 -> n2) -> Para n1 a -> Para n2 a
paraTakeFirst :: (Ord n) => n -> Para n a -> Para n a
paraTakeLast :: (Ord n) => n -> Para n a -> Para n a

-- | String-named parameter.
type SimplePara a = Para String a

-- | Composition of word separation and parameter parsing.
paraWords :: (Ord n) => ParaName n String -> String -> Para n String

-- | Parameter name is beginning with hyphen.
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "-foo"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "bar"
--   Nothing
--   </pre>
paraHyphen :: ParaName String String
instance (GHC.Classes.Ord n, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Classes.Eq n, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance GHC.Classes.Ord n => GHC.Base.Monoid (Koshucode.Baala.Syntax.Para.Para.Para n a)


-- | Parameter specification.
module Koshucode.Baala.Syntax.Para.ParaSpec

-- | Parameter specification.
data ParaSpec n
ParaSpec :: ParaSpecPos n -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> ParaSpec n

-- | Positional parameter
[paraSpecPos] :: ParaSpec n -> ParaSpecPos n

-- | Positional required parameters
[paraSpecReqP] :: ParaSpec n -> [n]

-- | Positional optional parameters
[paraSpecOptP] :: ParaSpec n -> [n]

-- | Explicitly-named required parameters
[paraSpecReqN] :: ParaSpec n -> [n]

-- | Explicitly-named optional parameters
[paraSpecOptN] :: ParaSpec n -> [n]

-- | Allow multiple-occurence, use first parameters
[paraSpecFirst] :: ParaSpec n -> [n]

-- | Allow multiple-occurence, use last parameters
[paraSpecLast] :: ParaSpec n -> [n]

-- | Allow multiple-occurence, use all parameters
[paraSpecMulti] :: ParaSpec n -> [n]

-- | Name list of all parameters.
paraSpecNames :: ParaSpec n -> [n]

-- | Name list of positional parameters.
paraSpecNamesP :: ParaSpec n -> [n]

-- | Name list of explicitly-named parameters.
paraSpecNamesN :: ParaSpec n -> [n]

-- | Positional parameter specification.
data ParaSpecPos n

-- | Named positional parameters
ParaItem :: Int -> [n] -> ParaSpecPos n

-- | Named positional and optional parameters
ParaItemOpt :: Int -> [n] -> [n] -> ParaSpecPos n

-- | Named positional and rest parameters
ParaItemRest :: Int -> [n] -> n -> ParaSpecPos n

-- | Lower bound of parameter length
ParaMin :: Int -> ParaSpecPos n

-- | Lower and upper bound of parameter length
ParaRange :: Int -> Int -> ParaSpecPos n

-- | Minimal length of positional parameters.
paraMinLength :: ParaSpecPos n -> Int

-- | Unmatch reason of real parameter and its specifition.
data ParaUnmatch n

-- | Positional parameter is unmatched.
ParaOutOfRange :: Int -> (ParaSpecPos n) -> ParaUnmatch n

-- | Unknown parameter is specified.
ParaUnknown :: [n] -> ParaUnmatch n

-- | Required parameter is missing.
ParaMissing :: [n] -> ParaUnmatch n

-- | Parameter occurs more than once.
ParaMultiple :: [n] -> ParaUnmatch n

-- | Test and revise parameter to satisfy specification.
paraMatch :: (Eq n, Ord n) => ParaSpec n -> Para n a -> Either (ParaUnmatch n) (Para n a)

-- | Map parameter to some value.
type ParaTo n a b = Para n a -> b

-- | Select matched specification and apply <a>ParaTo</a> function.
paraSelect :: (Eq n, Ord n) => b -> [(ParaSpec n, ParaTo n a b)] -> ParaTo n a b
paraChoose :: (Ord n) => [(Maybe String, ParaSpec n)] -> Para n a -> Either [ParaUnmatch n] (Para n a)
type ParaSpecMap n = Map (ParaSpec n)
paraSpec :: (Show n, Ord n) => ParaSpecMap n -> ParaSpec n

-- | Lower bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMin 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaOutOfRange ...
--   </pre>
paraMin :: Int -> ParaSpecMap n

-- | Upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMax 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Left ParaOutOfRange ...
--   </pre>
paraMax :: Int -> ParaSpecMap n

-- | Fixed-length positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraJust 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaOutOfRange ...
--   </pre>
paraJust :: Int -> ParaSpecMap n

-- | Lower and upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraRange 1 2
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Left ParaOutOfRange ...
--   </pre>
paraRange :: Int -> Int -> ParaSpecMap n

-- | No positional parameter.
para0 :: ParaSpecMap n

-- | Named one positional parameter.
para1 :: n -> ParaSpecMap n

-- | Named two positional parameters.
para2 :: n -> n -> ParaSpecMap n

-- | Named three positional parameters.
para3 :: n -> n -> n -> ParaSpecMap n

-- | Named arbitrary positional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItem ["x", "y", "z", "w"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]), ..., ("w",[["d"]])] })
--   </pre>
paraItem :: [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemOpt ["x", "y"] ["z"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]])] })
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c"]])] })
--   </pre>
paraItemOpt :: [n] -> [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemRest ["x", "y"] "z"
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c","d"]])] })
--   </pre>
paraItemRest :: [n] -> n -> ParaSpecMap n

-- | Required named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Left (ParaUnknown ["y"])
--   </pre>
paraReq :: [n] -> ParaSpecMap n

-- | Optional named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraOpt ["y"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Right (Para { ..., paraName = fromList [("x", [["a"]]), ("y", [["b"]])] })
--   </pre>
paraOpt :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use first parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraFirst ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"]])] })
--   </pre>
paraFirst :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use last parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraLast ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["b","c"]])] })
--   </pre>
paraLast :: [n] -> ParaSpecMap n

-- | Multiple-occurence parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraMulti ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"],["b","c"]])] })
--   </pre>
paraMulti :: [n] -> ParaSpecMap n
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch


-- | Getters for parameter.
module Koshucode.Baala.Syntax.Para.Get

-- | Named parageter.
paraGet :: (Ord n) => Para n a -> n -> Ab [a]

-- | Named parameter with default content.
paraGetOpt :: (Ord n) => [a] -> Para n a -> n -> Ab [a]

-- | Multiple-occurence parameter.
paraGetList :: (Ord n) => Para n a -> n -> Ab [[a]]

-- | S.Parameter as switch, just given or not.
paraGetSwitch :: (Ord n) => Para n a -> n -> Ab Bool

-- | Whole positional parameter list.
paraGetPos :: Para n a -> Ab [a]

-- | First positional parameter.
paraGetFst :: Para n a -> Ab a

-- | Second positional parameter.
paraGetSnd :: Para n a -> Ab a

-- | Third positional parameter.
paraGetTrd :: Para n a -> Ab a

-- | Positional parameter list but first element.
paraGetRest :: Para n a -> Ab [a]

-- | Positional parameter list but first and second element.
paraGetRRest :: Para n a -> Ab [a]


-- | Attribute name.
module Koshucode.Baala.Syntax.Attr.AttrName

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: String -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: String -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Attribute string with hyphen.
attrNameCode :: AttrName -> String

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrName.AttrName

module Koshucode.Baala.Syntax.Token.Message
abToken :: (CodePtr cp) => [cp] -> Map (Ab b)

-- | Forbidden input
forbiddenInput :: String -> Ab a

-- | Unexpedted section delimiter
unexpSect :: [String] -> Ab a

-- | Unknown bracket text
unkAngleText :: String -> Ab a

module Koshucode.Baala.Syntax.Symbol.Message

-- | Expect ordinary symbol
expOrdSym :: Ab a

-- | Quotation not end in line
quotNotEnd :: Ab a


-- | Next character sequence.
module Koshucode.Baala.Syntax.Symbol.Next

-- | Input data type.
type InputText = String

-- | Split next character sequence from input text.
type Next a = InputText -> (InputText, a)

-- | Split next character sequence from input text.
type AbNext a = InputText -> Ab (InputText, a)

-- | Get next spaces.
nextSpace :: Next Int

-- | Get next double-quoted text.
nextQQ :: AbNext String

-- | Symbol class.
--   
--   Relation between character classes and symbol classes. The char class
--   <tt>number'</tt> means Unicode number except for <tt>0-9</tt>.
--   <tt>G</tt> for general symbol, <tt>P</tt> for plain, <tt>N</tt> for
--   numeric.
--   
--   <pre>
--   Char class   Symbol class
--   ------------ -----------------
--   "0-9"        ( G ) ( P ) ( N )
--   "-"          ( G ) ( P ) ( N )
--   letter       ( G )   P
--   mark         ( G )   P
--   number'      ( G )   P
--   "_?"         ( G )   P
--   "+"          ( G )         N
--   "*=&lt;&gt;~"        G
--   ".#"                       N
--   </pre>
--   
--   Partial order of symbol classes.
--   
--   <pre>
--                     ( GPN ) Common
--                    /      |
--           Plain ( GP )  ( GN ) Numeric
--                /  |    /  |
--   Short ( P.P )   |   /   |
--            :      |  /    |
--         General ( G )     |
--            :      :     ( N ) Numeric
--            :      :       :
--            ................ Unknown
--   </pre>
data Symbol

-- | General-ordinary-numeric symbol
SymbolCommon :: String -> Symbol

-- | General symbol
SymbolGeneral :: String -> Symbol

-- | Plain symbol
SymbolPlain :: String -> Symbol

-- | Numeric symbol
SymbolNumeric :: String -> Symbol

-- | Short symbol (Plain <tt>"."</tt> Plain)
SymbolShort :: String -> String -> Symbol

-- | Unknown symbol
SymbolUnknown :: String -> Symbol

-- | Test symbol is general, in other words, <a>SymbolCommon</a>,
--   <a>SymbolPlain</a> or <a>SymbolGeneral</a>.
isGeneralSymbol :: Symbol -> Bool

-- | Test symbol is plain, in other words, <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
isPlainSymbol :: Symbol -> Bool

-- | Test symbol is numeric, in other words, <a>SymbolCommon</a> or
--   <a>SymbolNumeric</a>.
isNumericSymbol :: Symbol -> Bool

-- | Test symbol is <a>SymbolShort</a>.
isShortSymbol :: Symbol -> Bool

-- | Test character is a symbol component.
isSymbolChar :: Char -> Bool

-- | Test character is a general-symbol component.
isGeneralChar :: Char -> Bool

-- | Test character is a plain-symbol component.
isPlainChar :: Char -> Bool

-- | Test character is a numeric-symbol component.
isNumericChar :: Char -> Bool

-- | Get next symbol.
nextSymbol :: Next Symbol
nextSymbolPlain :: AbNext String
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Next.Symbol
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Next.Symbol
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Next.Symbol


-- | Short sign.
module Koshucode.Baala.Syntax.Symbol.Short

-- | Something with short definition.
data Short a
Short :: [CodePt] -> [ShortDef] -> a -> Short a
[shortSource] :: Short a -> [CodePt]
[shortHead] :: Short a -> [ShortDef]
[shortBody] :: Short a -> a

-- | Short prefix and replacement.
type ShortDef = Named String
shortTrim :: Map [Short [a]]
shortM :: (Monad m) => Short (m a) -> m (Short a)
shortListM :: (Monad m) => [Short (m a)] -> m [Short a]
shortGroup :: [Short a] -> [Short [a]]

-- | String shortener.
shortText :: [ShortDef] -> Shorten
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Symbol.Short.Short


-- | Symbols
module Koshucode.Baala.Syntax.Symbol


-- | Tokens in Koshucode.
module Koshucode.Baala.Syntax.Token.Token
class SubtypeString a
subtypeString :: SubtypeString a => a -> String

-- | There are eleven types of tokens.
data Token

-- | 1) Text.
TText :: CodePt -> TextForm -> String -> Token

-- | 2) Slot name. <a>Int</a> represents slot level, i.e., 0 for local
--   positional slots, 1 for local named slots, 2 for global slots —
--   <tt>@</tt><i>name</i>
TSlot :: CodePt -> Int -> String -> Token

-- | 3) Prefixed shorten text — <i>short</i><tt>.</tt><i>proper</i>
TShort :: CodePt -> String -> String -> Token

-- | 4) Term name — <tt>/</tt><i>name</i>
TTermN :: CodePt -> Ordering -> TermName -> Token

-- | 5) Term path — <tt>/</tt><i>name</i><tt>/</tt><i>name</i>
TTerm :: CodePt -> TermType -> TermPath -> Token

-- | 6) Local name — <tt>^/</tt><i>name</i>
TLocal :: CodePt -> (Local String) -> Int -> [Token] -> Token

-- | 7) Opening bracket — <tt>(</tt>, <tt>{</tt>, etc
TOpen :: CodePt -> String -> Token

-- | 8) Closing bracket — <tt>}</tt>, <tt>)</tt>, etc
TClose :: CodePt -> String -> Token

-- | 9) <i>N</i> space characters.
TSpace :: CodePt -> Int -> Token

-- | 10) Comment — <tt>**</tt><i>text</i>
TComment :: CodePt -> String -> Token

-- | 11) Blank name. (This is used in building content expression)
TName :: CodePt -> BlankName -> Token

-- | 12) Unknown token.
TUnknown :: CodePt -> String -> AbortReason -> Token

-- | Create raw text token.
textToken :: String -> Token

-- | Create unknown token.
unknownToken :: CodePt -> String -> Ab a -> Token
data TextForm

-- | Unknown keyword
TextUnk :: TextForm

-- | Naked text
TextRaw :: TextForm

-- | Single-quoted text — <tt>'</tt><i>code</i>
TextQ :: TextForm

-- | Double-quoted text — <tt>"</tt><i>text</i><tt>"</tt>
TextQQ :: TextForm

-- | Keyword literal — <tt>&lt;</tt><i>keyword</i><tt>&gt;</tt>
TextKey :: TextForm

-- | Text enclosed in bars — <tt>|</tt><i>text</i><tt>|</tt>
TextBar :: TextForm

-- | Text in license section
TextLicense :: TextForm
data TermType

-- | Normal term path
TermTypePath :: TermType

-- | Quoted term name
TermTypeQuoted :: TermType
data Local a
LocalSymbol :: a -> Local a
LocalNest :: a -> Local a
unlocal :: Local a -> a
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Token.Token.Local a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Token.Token.Local a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Token.Token.Local a)
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TermType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TermType
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TermType
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Syntax.Token.Token.SubtypeString Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.IO.CodePt.CodePtr Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Text.PPrint.PPrint Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Syntax.Token.Token.SubtypeString Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.BlankName
instance Koshucode.Baala.Syntax.Token.Token.SubtypeString Koshucode.Baala.Syntax.Token.Token.BlankName


-- | Token pattern.
module Koshucode.Baala.Syntax.Token.Pattern

-- | Unknown text token.

-- | Raw text token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextRaw B.def "a"   -- a
--   </pre>

-- | Quoted text token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextQ B.def "a"   -- 'a
--   </pre>

-- | Dobule-quoted text token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextQQ B.def "a"   -- "a"
--   </pre>

-- | Keyword token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextKey B.def "a"   -- &lt;a&gt;
--   </pre>

-- | Bar-enclosed token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextBar B.def "a"   -- |a|
--   </pre>

-- | License text token.

-- | Term path token.
--   
--   <pre>
--   &gt;&gt;&gt; TTermPath B.def ["a", "b"]   -- /a/b
--   </pre>

-- | Quoted term path token.
--   
--   <pre>
--   &gt;&gt;&gt; TTermQ B.def ["a"]   -- '/a
--   </pre>


-- | Token utilities.
module Koshucode.Baala.Syntax.Token.Utility

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.TTermPath B.def ["r", "x"] in tokenContent tok
--   "/r/x"
--   </pre>
tokenContent :: Token -> String
untoken :: Token -> String

-- | Get detail type string of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.textToken "flower" in (S.subtypeString tok, tokenDetailTypeString tok)
--   ("text", Just "raw")
--   </pre>
tokenDetailTypeString :: Token -> Maybe String
tokenParents :: Token -> [Token]

-- | Test token is blank, i.e., comment or space.
isBlankToken :: Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]

-- | Test token is short-type token.
isShortToken :: Pred Token

-- | Test token is term-type token.
isTermToken :: Pred Token

-- | Test token is open-type token.
isOpenToken :: Pred Token

-- | Test token is close-type token.
isCloseToken :: Pred Token

-- | Test token is a open-type of the specific bracket.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.TOpen B.def "(" in isOpenTokenOf "(" tok
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.TOpen B.def "{" in isOpenTokenOf "(" tok
--   False
--   </pre>
isOpenTokenOf :: String -> Pred Token

-- | Test token is a close-type of the specific bracket.
isCloseTokenOf :: String -> Pred Token

-- | Test token is unknown.
isUnknownToken :: Pred Token


-- | Token nipper.
module Koshucode.Baala.Syntax.Token.Nipper

-- | Code roll for token.
type TokenScan = CodeScan String Token

-- | Read single token.
type TokenScanMap = Map TokenScan

-- | Nip off a next token.
type TokenNip = CodePt -> InputText -> TokenNipResult

-- | Nip off a next token with word table.
type TokenNipW = CodePt -> WordTable -> InputText -> TokenNipWResult
type TokenNipResult = (InputText, Token)
type TokenNipWResult = (WordTable, InputText, Token)

-- | Test character is symbolic.
isSymbol :: Pred Char

-- | Test character is space.
isSpace :: Pred Char

-- | Test character is double-quote.
isQQ :: Pred Char

-- | Test character is term slash.
isTerm :: Pred Char

-- | Test character is content line, i.e., <tt>'-'</tt> or <tt>'='</tt>.
isJudge :: Pred Char

-- | Test character is component of clock text.
isClock :: Pred Char

-- | Update token scanner by nipper result.
nipUpdate :: TokenScan -> TokenNipResult -> TokenScan

-- | Update token scanner by nipper result with word table.
nipUpdateW :: TokenScan -> TokenNipWResult -> TokenScan

-- | Nip off space token.
nipSpace :: TokenNip

-- | Nip off a single-quoted text.
nipQ :: TokenNipW

-- | Nip off a double-quoted text.
nipQQ :: TokenNip

-- | Nip off symbolic token.
nipSymbol :: TokenNipW

-- | Create symbolic token.
symbolToken :: (CodePt -> String -> Token) -> String -> TokenNipW

-- | Nip off a slot name, like <tt>@foo</tt>.
nipSlot :: Int -> TokenNip

-- | Nip off a signed term name.
nipTermSign :: Ordering -> TokenNipW

-- | Nip off a term name.
nipTermPath :: TokenNipW

-- | Nip off a quoted term.
nipTermQ :: TokenNipW

-- | Nip off token beginning with <tt>"|"</tt>.
nipBar :: CodePt -> String -> String -> TokenNipResult


-- | Code section.
module Koshucode.Baala.Syntax.Token.Section

-- | Select scanner based on section name.
type ChangeSection = String -> Maybe TokenScanMap
section :: ChangeSection -> (InputText -> TokenScan) -> TokenScanMap

-- | Token scanner.
type Scanner = ChangeSection -> TokenScanMap

-- | Scan tokens in <tt>end</tt> section.
scanEnd :: Scanner

-- | Scan tokens in <tt>note</tt> section.
scanNote :: Scanner

-- | Scan tokens in <tt>license</tt> section.
scanLicense :: Scanner

-- | Scan entire line as text.
scanLine :: TextForm -> Scanner
scanLineInClause :: TextForm -> Scanner
scanTextAssert :: Scanner


-- | Tokenizer for relational section.
module Koshucode.Baala.Syntax.Token.Rel

-- | Scan a next token in relational section.
scanRel :: Scanner

-- | Scan interpretation content between <tt>{|</tt> and <tt>|}</tt>.
scanInterp :: Scanner

module Koshucode.Baala.Syntax.Token.Clause
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Abbreviated tokenizer.
toks :: InputText -> [Token]

-- | Tokenize text.
tokenLines :: NIOPoint -> InputText -> [TokenLine]

-- | Tokenize lazy bytestring.
tokenLinesBz :: NIOPoint -> Bz -> [TokenLine]

-- | Tokenize lazy bytestring.
tokenLinesBzTextAssert :: NIOPoint -> Bz -> [TokenLine]

-- | Test string is short prefix.
isShortPrefix :: Pred String


-- | Token and tokenizer.
module Koshucode.Baala.Syntax.Token


-- | Bracket type.
module Koshucode.Baala.Syntax.TTree.Bracket

-- | Type of bracket.
data BracketType

-- | Round brackets for grouping: <tt>( E ... )</tt>
BracketGroup :: BracketType

-- | Square brackets for lists: <tt>[ C | ... ]</tt>
BracketList :: BracketType

-- | Curely braces for sets: <tt>{ C | .... }</tt>
BracketSet :: BracketType

-- | Curely-single braces for ties: <tt>{- /N C ... -}</tt>
BracketTie :: BracketType

-- | Curely-double braces for relations: <tt>{= /N ... [ C | ... ][ C | ...
--   ] =}</tt>
BracketRel :: BracketType

-- | Curely-bar braces for data interpretation: <tt>{| ... /N ... |}</tt>
BracketInterp :: BracketType

-- | Square-single brackets for type: <tt>[- ... -]</tt>
BracketType :: BracketType

-- | Round-bar brackets for form with blanks: <tt>(| V ... | E ... |)</tt>
BracketForm :: BracketType

-- | Unknown bracket
BracketUnknown :: BracketType

-- | Bracket type of token.
getBracketType :: GetBracketType BracketType Token

-- | Open group: <tt>"("</tt>
groupOpen :: String

-- | Close group: <tt>")"</tt>
groupClose :: String

-- | Open list: <tt>"["</tt>
listOpen :: String

-- | Close list: <tt>"]"</tt>
listClose :: String

-- | Open set: <tt>"{"</tt>
setOpen :: String

-- | Close set: <tt>"}"</tt>
setClose :: String

-- | Open tie: <tt>"{-"</tt>
tieOpen :: String

-- | Close tie: <tt>"-}"</tt>
tieClose :: String

-- | Open relation: <tt>"{="</tt>
relOpen :: String

-- | Close relation: <tt>"=}"</tt>
relClose :: String

-- | Open interpreation: <tt>"{|"</tt>
interpOpen :: String

-- | Close interpreation: <tt>"|}"</tt>
interpClose :: String

-- | Open type: <tt>"[-"</tt>
typeOpen :: String

-- | Close type: <tt>"-]"</tt>
typeClose :: String
instance GHC.Classes.Ord Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance GHC.Show.Show Koshucode.Baala.Syntax.TTree.Bracket.BracketType


-- | Tree of tokens
module Koshucode.Baala.Syntax.TTree.TokenTree

-- | Tree of tokens.
type TTree = CodeTree BracketType Token

-- | Pair of token tree and its name.
type NamedTree = Named TTree

-- | Pair of token trees and its name.
type NamedTrees = Named [TTree]

-- | Convert token tree to something.
type TTreeTo a = TTree -> a

-- | Convert list of token tree to sometning.
type TTreesTo a = [TTree] -> a

-- | Convert token tree to something, abortable.
type TTreeToAb a = TTree -> Ab a

-- | Convert list of token tree to sometning, abortable.
type TTreesToAb a = [TTree] -> Ab a

-- | Text leaf.

-- | Text leaf of <a>TextRaw</a>.

-- | Text leaf beginning with single hyphen.

-- | Text leaf beginning with double hyphens.

-- | Text leaf of <a>TextQ</a>.

-- | Text leaf of <a>TextQQ</a>.

-- | Text leaf of <a>TextKey</a>.


-- | Parser for token tree.
module Koshucode.Baala.Syntax.TTree.Parse

-- | Parse tokens with brackets into trees. Blank tokens and comments are
--   excluded.
ttrees :: [Token] -> Ab [TTree]

-- | Wrap trees in group.
ttreeGroup :: TTreesTo TTree

-- | Convert string to token trees.
tt :: String -> Ab [TTree]

-- | Parse string and group it.
tt1 :: String -> Ab TTree

-- | Parse string and print it.
ttPrint :: String -> IO ()

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: TTreesTo Doc

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "b c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Left [ TText  CodePt {..} TextRaw "b"
--        , TSpace CodePt {..} 1
--        , TText  CodePt {..} TextRaw "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "a | b | c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Right ( [ TText CodePt {..} TextRaw "a", TSpace CodePt {..} 1]
--         , TText CodePt {..} TextRaw "|"
--         , [ TText  CodePt {..} TextRaw "b"
--           , TSpace CodePt {..} 1
--           , TText  CodePt {..} TextRaw "|"
--           , TText  CodePt {..} TextRaw "c" ] )
--   </pre>
splitTokensBy :: Pred String -> SplitList3e Token

-- | Split token trees by quoteless token of given string.
splitTreesBy :: Pred String -> SplitList3e TTree

-- | Divide token trees by quoteless token of given string.
divideTreesBy :: Pred String -> TTreesTo [[TTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
divideTreesByBar :: TTreesTo [[TTree]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: TTreesTo [[TTree]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: TTreesTo [[TTree]]


-- | Token trees.
module Koshucode.Baala.Syntax.TTree

module Koshucode.Baala.Syntax.Para

module Koshucode.Baala.Syntax.Attr.Message
abAttr :: (CodePtr cp) => [cp] -> Map (Ab b)
abAttrTrees :: TTreesTo (Map (Ab b))
abSlot :: (CodePtr cp) => [cp] -> Map (Ab b)
abSlotTree :: TTreeTo (Map (Ab b))

-- | Same as <tt>abortable</tt> except for using <a>TTree</a> instead of
--   list of <a>Token</a>.
abortableTree :: String -> TTreeTo (Map (Ab b))

-- | Same as <tt>abortable</tt> except for using list of <a>TTree</a>
--   instead of list of <a>Token</a>.
abortableTrees :: String -> TTreesTo (Map (Ab b))

-- | Unexpected attribute / Duplicate
dupAttr :: [String] -> Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unmatch any patterns
unexpAttrMulti :: [ParaUnmatch String] -> Ab a

module Koshucode.Baala.Syntax.Message


-- | Slot substitution.
module Koshucode.Baala.Syntax.Attr.Slot

-- | Attribute name and its contents.
type AttrTree = (AttrName, [TTree])
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [TTree]


-- | Attribute editor.
module Koshucode.Baala.Syntax.Attr.AttrEd

-- | Attribute editor with source code information.
type AttrEd = Sourced AttrEdBody

-- | Operators for attribute editors.
data AttrEdBody

-- | Identity editor
AttrEdId :: AttrEdBody

-- | Add attribute
AttrEdAdd :: Bool -> String -> [TTree] -> AttrEdBody

-- | Rename attribute keyword
AttrEdRename :: (String, String) -> AttrEdBody

-- | Fill positional attributes
AttrEdFill :: [Maybe TTree] -> AttrEdBody

-- | Make term name
AttrEdTerm :: String -> [TTree] -> AttrEdBody

-- | Nested relation reference
AttrEdNest :: String -> [TTree] -> AttrEdBody

-- | Append editors
AttrEdAppend :: [AttrEd] -> AttrEdBody

-- | Construct attribute editor.
consAttrEd :: [TTree] -> Ab AttrEd

-- | Edit relmap attributes.
runAttrEd :: AttrEd -> AbMap [AttrTree]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody


-- | Attributes of relmap operator.
module Koshucode.Baala.Syntax.Attr.Attr

-- | Parameter specification for attribute name.
type AttrParaSpec = ParaSpec AttrName

-- | Attribute layout.
data AttrLayout
AttrLayout :: [(Maybe String, AttrBranch)] -> AttrLayout

-- | Single layout.
data AttrBranch
AttrBranch :: AttrParaSpec -> Map AttrName -> AttrBranch

-- | Parameter specification
[attrParaSpec] :: AttrBranch -> AttrParaSpec

-- | Attribute classifier
[attrClassifier] :: AttrBranch -> Map AttrName

-- | Construct attribute branch.
attrBranch :: AttrParaSpec -> AttrBranch

-- | Attribute parameter.
type AttrPara = Para AttrName TTree

-- | Parameterizer for attribute of relmap operator.
type AttrParaze = [TTree] -> Ab AttrPara

-- | Parameterize named attributes.
attrPara :: AttrParaze

-- | Parameterize attributes by its layout.
attrParaBy :: AttrLayout -> AttrParaze

-- | Take out hyphened text (like <tt>"-x"</tt>) from token tree.
maybeSingleHyphen :: TTreeTo (Maybe String)

-- | Take out double-hyphened text (like <tt>"--xyz"</tt>) from token tree.
maybeDoubleHyphen :: TTreeTo (Maybe String)
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrLayout
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrBranch


-- | Parser for attribute layout.
module Koshucode.Baala.Syntax.Attr.Parse

-- | Parse relmap attribute layout.
--   
--   <ul>
--   <li><b><tt>-</tt>Word</b> — Normal attribute</li>
--   <li><b><tt>-</tt>Word<tt>/</tt></b> — Relmap attribute</li>
--   <li><b><tt>-</tt>Word<tt>/^</tt></b> — Local relmap attribute</li>
--   </ul>
parseAttrLayout :: String -> AttrLayout

-- | Parse parameter layout.
--   
--   No positional and one named required <tt>c</tt> attribute.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSpec ". c"
--   [(Nothing, ParaSpec { paraSpecReqN = ["c"], ... })]
--   </pre>
--   
--   Positional required <tt>a</tt>, rest <tt>b</tt>, and one named
--   <tt>c</tt> attributes.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSpec "a b* . c"
--   [(Nothing, ParaSpec { paraSpecPos = ParaItemRest 1 ["a"] "b"
--                       , paraSpecReqP = ["a"]
--                       , paraSpecOptP = ["b"]
--                       , paraSpecReqN = ["c"], ... })]
--   </pre>
--   
--   Set of named layouts.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSpec "a : a | ab : a b"
--   [ (Just "a",  ParaSpec { paraSpecPos = ParaItem 1 ["a"], paraSpecReqP = ["a"], ... })
--   , (Just "ab", ParaSpec { paraSpecPos = ParaItem 2 ["a","b"], paraSpecReqP = ["a","b"], ... })]
--   </pre>
--   
--   Syntax for parameter layout.
--   
--   <ul>
--   <li><i>Multiple</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Single</b> — Single layout</li>
--   <li><b>Single <tt>|</tt> Multiple</b> ... — Multiple layout</li>
--   </ul>
--   
--   <ul>
--   <li><i>Single</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Layout</b> — Layout without tag</li>
--   <li><b>Word <tt>:</tt> Layout</b> — Layout with tag</li>
--   </ul>
--   
--   <ul>
--   <li><i>Layout</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Positional</b> — Positional parameters</li>
--   <li><b>Positional <tt>.</tt> Named</b> — Positional and named
--   parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i>Positional</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Word ...</b> — Positional required parameters</li>
--   <li><b>Word ... Word<tt>?</tt> ...</b> — Positional required and
--   optional parameters</li>
--   <li><b>Word ... Word<tt>*</tt></b> — Positional required and rest
--   parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i>Named</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Name ...</b> — Named parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i>Name</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Word Opt</b> — Named parameter</li>
--   </ul>
--   
--   <ul>
--   <li><i>Opt</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Empty</b> — Required parameter</li>
--   <li><b><tt>?</tt></b> — Optional parameter</li>
--   </ul>
parseParaSpec :: String -> [(Maybe String, ParaSpec String)]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.Parse.Ror
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.Parse.Ror
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Parse.Ror

module Koshucode.Baala.Syntax.Attr

module Koshucode.Baala.Syntax
