-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Syntax for Koshucode
--   
--   Syntax for Koshucode
@package koshucode-baala-syntax
@version 0.174.0.0


-- | Term types and related functions.
module Koshucode.Baala.Syntax.Symbol.Term

-- | Term type: pair of term name and content.
type Term c = (TermName, c)

-- | Create term.
--   
--   <pre>
--   &gt;&gt;&gt; term "size" 10 :: Term Int
--   (TermName "size", 10)
--   </pre>
term :: (ToTermName n) => n -> c -> Term c

-- | Name of term, e.g., <tt>"size"</tt> for the term name <tt>/size</tt>.
data TermName

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]

-- | Convert to term name.
class ToTermName a
toTermName :: ToTermName a => a -> TermName

-- | Add necessary slash character indicating term name.
--   
--   <pre>
--   &gt;&gt;&gt; enslash &lt;$&gt; ["foo", "/bar", "+/baz", "-/qux"]
--   ["/foo", "/bar", "+/baz", "-/qux"]
--   </pre>
enslash :: Map String

-- | Decode term name from string.
--   
--   <pre>
--   &gt;&gt;&gt; stringTermName "/a"
--   TermName EQ "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringTermName "+/a"
--   TermName GT "a"
--   </pre>
stringTermName :: String -> TermName

-- | Encode term name into string.
--   
--   <pre>
--   &gt;&gt;&gt; termNameString $ stringTermName "/size"
--   "/size"
--   </pre>
termNameString :: TermName -> String

-- | Encode term path into string.
--   
--   <pre>
--   &gt;&gt;&gt; termPathString [stringTermName "r", stringTermName "x"]
--   "/r/x"
--   </pre>
termPathString :: TermPath -> String

-- | Extract internal name.
--   
--   <pre>
--   &gt;&gt;&gt; termNameContent $ stringTermName "/size"
--   "size"
--   </pre>
termNameContent :: TermName -> String

-- | Sign of term name.
termNameSign :: TermName -> Ordering

-- | Alter sign of term name.
termNameAltSign :: Ordering -> Map TermName

-- | Convert to ordering pair.
orderingTermName :: TermName -> (Ordering, TermName)

-- | Tuple of 2 term names.
type TermName2 = (TermName, TermName)

-- | Tuple of 3 term names.
type TermName3 = (TermName, TermName, TermName)

-- | Tuple of 4 term names.
type TermName4 = (TermName, TermName, TermName, TermName)

-- | Tuple of 5 term names.
type TermName5 = (TermName, TermName, TermName, TermName, TermName)

-- | Tuple of 6 term names.
type TermName6 = (TermName, TermName, TermName, TermName, TermName, TermName)

-- | Term index.
type TermIndex = Int

-- | Term name and index.
type IndexTerm = (TermName, TermIndex)

-- | Test present term.
--   
--   <pre>
--   &gt;&gt;&gt; termP 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termP 0
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termP (-1)
--   False
--   </pre>
termP :: Test TermIndex

-- | Test new term.
termN :: Test TermIndex

-- | Test all terms are present.
termsP :: Test [TermIndex]

-- | Test all terms are new.
--   
--   <pre>
--   &gt;&gt;&gt; termsN [-1, -1]
--   True
--   </pre>
termsN :: Test [TermIndex]

-- | Test present and new terms.
--   
--   <pre>
--   &gt;&gt;&gt; termsPN [1,2] [-1]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termsPN [1,2] [-1,0]
--   False
--   </pre>
termsPN :: Test2 [TermIndex] [TermIndex]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Term.TermName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Term.TermName
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Data.String.IsString Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName GHC.Base.String
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Data.Text.Internal.Text
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Data.Text.Internal.Lazy.Text


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Syntax.Symbol.AngleText

-- | Convert string into double-quoted and angle-quoted form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "\t"
--   &lt;tab&gt;
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "aaa\nbbb\r\nccc\r\n\r\nddd"
--   "aaa" &lt;lf&gt; "bbb" &lt;crlf&gt; "ccc" &lt;crlf&gt; &lt;crlf&gt; "ddd"
--   </pre>
angleQuote :: StringMap

-- | Table of coresspondences of angle text and its replacement.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" angleTexts
--   Just "\n"
--   </pre>
angleTexts :: [(String, String)]


-- | Parameter type.
module Koshucode.Baala.Syntax.Para.Para

-- | Named and positional parameter.
data Para n a
Para :: [String] -> [a] -> [a] -> ParaMap n a -> Para n a

-- | Parameter tags.
[paraTags] :: Para n a -> [String]

-- | All parameter elements.
[paraAll] :: Para n a -> [a]

-- | Positional parameters.
[paraPos] :: Para n a -> [a]

-- | Named parameters.
[paraName] :: Para n a -> ParaMap n a

-- | Mapping parameter name to its contents.
type ParaMap n a = Map n [[a]]

-- | Test and take parameter name.
type ParaName n a = a -> Maybe n

-- | Parse list into parameter.
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b"
--   Para { paraAll = ["a","b"], paraPos = ["a","b"], paraName = fromList [] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b -x c d"
--   Para { paraAll = ["a","b","-x","c"]
--        , paraPos = ["a","b"]
--        , paraName = fromList [("x",[["c","d"]])] }
--   </pre>
para :: (Ord n) => ParaName n a -> [a] -> Para n a

-- | Association list of named parameters.
paraNameList :: Para n a -> [(n, [[a]])]

-- | List of parameter names.
paraNames :: Para n a -> [n]

-- | List of names which appear more than once.
paraMultipleNames :: Para n a -> [n]

-- | Lookup named parameter.
paraLookup :: (Ord n) => n -> Para n a -> Maybe [[a]]

-- | Lookup single-occurence parameter.
paraLookupSingle :: (Ord n) => n -> Para n a -> Maybe [a]

-- | Give names to positional parameters.
paraPosName :: (Ord n, Monad m) => ([a] -> m [(n, [a])]) -> Para n a -> m (Para n a)

-- | Add named parameter.
paraNameAdd :: (Ord n) => n -> [a] -> Map (Para n a)

-- | Map names of named parameters.
paraNameMapKeys :: (Ord n2) => (n1 -> n2) -> Para n1 a -> Para n2 a

-- | Take first element from multiply given named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = para paraHyphen $ words "a -x 1 -x 2 -x 3"
--   
--   &gt;&gt;&gt; p
--   Para { ..., paraName = fromList [("x", [["1"],["2"],["3"]])] }
--   
--   &gt;&gt;&gt; paraTakeFirst "x" p
--   Para { ..., paraName = fromList [("x", [["1"]])] }
--   </pre>
paraTakeFirst :: (Ord n) => n -> Para n a -> Para n a

-- | Take last element from multiply given named parameter.
paraTakeLast :: (Ord n) => n -> Para n a -> Para n a

-- | String-named parameter.
type SimplePara a = Para String a

-- | Composition of word separation and parameter parsing.
paraWords :: (Ord n) => ParaName n String -> String -> Para n String

-- | Parameter name is beginning with hyphen.
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "-foo"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "bar"
--   Nothing
--   </pre>
paraHyphen :: ParaName String String
instance (GHC.Classes.Ord n, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Classes.Eq n, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance GHC.Classes.Ord n => GHC.Base.Monoid (Koshucode.Baala.Syntax.Para.Para.Para n a)


-- | Parameter specification.
module Koshucode.Baala.Syntax.Para.ParaSpec

-- | Parameter specification.
data ParaSpec n
ParaSpec :: ParaSpecPos n -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> ParaSpec n

-- | <b>Positional:</b> Positional parameter
[paraSpecPos] :: ParaSpec n -> ParaSpecPos n

-- | <b>Positional:</b> Positional required parameters
[paraSpecReqP] :: ParaSpec n -> [n]

-- | <b>Positional:</b> Positional optional parameters
[paraSpecOptP] :: ParaSpec n -> [n]

-- | <b>Named:</b> Explicitly-named required parameters
[paraSpecReqN] :: ParaSpec n -> [n]

-- | <b>Named:</b> Explicitly-named optional parameters
[paraSpecOptN] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use first parameters
[paraSpecFirst] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use last parameters
[paraSpecLast] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use all parameters
[paraSpecMulti] :: ParaSpec n -> [n]

-- | Name list of all parameters.
paraSpecNames :: ParaSpec n -> [n]

-- | Name list of positional parameters.
paraSpecNamesP :: ParaSpec n -> [n]

-- | Name list of explicitly-named parameters.
paraSpecNamesN :: ParaSpec n -> [n]

-- | Positional parameter specification.
data ParaSpecPos n

-- | Named positional parameters
ParaItem :: Int -> [n] -> ParaSpecPos n

-- | Named positional and optional parameters
ParaItemOpt :: Int -> [n] -> [n] -> ParaSpecPos n

-- | Named positional and rest parameters
ParaItemRest :: Int -> [n] -> n -> ParaSpecPos n

-- | Lower bound of parameter length
ParaMin :: Int -> ParaSpecPos n

-- | Lower and upper bound of parameter length
ParaRange :: Int -> Int -> ParaSpecPos n

-- | Minimal length of positional parameters.
paraMinLength :: ParaSpecPos n -> Int

-- | Unmatch reason of real parameter and its specifition.
data ParaUnmatch n

-- | Positional parameter is unmatched.
ParaOutOfRange :: Int -> (ParaSpecPos n) -> ParaUnmatch n

-- | Unknown parameter is specified.
ParaUnknown :: [n] -> ParaUnmatch n

-- | Required parameter is missing.
ParaMissing :: [n] -> ParaUnmatch n

-- | Parameter occurs more than once.
ParaMultiple :: [n] -> ParaUnmatch n

-- | Either something or parameter.
type ParaOr left n a = Either left (Para n a)

-- | Test and revise parameter to satisfy specification.
paraMatch :: (Eq n, Ord n) => ParaSpec n -> Para n a -> ParaOr (ParaUnmatch n) n a

-- | Select matched specification and apply parameter value function.
paraSelect :: (Eq n, Ord n) => b -> [(ParaSpec n, Para n a -> b)] -> Para n a -> b

-- | Collect parameter tags.
paraChoose :: (Ord n) => [(Maybe String, ParaSpec n)] -> Para n a -> ParaOr [ParaUnmatch n] n a

-- | Mapping of parameter specification.
type ParaSpecMap n = Map (ParaSpec n)

-- | Create parameter specification.
paraSpec :: (Show n, Ord n) => ParaSpecMap n -> ParaSpec n

-- | Lower bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMin 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaOutOfRange ...
--   </pre>
paraMin :: Int -> ParaSpecMap n

-- | Upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMax 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Left ParaOutOfRange ...
--   </pre>
paraMax :: Int -> ParaSpecMap n

-- | Fixed-length positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraJust 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaOutOfRange ...
--   </pre>
paraJust :: Int -> ParaSpecMap n

-- | Lower and upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraRange 1 2
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Left ParaOutOfRange ...
--   </pre>
paraRange :: Int -> Int -> ParaSpecMap n

-- | No positional parameter.
para0 :: ParaSpecMap n

-- | Named one positional parameter.
para1 :: n -> ParaSpecMap n

-- | Named two positional parameters.
para2 :: n -> n -> ParaSpecMap n

-- | Named three positional parameters.
para3 :: n -> n -> n -> ParaSpecMap n

-- | Named arbitrary positional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItem ["x", "y", "z", "w"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]), ..., ("w",[["d"]])] })
--   </pre>
paraItem :: [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemOpt ["x", "y"] ["z"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]])] })
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c"]])] })
--   </pre>
paraItemOpt :: [n] -> [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemRest ["x", "y"] "z"
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c","d"]])] })
--   </pre>
paraItemRest :: [n] -> n -> ParaSpecMap n

-- | Required named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Left (ParaUnknown ["y"])
--   </pre>
paraReq :: [n] -> ParaSpecMap n

-- | Optional named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraOpt ["y"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Right (Para { ..., paraName = fromList [("x", [["a"]]), ("y", [["b"]])] })
--   </pre>
paraOpt :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use first parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraFirst ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"]])] })
--   </pre>
paraFirst :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use last parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraLast ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["b","c"]])] })
--   </pre>
paraLast :: [n] -> ParaSpecMap n

-- | Multiple-occurence parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraMulti ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"],["b","c"]])] })
--   </pre>
paraMulti :: [n] -> ParaSpecMap n
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch


-- | Getters for parameter.
module Koshucode.Baala.Syntax.Para.Get

-- | Named parageter.
paraGet :: (Ord n) => Para n a -> n -> Ab [a]

-- | Named parameter with default content.
paraGetOpt :: (Ord n) => [a] -> Para n a -> n -> Ab [a]

-- | Multiple-occurence parameter.
paraGetList :: (Ord n) => Para n a -> n -> Ab [[a]]

-- | S.Parameter as switch, just given or not.
paraGetSwitch :: (Ord n) => Para n a -> n -> Ab Bool

-- | Whole positional parameter list.
paraGetPos :: Para n a -> Ab [a]

-- | First positional parameter.
paraGetFst :: Para n a -> Ab a

-- | Second positional parameter.
paraGetSnd :: Para n a -> Ab a

-- | Third positional parameter.
paraGetTrd :: Para n a -> Ab a

-- | Positional parameter list but first element.
paraGetRest :: Para n a -> Ab [a]

-- | Positional parameter list but first and second element.
paraGetRRest :: Para n a -> Ab [a]


-- | Attribute name.
module Koshucode.Baala.Syntax.Attr.AttrName

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: String -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: String -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Attribute string with hyphen.
attrNameCode :: AttrName -> String

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrName.AttrName


-- | Message list.
module Koshucode.Baala.Syntax.Token.Message

-- | Abortable scope for token.
abToken :: (CodePtr cp) => [cp] -> Map (Ab b)

-- | Forbidden input
forbiddenInput :: String -> Ab a

-- | Unexpedted section delimiter
unexpSect :: [String] -> Ab a

-- | Unknown bracket text
unkAngleText :: String -> Ab a


-- | Message list.
module Koshucode.Baala.Syntax.Symbol.Message

-- | Expect ordinary symbol
expOrdSym :: Ab a

-- | Quotation not end in line
quotNotEnd :: Ab a


-- | Next character sequence.
module Koshucode.Baala.Syntax.Symbol.Next

-- | Input data type.
type InputText = String

-- | Split next character sequence from input text.
type Next a = InputText -> (InputText, a)

-- | Split next character sequence from input text.
type AbNext a = InputText -> Ab (InputText, a)

-- | Get next spaces. Space character is decided by <a>isSpace</a>.
--   
--   <pre>
--   &gt;&gt;&gt; nextSpace " abc"
--   ("abc", 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSpace " \tabc"
--   ("abc", 2)
--   </pre>
nextSpace :: Next Int

-- | Get next double quoted text. A single double quote ends text. A double
--   double quote does not end text, but it is converted to double quote.
--   
--   <pre>
--   &gt;&gt;&gt; nextQQ "abc\" def"
--   Right (" def","abc")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextQQ "abc\"\"def\" ghi"
--   Right (" ghi","abc\"def")
--   </pre>
nextQQ :: AbNext String

-- | Symbol class.
--   
--   Relation between character classes and symbol classes. The char class
--   <tt>number'</tt> means Unicode number except for <tt>0-9</tt>.
--   <tt>G</tt> for general symbol, <tt>P</tt> for plain, <tt>N</tt> for
--   numeric.
--   
--   <pre>
--   Char class   Symbol class
--   ------------ -----------------
--   "0-9"        ( G ) ( P ) ( N )
--   "-"          ( G ) ( P ) ( N )
--   letter       ( G )   P
--   mark         ( G )   P
--   number'      ( G )   P
--   "_?"         ( G )   P
--   "+"          ( G )         N
--   "*=&lt;&gt;~"        G
--   ".#"                       N
--   </pre>
--   
--   Partial order of symbol classes.
--   
--   <pre>
--                     ( GPN ) Common
--                    /      |
--           Plain ( GP )  ( GN ) Numeric
--                /  |    /  |
--   Short ( P.P )   |   /   |
--            :      |  /    |
--         General ( G )     |
--            :      :     ( N ) Numeric
--            :      :       :
--            ................ Unknown
--   </pre>
data Symbol

-- | General-plain-numeric symbol
SymbolCommon :: String -> Symbol

-- | General symbol
SymbolGeneral :: String -> Symbol

-- | Plain symbol
SymbolPlain :: String -> Symbol

-- | Numeric symbol
SymbolNumeric :: String -> Symbol

-- | Short symbol (Plain <tt>"."</tt> Plain)
SymbolShort :: String -> String -> Symbol

-- | Unknown symbol
SymbolUnknown :: String -> Symbol

-- | Test symbol is general, in other words, <a>SymbolCommon</a>,
--   <a>SymbolPlain</a> or <a>SymbolGeneral</a>.
isGeneralSymbol :: Test Symbol

-- | Test symbol is plain, in other words, <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
isPlainSymbol :: Test Symbol

-- | Test symbol is numeric, in other words, <a>SymbolCommon</a> or
--   <a>SymbolNumeric</a>.
isNumericSymbol :: Test Symbol

-- | Test symbol is <a>SymbolShort</a>.
isShortSymbol :: Test Symbol

-- | Test character is a symbol component.
isSymbolChar :: Test Char

-- | Test character is a general-symbol component.
isGeneralChar :: Test Char

-- | Test character is a plain-symbol component.
isPlainChar :: Test Char

-- | Test character is a numeric-symbol component.
isNumericChar :: Test Char

-- | Get next symbol.
nextSymbol :: Next Symbol

-- | Get next plain symbol.
nextSymbolPlain :: AbNext String
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Next.Symbol
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Next.Symbol
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Next.Symbol


-- | Short sign.
module Koshucode.Baala.Syntax.Symbol.Short

-- | Something with short definition.
data Short a
Short :: [CodePt] -> [ShortDef] -> a -> Short a

-- | Source information
[shortSource] :: Short a -> [CodePt]

-- | Definition of short signs
[shortHead] :: Short a -> [ShortDef]

-- | Body with short signs
[shortBody] :: Short a -> a

-- | Short prefix and replacement.
type ShortDef = Named String

-- | Omit empty body.
shortTrim :: Map [Short [a]]

-- | Evaluate body of short structures.
shortListM :: (Monad m) => [Short (m a)] -> m [Short a]

-- | Group short structures.
shortGroup :: [Short a] -> [Short [a]]

-- | String shortener.
shortText :: [ShortDef] -> Shorten
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Symbol.Short.Short


-- | Symbols
module Koshucode.Baala.Syntax.Symbol


-- | Tokens in Koshucode.
module Koshucode.Baala.Syntax.Token.Token

-- | Type wihch has subtype and its name.
class SubtypeName a
subtypeName :: SubtypeName a => a -> String

-- | There are eleven types of tokens.
data Token

-- | <b>1 Textual:</b> Text — <tt>'code</tt>, <tt>"text"</tt>, etc
TText :: CodePt -> TextForm -> String -> Token

-- | <b>2 Textual:</b> Prefixed shorten text — <tt>short.proper</tt>
TShort :: CodePt -> String -> String -> Token

-- | <b>3 Textual:</b> Term name — <tt>/term</tt>
TTerm :: CodePt -> String -> Token

-- | <b>4 Symbolic:</b> Local name — <tt>^r</tt>, <tt>^/r</tt>
TLocal :: CodePt -> LocalRef -> Int -> [Token] -> Token

-- | <b>5 Symbolic:</b> Slot name. <a>Int</a> represents slot level, i.e.,
--   0 for local positional slots, 1 for local named slots, 2 for global
--   slots — <tt>@slot</tt>, <tt>@@global</tt>
TSlot :: CodePt -> Int -> String -> Token

-- | <b>6 Symbolic:</b> Blank name. (This is only used in building content
--   expression)
TName :: CodePt -> BlankName -> Token

-- | <b>7 Punctuational:</b> Opening bracket — <tt>(</tt>, <tt>{</tt>,
--   <tt>{=</tt>, etc
TOpen :: CodePt -> String -> Token

-- | <b>8 Punctuational:</b> Closing bracket — <tt>=}</tt>, <tt>}</tt>,
--   <tt>)</tt>, etc
TClose :: CodePt -> String -> Token

-- | <b>9 Punctuational:</b> <i>N</i> space characters
TSpace :: CodePt -> Int -> Token

-- | <b>10 Punctuational:</b> Comment — <tt>** comment line</tt>
TComment :: CodePt -> String -> Token

-- | <b>11 Other:</b> Unknown token
TUnknown :: CodePt -> String -> AbortReason -> Token

-- | Create raw text token.
rawTextToken :: String -> Token

-- | Create unknown token.
unknownToken :: CodePt -> String -> Ab a -> Token

-- | Subtype of text token.
data TextForm

-- | <b>1.</b> Unknown keyword — <tt>&lt;unknown&gt;</tt>
TextUnk :: TextForm

-- | <b>2.</b> Naked text — <tt>raw</tt>
TextRaw :: TextForm

-- | <b>3.</b> Single-quoted text — <tt>'code</tt>
TextQ :: TextForm

-- | <b>4.</b> Double-quoted text — <tt>"text"</tt>
TextQQ :: TextForm

-- | <b>5.</b> Keyword literal — <tt>&lt;crlf&gt;</tt>
TextKey :: TextForm

-- | <b>6.</b> Quoted term name — <tt>'/term</tt>
TextTerm :: TextForm

-- | <b>7.</b> Text enclosed in bars — <tt>|9:30|</tt>
TextBar :: TextForm

-- | <b>8.</b> Text in license section — <tt>=== license</tt>
TextLicense :: TextForm

-- | Local relation reference.
data LocalRef

-- | Reference to local relation — <tt>^r</tt>
LocalSymbol :: String -> LocalRef

-- | Reference to nested relation — <tt>^/r</tt>
LocalNest :: TermName -> LocalRef

-- | Blank in form.
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.IO.CodePt.CodePtr Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Text.PPrint.PPrint Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.LocalRef
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.BlankName
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.BlankName


-- | Token pattern.
module Koshucode.Baala.Syntax.Token.Pattern

-- | Unknown text token.

-- | Raw text token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextRaw B.def "a"   -- a
--   </pre>

-- | Quoted text token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextQ B.def "a"   -- 'a
--   </pre>

-- | Dobule-quoted text token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextQQ B.def "a"   -- "a"
--   </pre>

-- | Keyword token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextKey B.def "a"   -- &lt;a&gt;
--   </pre>

-- | Bar-enclosed token.
--   
--   <pre>
--   &gt;&gt;&gt; S.TTextBar B.def "a"   -- |a|
--   </pre>

-- | License text token.

-- | Section sign.


-- | Token utilities.
module Koshucode.Baala.Syntax.Token.Utility

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; tokenContent $ S.TOpen B.def "("
--   "("
--   </pre>
tokenContent :: Token -> String

-- | Get detail type string of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.rawTextToken "flower" in (S.subtypeName tok, tokenDetailTypeString tok)
--   ("text", Just "raw")
--   </pre>
tokenDetailTypeString :: Token -> Maybe String

-- | Get token parents from local token.
tokenParents :: Token -> [Token]

-- | Test token is blank, i.e., comment or space.
isBlankToken :: Test Token

-- | Remove blank tokens.
sweepToken :: Map [Token]

-- | Test token is short-type token.
isShortToken :: Test Token

-- | Test token is term-type token.
isTermToken :: Test Token

-- | Test token is open-type token.
isOpenToken :: Test Token

-- | Test token is close-type token.
isCloseToken :: Test Token

-- | Test token is a open-type of the specific bracket.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.TOpen B.def "(" in isOpenTokenOf "(" tok
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.TOpen B.def "{" in isOpenTokenOf "(" tok
--   False
--   </pre>
isOpenTokenOf :: String -> Test Token

-- | Test token is a close-type of the specific bracket.
isCloseTokenOf :: String -> Test Token

-- | Test token is unknown.
isUnknownToken :: Test Token


-- | Token nipper.
module Koshucode.Baala.Syntax.Token.Nipper

-- | Code roll for token.
type TokenScan = CodeScan String Token

-- | Read single token.
type TokenScanMap = Map TokenScan

-- | Nip off a next token.
type TokenNip = CodePt -> InputText -> TokenNipResult

-- | Nip off a next token with word table.
type TokenNipW = CodePt -> WordTable -> InputText -> TokenNipWResult

-- | Nip off a next token with word table.
type TokenNipLW = CodePt -> WordTable -> InputText -> TokenNipLWResult

-- | Nip result.
type TokenNipResult = (InputText, Token)

-- | Nip result with word table.
type TokenNipWResult = (WordTable, InputText, Token)

-- | Nip result with word table.
type TokenNipLWResult = (WordTable, InputText, [Token])

-- | Test character is symbolic.
isSymbol :: Test Char

-- | Test character is space.
isSpace :: Test Char

-- | Test character is double-quote.
isQQ :: Test Char

-- | Test character is term slash.
isTerm :: Test Char

-- | Test character is content line, i.e., <tt>'-'</tt> or <tt>'='</tt>.
isJudge :: Test Char

-- | Test character is component of clock text.
isClock :: Test Char

-- | Update token scanner by nipper result.
nipUpdate :: TokenScan -> TokenNipResult -> TokenScan

-- | Update token scanner by nipper result with word table.
nipUpdateW :: TokenScan -> TokenNipWResult -> TokenScan

-- | Update token scanner by nipper result with word table.
nipUpdateLW :: TokenScan -> TokenNipLWResult -> TokenScan

-- | Nip off space token.
--   
--   <pre>
--   &gt;&gt;&gt; nipSpace B.def "  foo bar baz"
--   ("foo bar baz", TSpace &lt;I0-L0-C0&gt; 3)
--   </pre>
nipSpace :: TokenNip

-- | Nip off a single-quoted text.
--   
--   <pre>
--   &gt;&gt;&gt; nipQ B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", TText &lt;I0-L0-C0&gt; TextQ "foo")
--   </pre>
nipQ :: TokenNipW

-- | Nip off a double-quoted text.
--   
--   <pre>
--   &gt;&gt;&gt; nipQQ B.def "foo\" bar baz"
--   (" bar baz", TText &lt;I0-L0-C0&gt; TextQQ "foo")
--   </pre>
nipQQ :: TokenNip

-- | Nip off symbolic token.
--   
--   <pre>
--   &gt;&gt;&gt; nipSymbol B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", TText &lt;I0-L0-C0&gt; TextRaw "foo")
--   </pre>
nipSymbol :: TokenNipW

-- | Nip off a slot name, like <tt>@foo</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; nipSlot 1 B.def "foo bar baz"
--   (" bar baz", TSlot &lt;I0-L0-C0&gt; 1 "foo")
--   </pre>
nipSlot :: Int -> TokenNip

-- | Nip off a signed term name.
--   
--   <pre>
--   &gt;&gt;&gt; nipTermSign EQ B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", [TTerm &lt;I0-L0-C0&gt; "/foo"])
--   </pre>
nipTermSign :: Ordering -> TokenNipLW

-- | Nip off a term name.
--   
--   <pre>
--   &gt;&gt;&gt; nipTermPath B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", [TTerm &lt;I0-L0-C0&gt; "/foo"])
--   </pre>
nipTermPath :: TokenNipLW

-- | Nip off a quoted term.
--   
--   <pre>
--   &gt;&gt;&gt; nipTermQ B.def Map.empty "foo bar baz"
--   (fromList [], " bar baz", [TText &lt;I0-L0-C0&gt; TextTerm "foo"])
--   </pre>
nipTermQ :: TokenNipLW

-- | Nip off token beginning with <tt>"|"</tt>.
nipBar :: CodePt -> String -> String -> TokenNipResult


-- | Code section.
module Koshucode.Baala.Syntax.Token.Section

-- | Select scanner based on section name.
type ChangeSection = String -> Maybe TokenScanMap

-- | Line begins with triple equal signs is treated as section delimter.
section :: ChangeSection -> (InputText -> TokenScan) -> TokenScanMap

-- | Token scanner.
type Scanner = ChangeSection -> TokenScanMap

-- | Scan tokens in <tt>end</tt> section.
scanEnd :: Scanner

-- | Scan tokens in <tt>note</tt> section.
scanNote :: Scanner

-- | Scan tokens in <tt>license</tt> section.
scanLicense :: Scanner

-- | Scan entire line as text.
scanLine :: TextForm -> Scanner

-- | Section for <tt>koshu-text-assert</tt> command.
scanTextAssert :: Scanner


-- | Tokenizer for relational section.
module Koshucode.Baala.Syntax.Token.Rel

-- | Scan a next token in relational section.
scanRel :: Scanner

-- | Scan interpretation content between <tt>{|</tt> and <tt>|}</tt>.
scanInterp :: Scanner


-- | Token clause.
module Koshucode.Baala.Syntax.Token.Clause

-- | Code clause of tokens.
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Abbreviated tokenizer.
toks :: InputText -> [Token]

-- | Tokenize text.
tokenLines :: NIOPoint -> InputText -> [TokenLine]

-- | Tokenize lazy bytestring.
tokenLinesBz :: NIOPoint -> Bz -> [TokenLine]

-- | Tokenize lazy bytestring.
tokenLinesBzTextAssert :: NIOPoint -> Bz -> [TokenLine]

-- | Test string is short prefix.
isShortPrefix :: Test String


-- | Token and tokenizer.
module Koshucode.Baala.Syntax.Token


-- | Bracket type.
module Koshucode.Baala.Syntax.TTree.Bracket

-- | Type of bracket.
data BracketType

-- | <b>1.</b> Round brackets for grouping: <tt>( E ... )</tt>
BracketGroup :: BracketType

-- | <b>2.</b> Round-single brackets for term path: <tt>(- /P ... -)</tt>
BracketTerm :: BracketType

-- | <b>3.</b> Square brackets for lists: <tt>[ C | ... ]</tt>
BracketList :: BracketType

-- | <b>4.</b> Curely braces for sets: <tt>{ C | ... }</tt>
BracketSet :: BracketType

-- | <b>5.</b> Curely-single braces for ties: <tt>{- /N C ... -}</tt>
BracketTie :: BracketType

-- | <b>6.</b> Curely-double braces for relations: <tt>{= /N ... [ C | ...
--   ][ C | ... ] =}</tt>
BracketRel :: BracketType

-- | <b>7.</b> Curely-bar braces for data interpretation: <tt>{| ... /N ...
--   |}</tt>
BracketInterp :: BracketType

-- | <b>8.</b> Square-single brackets for type: <tt>[- ... -]</tt>
BracketType :: BracketType

-- | <b>9.</b> Round-bar brackets for calculation form: <tt>(| V ... | E
--   ... |)</tt>
BracketForm :: BracketType

-- | <b>10.</b> Unknown bracket
BracketUnknown :: BracketType

-- | Bracket type of token.
getBracketType :: GetBracketType BracketType Token

-- | Open group: <tt>"("</tt>
openGroup :: String

-- | Close group: <tt>")"</tt>
closeGroup :: String

-- | Open term path: <tt>"(-"</tt>
openTerm :: String

-- | Close term path: <tt>"-)"</tt>
closeTerm :: String

-- | Open list: <tt>"["</tt>
openList :: String

-- | Close list: <tt>"]"</tt>
closeList :: String

-- | Open set: <tt>"{"</tt>
openSet :: String

-- | Close set: <tt>"}"</tt>
closeSet :: String

-- | Open tie: <tt>"{-"</tt>
openTie :: String

-- | Close tie: <tt>"-}"</tt>
closeTie :: String

-- | Open relation: <tt>"{="</tt>
openRel :: String

-- | Close relation: <tt>"=}"</tt>
closeRel :: String

-- | Open interpreation: <tt>"{|"</tt>
openInterp :: String

-- | Close interpreation: <tt>"|}"</tt>
closeInterp :: String

-- | Open type: <tt>"[-"</tt>
openType :: String

-- | Close type: <tt>"-]"</tt>
closeType :: String
instance GHC.Classes.Ord Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance GHC.Show.Show Koshucode.Baala.Syntax.TTree.Bracket.BracketType


-- | Tree of tokens
module Koshucode.Baala.Syntax.TTree.TokenTree

-- | Tree of tokens.
type TTree = CodeTree BracketType Token

-- | Pair of token tree and its name.
type NamedTree = Named TTree

-- | Pair of token trees and its name.
type NamedTrees = Named [TTree]

-- | Term leaf.

-- | Text leaf.

-- | Text leaf of <a>TextRaw</a>.

-- | Text leaf beginning with single hyphen.

-- | Text leaf beginning with double hyphens.

-- | Text leaf of <a>TextQ</a>.


-- | Parser for token tree.
module Koshucode.Baala.Syntax.TTree.Parse

-- | Parse tokens with brackets into trees. Blank tokens and comments are
--   excluded.
ttrees :: [Token] -> Ab [TTree]

-- | Wrap trees in group.
ttreeGroup :: [TTree] -> TTree

-- | Convert string to token trees.
tt :: String -> Ab [TTree]

-- | Parse string and group it.
tt1 :: String -> Ab TTree

-- | Parse string and print it.
ttPrint :: String -> IO ()

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: [TTree] -> Doc

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "b c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Left [ TText  CodePt {..} TextRaw "b"
--        , TSpace CodePt {..} 1
--        , TText  CodePt {..} TextRaw "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "a | b | c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Right ( [ TText CodePt {..} TextRaw "a", TSpace CodePt {..} 1]
--         , TText CodePt {..} TextRaw "|"
--         , [ TText  CodePt {..} TextRaw "b"
--           , TSpace CodePt {..} 1
--           , TText  CodePt {..} TextRaw "|"
--           , TText  CodePt {..} TextRaw "c" ] )
--   </pre>
splitTokensBy :: Test String -> SplitList3e Token

-- | Split token trees by quoteless token of given string.
splitTreesBy :: Test String -> SplitList3e TTree

-- | Divide token trees by quoteless token of given string.
divideTreesBy :: Test String -> [TTree] -> [[TTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
divideTreesByBar :: [TTree] -> [[TTree]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: [TTree] -> [[TTree]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: [TTree] -> [[TTree]]


-- | Token trees.
module Koshucode.Baala.Syntax.TTree


-- | Patterns for token tree.
module Koshucode.Baala.Syntax.TTree.Pattern

-- | Token leaf.

-- | Token branch.

-- | Text leaf.

-- | Raw text leaf.

-- | Double-quoted text leaf.


-- | Parameter.
module Koshucode.Baala.Syntax.Para


-- | Message list.
module Koshucode.Baala.Syntax.Attr.Message

-- | Abortable scope for attribute.
abAttr :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for attribute.
abAttrTrees :: [TTree] -> MapAb b

-- | Abortable scope for slot.
abSlot :: (CodePtr cp) => [cp] -> MapAb b

-- | Abortable scope for slot.
abSlotTree :: TTree -> MapAb b

-- | Same as <tt>abortable</tt> except for using <a>TTree</a> instead of
--   list of <a>Token</a>.
abortableTree :: String -> TTree -> MapAb b

-- | Same as <tt>abortable</tt> except for using list of <a>TTree</a>
--   instead of list of <a>Token</a>.
abortableTrees :: String -> [TTree] -> MapAb b

-- | Unexpected attribute / Duplicate
dupAttr :: [TermName] -> Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unmatch any patterns
unexpAttrMulti :: [ParaUnmatch String] -> Ab a


-- | Bundle of message modules.
module Koshucode.Baala.Syntax.Message


-- | Slot substitution.
module Koshucode.Baala.Syntax.Attr.Slot

-- | Attribute name and its contents.
type AttrTree = (AttrName, [TTree])

-- | Global slot name and its content.
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [TTree]


-- | Attribute editor.
module Koshucode.Baala.Syntax.Attr.AttrEd

-- | Attribute editor with source code information.
type AttrEd = Sourced AttrEdBody

-- | Operators for attribute editors.
data AttrEdBody

-- | <b>id:</b> Identity editor
AttrEdId :: AttrEdBody

-- | <b>add:</b> Add attribute
AttrEdAdd :: Bool -> String -> [TTree] -> AttrEdBody

-- | <b>rename:</b> Rename attribute keyword
AttrEdRename :: (String, String) -> AttrEdBody

-- | <b>fill:</b> Fill positional attributes
AttrEdFill :: [Maybe TTree] -> AttrEdBody

-- | <b>nest:</b> Nested relation reference
AttrEdNest :: String -> [TTree] -> AttrEdBody

-- | Append editors
AttrEdAppend :: [AttrEd] -> AttrEdBody

-- | Construct attribute editor.
consAttrEd :: [TTree] -> Ab AttrEd

-- | Edit relmap attributes.
runAttrEd :: AttrEd -> AbMap [AttrTree]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody


-- | Attributes of relmap operator.
module Koshucode.Baala.Syntax.Attr.Attr

-- | Parameter specification for attribute name.
type AttrParaSpec = ParaSpec AttrName

-- | Attribute layout.
data AttrLayout
AttrLayout :: [(Maybe String, AttrBranch)] -> AttrLayout

-- | Single layout.
data AttrBranch
AttrBranch :: AttrParaSpec -> Map AttrName -> AttrBranch

-- | Parameter specification
[attrParaSpec] :: AttrBranch -> AttrParaSpec

-- | Attribute classifier
[attrClassifier] :: AttrBranch -> Map AttrName

-- | Construct attribute branch.
attrBranch :: AttrParaSpec -> AttrBranch

-- | Attribute parameter.
type AttrPara = Para AttrName TTree

-- | Parameterizer for attribute of relmap operator.
type AttrParaze = [TTree] -> Ab AttrPara

-- | Parameterize named attributes.
attrPara :: AttrParaze

-- | Parameterize attributes by its layout.
attrParaBy :: AttrLayout -> AttrParaze

-- | Take out hyphened text (like <tt>"-x"</tt>) from token tree.
maybeSingleHyphen :: TTree -> Maybe String

-- | Take out double-hyphened text (like <tt>"--xyz"</tt>) from token tree.
maybeDoubleHyphen :: TTree -> Maybe String
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrLayout
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrBranch


-- | Parser for attribute layout.
module Koshucode.Baala.Syntax.Attr.Parse

-- | Parse relmap attribute layout.
--   
--   <ul>
--   <li><b><tt>-</tt>Word</b> — Normal attribute</li>
--   <li><b><tt>-</tt>Word<tt>/</tt></b> — Relmap attribute</li>
--   <li><b><tt>-</tt>Word<tt>/^</tt></b> — Local relmap attribute</li>
--   </ul>
parseAttrLayout :: String -> AttrLayout

-- | Parse parameter layout.
--   
--   No positional and one named required <tt>c</tt> attribute.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSpec ". c"
--   [(Nothing, ParaSpec { paraSpecReqN = ["c"], ... })]
--   </pre>
--   
--   Positional required <tt>a</tt>, rest <tt>b</tt>, and one named
--   <tt>c</tt> attributes.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSpec "a b* . c"
--   [(Nothing, ParaSpec { paraSpecPos = ParaItemRest 1 ["a"] "b"
--                       , paraSpecReqP = ["a"]
--                       , paraSpecOptP = ["b"]
--                       , paraSpecReqN = ["c"], ... })]
--   </pre>
--   
--   Set of named layouts.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSpec "a : a | ab : a b"
--   [ (Just "a",  ParaSpec { paraSpecPos = ParaItem 1 ["a"], paraSpecReqP = ["a"], ... })
--   , (Just "ab", ParaSpec { paraSpecPos = ParaItem 2 ["a","b"], paraSpecReqP = ["a","b"], ... })]
--   </pre>
--   
--   Syntax for parameter layout.
--   
--   <ul>
--   <li><i>Multiple</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Single</b> — Single layout</li>
--   <li><b>Single <tt>|</tt> Multiple</b> ... — Multiple layout</li>
--   </ul>
--   
--   <ul>
--   <li><i>Single</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Layout</b> — Layout without tag</li>
--   <li><b>Word <tt>:</tt> Layout</b> — Layout with tag</li>
--   </ul>
--   
--   <ul>
--   <li><i>Layout</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Positional</b> — Positional parameters</li>
--   <li><b>Positional <tt>.</tt> Named</b> — Positional and named
--   parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i>Positional</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Word ...</b> — Positional required parameters</li>
--   <li><b>Word ... Word<tt>?</tt> ...</b> — Positional required and
--   optional parameters</li>
--   <li><b>Word ... Word<tt>*</tt></b> — Positional required and rest
--   parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i>Named</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Name ...</b> — Named parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i>Name</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Word Opt</b> — Named parameter</li>
--   </ul>
--   
--   <ul>
--   <li><i>Opt</i></li>
--   </ul>
--   
--   <ul>
--   <li><b>Empty</b> — Required parameter</li>
--   <li><b><tt>?</tt></b> — Optional parameter</li>
--   </ul>
parseParaSpec :: String -> [(Maybe String, ParaSpec String)]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.Parse.Ror
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.Parse.Ror
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Parse.Ror


-- | Syntax for attributes.
module Koshucode.Baala.Syntax.Attr


-- | Bundle of syntax modules.
module Koshucode.Baala.Syntax
