-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Syntax for Koshucode
--   
--   Syntax for Koshucode
@package koshucode-baala-syntax
@version 0.187.0.0


-- | Term types and related functions.
module Koshucode.Baala.Syntax.Symbol.Term

-- | Term type: pair of term name and content.
type Term c = (TermName, c)

-- | Create term.
--   
--   <pre>
--   &gt;&gt;&gt; term "size" 10 :: Term Int
--   (TermName "size", 10)
--   </pre>
term :: (ToTermName n) => n -> c -> Term c

-- | Name of term, e.g., <tt>"size"</tt> for the term name <tt>/size</tt>.
data TermName

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]

-- | Convert to term name.
class ToTermName a
toTermName :: ToTermName a => a -> TermName

-- | Add necessary slash character indicating term name.
--   
--   <pre>
--   &gt;&gt;&gt; enslash &lt;$&gt; ["foo", "/bar", "+/baz", "-/qux"]
--   ["/foo", "/bar", "+/baz", "-/qux"]
--   </pre>
enslash :: Map String

-- | Decode term name from string.
--   
--   <pre>
--   &gt;&gt;&gt; stringTermName "/a"
--   TermName EQ "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringTermName "+/a"
--   TermName GT "a"
--   </pre>
stringTermName :: String -> TermName

-- | Encode term name into string.
--   
--   <pre>
--   &gt;&gt;&gt; termNameString $ stringTermName "/size"
--   "/size"
--   </pre>
termNameString :: TermName -> String

-- | Encode term path into string.
--   
--   <pre>
--   &gt;&gt;&gt; termPathString [stringTermName "r", stringTermName "x"]
--   "/r/x"
--   </pre>
termPathString :: TermPath -> String

-- | Extract internal name.
--   
--   <pre>
--   &gt;&gt;&gt; termNameContent $ stringTermName "/size"
--   "size"
--   </pre>
termNameContent :: TermName -> String

-- | Sign of term name.
termNameSign :: TermName -> Ordering

-- | Alter sign of term name.
termNameAltSign :: Ordering -> Map TermName

-- | Convert to ordering pair.
orderingTermName :: TermName -> (Ordering, TermName)

-- | Tuple of 2 term names.
type TermName2 = (TermName, TermName)

-- | Tuple of 3 term names.
type TermName3 = (TermName, TermName, TermName)

-- | Tuple of 4 term names.
type TermName4 = (TermName, TermName, TermName, TermName)

-- | Tuple of 5 term names.
type TermName5 = (TermName, TermName, TermName, TermName, TermName)

-- | Tuple of 6 term names.
type TermName6 = (TermName, TermName, TermName, TermName, TermName, TermName)

-- | Term index.
type TermIndex = Int

-- | Term name and index.
type IndexTerm = (TermName, TermIndex)

-- | Test present term.
--   
--   <pre>
--   &gt;&gt;&gt; termP 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termP 0
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termP (-1)
--   False
--   </pre>
termP :: Test TermIndex

-- | Test new term.
termN :: Test TermIndex

-- | Test all terms are present.
termsP :: Test [TermIndex]

-- | Test all terms are new.
--   
--   <pre>
--   &gt;&gt;&gt; termsN [-1, -1]
--   True
--   </pre>
termsN :: Test [TermIndex]

-- | Test present and new terms.
--   
--   <pre>
--   &gt;&gt;&gt; termsPN [1,2] [-1]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termsPN [1,2] [-1,0]
--   False
--   </pre>
termsPN :: Test2 [TermIndex] [TermIndex]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Term.TermName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Term.TermName
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Data.String.IsString Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName GHC.Base.String
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Data.Text.Internal.Text
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Data.Text.Internal.Lazy.Text
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName GHC.Types.Int


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Syntax.Symbol.AngleText

-- | Convert string into double-quoted and angle-quoted form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "\t"
--   &lt;tab&gt;
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "aaa\nbbb\r\nccc\r\n\r\nddd"
--   "aaa" &lt;lf&gt; "bbb" &lt;crlf&gt; "ccc" &lt;crlf&gt; &lt;crlf&gt; "ddd"
--   </pre>
angleQuote :: StringMap

-- | Table of coresspondences of angle text and its replacement.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" angleTexts
--   Just "\n"
--   </pre>
angleTexts :: [(String, String)]


-- | Parameter type.
module Koshucode.Baala.Syntax.Para.Para

-- | Named and positional parameter.
data Para n a
Para :: [ParaTag] -> [a] -> [a] -> ParaMap n a -> Para n a

-- | Parameter tags.
[paraTags] :: Para n a -> [ParaTag]

-- | All parameter elements.
[paraAll] :: Para n a -> [a]

-- | Positional parameters.
[paraPos] :: Para n a -> [a]

-- | Named parameters.
[paraName] :: Para n a -> ParaMap n a

-- | Parameter tag.
type ParaTag = String

-- | Mapping parameter name to its contents.
type ParaMap n a = Map n [[a]]

-- | Test and take parameter name.
type ParaName n a = a -> Maybe n

-- | Parse list into parameter.
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b"
--   Para { paraAll = ["a","b"], paraPos = ["a","b"], paraName = fromList [] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b -x c d"
--   Para { paraAll = ["a","b","-x","c"]
--        , paraPos = ["a","b"]
--        , paraName = fromList [("x",[["c","d"]])] }
--   </pre>
para :: (Ord n) => ParaName n a -> [a] -> Para n a

-- | Association list of named parameters.
paraNameList :: Para n a -> [(n, [[a]])]

-- | List of parameter names.
paraNames :: Para n a -> [n]

-- | List of names which appear more than once.
paraMultipleNames :: Para n a -> [n]

-- | Lookup named parameter.
paraLookup :: (Ord n) => n -> Para n a -> Maybe [[a]]

-- | Lookup single-occurence parameter.
paraLookupSingle :: (Ord n) => n -> Para n a -> Maybe [a]

-- | Give names to positional parameters.
paraPosName :: (Ord n, Monad m) => ([a] -> m [(n, [a])]) -> Para n a -> m (Para n a)

-- | Add named parameter.
paraNameAdd :: (Ord n) => n -> [a] -> Map (Para n a)

-- | Map names of named parameters.
paraNameMapKeys :: (Ord n2) => (n1 -> n2) -> Para n1 a -> Para n2 a

-- | Take first element from multiply given named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = para paraHyphen $ words "a -x 1 -x 2 -x 3"
--   
--   &gt;&gt;&gt; p
--   Para { ..., paraName = fromList [("x", [["1"],["2"],["3"]])] }
--   
--   &gt;&gt;&gt; paraTakeFirst "x" p
--   Para { ..., paraName = fromList [("x", [["1"]])] }
--   </pre>
paraTakeFirst :: (Ord n) => n -> Para n a -> Para n a

-- | Take last element from multiply given named parameter.
paraTakeLast :: (Ord n) => n -> Para n a -> Para n a

-- | String-named parameter.
type SimplePara a = Para String a

-- | Composition of word separation and parameter parsing.
paraWords :: (Ord n) => ParaName n String -> String -> Para n String

-- | Parameter name is beginning with hyphen.
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "-foo"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "bar"
--   Nothing
--   </pre>
paraHyphen :: ParaName String String
instance (GHC.Classes.Ord n, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Classes.Eq n, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance GHC.Classes.Ord n => GHC.Base.Monoid (Koshucode.Baala.Syntax.Para.Para.Para n a)


-- | Parameter specification.
module Koshucode.Baala.Syntax.Para.ParaSpec

-- | Parameter specification.
data ParaSpec n
ParaSpec :: ParaSpecPos n -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> ParaSpec n

-- | <b>Positional:</b> Positional parameter
[paraSpecPos] :: ParaSpec n -> ParaSpecPos n

-- | <b>Positional:</b> Positional required parameters
[paraSpecReqP] :: ParaSpec n -> [n]

-- | <b>Positional:</b> Positional optional parameters
[paraSpecOptP] :: ParaSpec n -> [n]

-- | <b>Named:</b> Explicitly-named required parameters
[paraSpecReqN] :: ParaSpec n -> [n]

-- | <b>Named:</b> Explicitly-named optional parameters
[paraSpecOptN] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use first parameters
[paraSpecFirst] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use last parameters
[paraSpecLast] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use all parameters
[paraSpecMulti] :: ParaSpec n -> [n]

-- | Name list of all parameters.
paraSpecNames :: ParaSpec n -> [n]

-- | Name list of positional parameters.
paraSpecNamesP :: ParaSpec n -> [n]

-- | Name list of explicitly-named parameters.
paraSpecNamesN :: ParaSpec n -> [n]

-- | Positional parameter specification.
data ParaSpecPos n

-- | Named positional parameters
ParaItem :: Int -> [n] -> ParaSpecPos n

-- | Named positional and optional parameters
ParaItemOpt :: Int -> [n] -> [n] -> ParaSpecPos n

-- | Named positional and rest parameters
ParaItemRest :: Int -> [n] -> n -> ParaSpecPos n

-- | Lower bound of parameter length
ParaMin :: Int -> ParaSpecPos n

-- | Lower and upper bound of parameter length
ParaRange :: Int -> Int -> ParaSpecPos n

-- | Minimal length of positional parameters.
paraMinLength :: ParaSpecPos n -> Int

-- | Unmatch reason of real parameter and its specifition.
data ParaUnmatch n

-- | Positional parameter is unmatched.
ParaPos :: Int -> (ParaSpecPos n) -> ParaUnmatch n

-- | Unknown parameter is specified.
ParaUnknown :: [n] -> ParaUnmatch n

-- | Required parameter is missing.
ParaMissing :: [n] -> ParaUnmatch n

-- | Parameter occurs more than once.
ParaMultiple :: [n] -> ParaUnmatch n

-- | Either something or parameter.
type ParaOr left n a = Either left (Para n a)

-- | Test and revise parameter to satisfy specification.
paraMatch :: (Eq n, Ord n) => ParaSpec n -> Para n a -> ParaOr (ParaUnmatch n) n a

-- | Select matched specification and apply parameter value function.
paraSelect :: (Eq n, Ord n) => b -> [(ParaSpec n, Para n a -> b)] -> Para n a -> b

-- | Collect parameter tags.
paraChoose :: (Ord n) => [(Maybe ParaTag, ParaSpec n)] -> Para n a -> ParaOr [ParaUnmatch n] n a

-- | Mapping of parameter specification.
type ParaSpecMap n = Map (ParaSpec n)

-- | Create parameter specification.
paraSpec :: (Show n, Ord n) => ParaSpecMap n -> ParaSpec n

-- | Lower bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMin 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaPos ...
--   </pre>
paraMin :: Int -> ParaSpecMap n

-- | Upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMax 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Left ParaPos ...
--   </pre>
paraMax :: Int -> ParaSpecMap n

-- | Fixed-length positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraJust 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaPos ...
--   </pre>
paraJust :: Int -> ParaSpecMap n

-- | Lower and upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraRange 1 2
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Left ParaPos ...
--   </pre>
paraRange :: Int -> Int -> ParaSpecMap n

-- | No positional parameter.
para0 :: ParaSpecMap n

-- | Named one positional parameter.
para1 :: n -> ParaSpecMap n

-- | Named two positional parameters.
para2 :: n -> n -> ParaSpecMap n

-- | Named three positional parameters.
para3 :: n -> n -> n -> ParaSpecMap n

-- | Named arbitrary positional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItem ["x", "y", "z", "w"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]), ..., ("w",[["d"]])] })
--   </pre>
paraItem :: [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemOpt ["x", "y"] ["z"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]])] })
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c"]])] })
--   </pre>
paraItemOpt :: [n] -> [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemRest ["x", "y"] "z"
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c","d"]])] })
--   </pre>
paraItemRest :: [n] -> n -> ParaSpecMap n

-- | Required named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Left (ParaUnknown ["y"])
--   </pre>
paraReq :: [n] -> ParaSpecMap n

-- | Optional named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraOpt ["y"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Right (Para { ..., paraName = fromList [("x", [["a"]]), ("y", [["b"]])] })
--   </pre>
paraOpt :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use first parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraFirst ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"]])] })
--   </pre>
paraFirst :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use last parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraLast ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["b","c"]])] })
--   </pre>
paraLast :: [n] -> ParaSpecMap n

-- | Multiple-occurence parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraMulti ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"],["b","c"]])] })
--   </pre>
paraMulti :: [n] -> ParaSpecMap n
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch


-- | Parse parameter specification.
module Koshucode.Baala.Syntax.Para.Parse

-- | Parse parameter layout. This function divides a given string by
--   vertical bar <tt>"|"</tt>, then parse each layouts.
parseParaSpec :: String -> [(Maybe ParaTag, ParaSpec String)]

-- | Parse list of single layout.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaList [ "a : -a", "ab : -a -b" ]
--   [ (Just "a", ParaSpec { paraSpecPos = ParaItem 1 ["-a"]
--                         , paraSpecReqP = ["-a"], ... })
--   , (Just "ab", ParaSpec { paraSpecPos = ParaItem 2 ["-a","-b"]
--                          , paraSpecReqP = ["-a","-b"], ... }) ]
--   </pre>
parseParaList :: [String] -> [(Maybe ParaTag, ParaSpec String)]

-- | Parse single layout.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSingle "ab : -a -b"
--   (Just "ab", ParaSpec { paraSpecPos = ParaItem 2 ["-a","-b"]
--                        , paraSpecReqP = ["-a","-b"], ...} )
--   </pre>
parseParaSingle :: String -> (Maybe ParaTag, ParaSpec String)

-- | Report bug of parameter specification.
paraBug :: String -> String -> a
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Para.Parse.Ror
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Para.Parse.Ror
instance GHC.Show.Show Koshucode.Baala.Syntax.Para.Parse.Ror


-- | Getters for parameter.
module Koshucode.Baala.Syntax.Para.Get

-- | Named parageter.
paraGet :: (Ord n) => Para n a -> n -> Ab [a]

-- | Named parameter with default content.
paraGetOpt :: (Ord n) => [a] -> Para n a -> n -> Ab [a]

-- | Multiple-occurence parameter.
paraGetList :: (Ord n) => Para n a -> n -> Ab [[a]]

-- | S.Parameter as switch, just given or not.
paraGetSwitch :: (Ord n) => Para n a -> n -> Ab Bool

-- | Whole positional parameter list.
paraGetPos :: Para n a -> Ab [a]

-- | First positional parameter.
paraGetFst :: Para n a -> Ab a

-- | Second positional parameter.
paraGetSnd :: Para n a -> Ab a

-- | Third positional parameter.
paraGetTrd :: Para n a -> Ab a

-- | Positional parameter list but first element.
paraGetRest :: Para n a -> Ab [a]

-- | Positional parameter list but first and second element.
paraGetRRest :: Para n a -> Ab [a]


-- | Attribute name.
module Koshucode.Baala.Syntax.Attr.AttrName

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: String -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: String -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Attribute string with hyphen.
attrNameCode :: AttrName -> String

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrName.AttrName


-- | Message list.
module Koshucode.Baala.Syntax.Token.Message

-- | Abortable scope for token.
abToken :: (GetCodePos cp) => Abortable cp b

-- | Forbidden input
forbiddenInput :: String -> Ab a

-- | Unexpedted section delimiter
unexpSect :: [String] -> Ab a

-- | Unknown bracket text
unkAngleText :: String -> Ab a


-- | Message list.
module Koshucode.Baala.Syntax.Symbol.Message

-- | Expect ordinary symbol
expOrdSym :: Ab a

-- | Quotation not end in line
quotNotEnd :: Ab a


-- | Next character sequence.
module Koshucode.Baala.Syntax.Symbol.Next

-- | Input data type.
type InputText = String

-- | Split next character sequence from input text.
type Next a = InputText -> (InputText, a)

-- | Split next character sequence from input text.
type AbNext a = InputText -> Ab (InputText, a)

-- | Get next spaces. Space character is decided by <a>isSpace</a>.
--   
--   <pre>
--   &gt;&gt;&gt; nextSpace " abc"
--   ("abc", 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSpace " \tabc"
--   ("abc", 2)
--   </pre>
nextSpace :: Next Int

-- | Get next double quoted text. A single double quote ends text. A double
--   double quote does not end text, but it is converted to double quote.
--   
--   <pre>
--   &gt;&gt;&gt; nextQQ "abc\" def"
--   Right (" def","abc")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextQQ "abc\"\"def\" ghi"
--   Right (" ghi","abc\"def")
--   </pre>
nextQQ :: AbNext String


-- | Symbol type.
module Koshucode.Baala.Syntax.Symbol.Symbol

-- | Symbol class.
--   
--   Relation between character classes and symbol classes. The char class
--   <tt>number'</tt> means Unicode number except for <tt>0-9</tt>.
--   <tt>G</tt> for general symbol, <tt>P</tt> for plain, <tt>N</tt> for
--   numeric.
--   
--   <pre>
--   Char class   Symbol class        Symbol type
--   ------------ ------------------- -----------------
--   "0-9"        ( G ) ( P ) ( N )   SymbolCommon
--   "-"          ( G ) ( P ) ( N )   SymbolCommon
--   letter       ( G )   P           SymbolPlain
--   mark         ( G )   P           SymbolPlain
--   number'      ( G )   P           SymbolPlain
--   "_?"         ( G )   P           SymbolPlain
--   "+"          ( G )         N     SymbolNumeric
--   "*=&lt;&gt;~"        G                 SymbolGeneral
--   ".#"                       N     SymbolNumeric
--   </pre>
--   
--   Partial order between the symbol classes.
--   
--   <pre>
--                     ( GPN ) Common
--                    /      |
--           Plain ( GP )  ( GN ) Numeric
--                /  |    /  |
--   Short ( P.P )   |   /   |
--            :      |  /    |
--         General ( G )     |
--            :      :     ( N ) Numeric
--            :      :       :
--            ................ Unknown
--   </pre>
data Symbol

-- | <b>1.</b> General-plain-numeric symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "1"
--   ("", SymbolCommon "1")
--   </pre>
SymbolCommon :: String -> Symbol

-- | <b>2.</b> Plain (include general) symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "a"
--   ("", SymbolPlain "a")
--   </pre>
SymbolPlain :: String -> Symbol

-- | <b>3.</b> Numeric (include general) symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "+"
--   ("", SymbolNumeric "+")
--   </pre>
SymbolNumeric :: String -> Symbol

-- | <b>4.</b> General (not plain nor numeric) symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "="
--   ("", SymbolGeneral "=")
--   </pre>
SymbolGeneral :: String -> Symbol

-- | <b>5.</b> Short symbol (Plain <tt>"."</tt> Plain)
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "a.xxx"
--   ("", SymbolShort "a" "xxx")
--   </pre>
SymbolShort :: String -> String -> Symbol

-- | <b>6.</b> Unknown symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "a+"
--   ("", SymbolUnknown "a+")
--   </pre>
SymbolUnknown :: String -> Symbol

-- | Test symbol is general, in other words, <a>SymbolCommon</a>,
--   <a>SymbolPlain</a> or <a>SymbolGeneral</a>.
isGeneralSymbol :: Test Symbol

-- | Test symbol is plain, in other words, <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
isPlainSymbol :: Test Symbol

-- | Test symbol is numeric, in other words, <a>SymbolCommon</a> or
--   <a>SymbolNumeric</a>.
isNumericSymbol :: Test Symbol

-- | Test symbol is <a>SymbolShort</a>.
isShortSymbol :: Test Symbol

-- | Test character is a symbol component.
isSymbolChar :: Test Char

-- | Test character is a general-symbol component.
isGeneralChar :: Test Char

-- | Test character is a plain-symbol component.
isPlainChar :: Test Char

-- | Test character is a numeric-symbol component.
isNumericChar :: Test Char

-- | Get next symbol.
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "foo bar"
--   (" bar", SymbolPlain "foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "0.50"
--   ("", SymbolNumeric "0.50")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "= /a"
--   (" /a", SymbolGeneral "=")
--   </pre>
nextSymbol :: Next Symbol

-- | Get next plain symbol, i.e., <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbolPlain "foo bar"
--   Right (" bar","foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbolPlain "12.0"
--   Left (AbortReason "Expect ordinary symbol" ...)
--   </pre>
nextSymbolPlain :: AbNext String
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Symbol.Symbol
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Symbol.Symbol
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Symbol.Symbol


-- | Short sign.
module Koshucode.Baala.Syntax.Symbol.Short

-- | Something with short definition.
data Short a
Short :: [CodePos] -> [ShortDef] -> a -> Short a

-- | Source information
[shortSource] :: Short a -> [CodePos]

-- | Definition of short signs
[shortHead] :: Short a -> [ShortDef]

-- | Body with short signs
[shortBody] :: Short a -> a

-- | Short prefix and replacement.
type ShortDef = Named String

-- | Omit empty body.
shortTrim :: Map [Short [a]]

-- | Evaluate body of short structures.
shortListM :: (Monad m) => [Short (m a)] -> m [Short a]

-- | Group short structures.
shortGroup :: [Short a] -> [Short [a]]

-- | String shortener.
shortText :: [ShortDef] -> TransString
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Symbol.Short.Short


-- | Symbols
module Koshucode.Baala.Syntax.Symbol


-- | Tokens in Koshucode.
module Koshucode.Baala.Syntax.Token.Token

-- | Type wihch has subtype and its name.
class SubtypeName a
subtypeName :: SubtypeName a => a -> String

-- | There are eleven types of tokens.
data Token

-- | <b>1 Textual:</b> Text — <tt>'code</tt>, <tt>"text"</tt>, etc
TText :: CodePos -> TextForm -> String -> Token

-- | <b>2 Textual:</b> Prefixed shorten text — <tt>short.proper</tt>
TShort :: CodePos -> String -> String -> Token

-- | <b>3 Textual:</b> Term name — <tt>/term</tt>
TTerm :: CodePos -> String -> Token

-- | <b>4 Symbolic:</b> Local name — <tt>^r</tt>, <tt>^/r</tt>
TLocal :: CodePos -> LocalRef -> Int -> [Token] -> Token

-- | <b>5 Symbolic:</b> Slot name. <a>Int</a> represents slot level, i.e.,
--   0 for local positional slots, 1 for local named slots, 2 for global
--   slots — <tt>@slot</tt>, <tt>@@global</tt>
TSlot :: CodePos -> Int -> String -> Token

-- | <b>6 Symbolic:</b> Blank name. (This is only used in building content
--   expression)
TName :: CodePos -> BlankName -> Token

-- | <b>7 Punctuational:</b> Opening bracket — <tt>(</tt>, <tt>{</tt>,
--   <tt>{=</tt>, etc
TOpen :: CodePos -> String -> Token

-- | <b>8 Punctuational:</b> Closing bracket — <tt>=}</tt>, <tt>}</tt>,
--   <tt>)</tt>, etc
TClose :: CodePos -> String -> Token

-- | <b>9 Punctuational:</b> <i>N</i> space characters
TSpace :: CodePos -> Int -> Token

-- | <b>10 Punctuational:</b> Comment — <tt>** comment line</tt>
TComment :: CodePos -> String -> Token

-- | <b>11 Other:</b> Unknown token
TUnknown :: CodePos -> String -> AbortReason -> Token

-- | Create raw text token.
rawTextToken :: String -> Token

-- | Create unknown token.
unknownToken :: CodePos -> String -> Ab a -> Token

-- | Subtype of text token.
data TextForm

-- | <b>1.</b> Unknown keyword — <tt>&lt;unknown&gt;</tt>
TextUnk :: TextForm

-- | <b>2.</b> Naked text — <tt>raw</tt>
TextRaw :: TextForm

-- | <b>3.</b> Single-quoted text — <tt>'code</tt>
TextQ :: TextForm

-- | <b>4.</b> Double-quoted text — <tt>"text"</tt>
TextQQ :: TextForm

-- | <b>5.</b> Keyword literal — <tt>&lt;crlf&gt;</tt>
TextKey :: TextForm

-- | <b>6.</b> Quoted term name — <tt>'/term</tt>
TextTerm :: TextForm

-- | <b>7.</b> Text enclosed in bars — <tt>|9:30|</tt>
TextBar :: TextForm

-- | <b>8.</b> Text in license section — <tt>=== license</tt>
TextLicense :: TextForm

-- | Local relation reference.
data LocalRef

-- | Reference to local relation — <tt>^r</tt>
LocalSymbol :: String -> LocalRef

-- | Reference to nested relation — <tt>^/r</tt>
LocalNest :: TermName -> LocalRef

-- | Blank in form.
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Text.PPrint.PPrint Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.LocalRef
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.BlankName
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.BlankName


-- | Token pattern.
module Koshucode.Baala.Syntax.Token.Pattern

-- | Text token.

-- | Unknown text.

-- | Raw text.

-- | Section sign: <tt>"==="</tt>

-- | Single-quoted text.

-- | Double-quoted text.

-- | Keyword text.

-- | Bar-enclosed text.

-- | License text.

-- | Term token.


-- | Token utilities.
module Koshucode.Baala.Syntax.Token.Utility

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; tokenContent $ S.TOpen B.def "("
--   "("
--   </pre>
tokenContent :: Token -> String

-- | Get detail type string of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.rawTextToken "flower" in (S.subtypeName tok, tokenDetailTypeString tok)
--   ("text", Just "raw")
--   </pre>
tokenDetailTypeString :: Token -> Maybe String

-- | Get token parents from local token.
tokenParents :: Token -> [Token]

-- | Prepare token list for parsing.
--   
--   <ol>
--   <li>Remove spaces.</li>
--   <li>Remove comments.</li>
--   <li>Join fragmented texts.</li>
--   </ol>
prepareTokens :: Map [Token]

-- | Remove blank tokens.
sweepToken :: Map [Token]

-- | Test token is blank, i.e., comment or space.
isBlankToken :: Test Token

-- | Test token is short-type token.
isShortToken :: Test Token

-- | Test token is term-type token.
isTermToken :: Test Token

-- | Test token is open-type token.
isOpenToken :: Test Token

-- | Test token is close-type token.
isCloseToken :: Test Token

-- | Create bracket testers.
isBracketTokenOf :: (String, String) -> (Test Token, Test Token)

-- | Test token is unknown.
isUnknownToken :: Test Token


-- | Clip token text.
module Koshucode.Baala.Syntax.Token.Clip

-- | Test character is symbolic.
isSymbol :: Test Char

-- | Test character is space.
isSpace :: Test Char

-- | Test character is double-quote.
isQQ :: Test Char

-- | Test character is term slash.
isTerm :: Test Char

-- | Test character is content line, i.e., <tt>'-'</tt> or <tt>'='</tt>.
isJudge :: Test Char

-- | Test character is component of clock text.
isClock :: Test Char

-- | Code scanner for token list.
type TokenScan = CodeScan String Token

-- | Read single token.
type TokenScanMap = Map TokenScan

-- | Clip single-token result.
type ClipResult = (InputText, Token)

-- | Clip single-token result with word cache.
type ClipResultC = (WordCache, InputText, Token)

-- | Clip multiple-tokens result with word cache.
type ClipResultCL = (WordCache, InputText, [Token])

-- | Clip a next token.
type ClipToken = CodePos -> InputText -> ClipResult

-- | Clip a next token with word cache.
type ClipTokenC = CodePos -> WordCache -> InputText -> ClipResultC

-- | Clip a next token with word cache.
type ClipTokenCL = CodePos -> WordCache -> InputText -> ClipResultCL

-- | Update token scanner by clip result.
clipUpdate :: TokenScan -> ClipResult -> TokenScan

-- | Update token scanner by clip result with word cache.
clipUpdateC :: TokenScan -> ClipResultC -> TokenScan

-- | Update token scanner by clip result with word cache.
clipUpdateCL :: TokenScan -> ClipResultCL -> TokenScan

-- | Clip space token.
--   
--   <pre>
--   &gt;&gt;&gt; clipSpace B.def "  foo bar baz"
--   ("foo bar baz", TSpace /0.0.0/ 3)
--   </pre>
clipSpace :: ClipToken

-- | Clip single-quoted text.
--   
--   <pre>
--   &gt;&gt;&gt; clipQ B.def O.emptyWordCache "foo bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextQ "foo")
--   </pre>
clipQ :: ClipTokenC

-- | Clip double-quoted text.
--   
--   <pre>
--   &gt;&gt;&gt; clipQQ B.def O.emptyWordCache "foo\" bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextQQ "foo")
--   </pre>
clipQQ :: ClipTokenC

-- | Clip symbolic token.
--   
--   <pre>
--   &gt;&gt;&gt; clipSymbol B.def O.emptyWordCache "foo bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextRaw "foo")
--   </pre>
clipSymbol :: ClipTokenC

-- | Clip slot name, like <tt>@foo</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clipSlot 1 B.def "foo bar baz"
--   (" bar baz", TSlot /0.0.0/ 1 "foo")
--   </pre>
clipSlot :: Int -> ClipToken

-- | Clip signed term name.
--   
--   <pre>
--   &gt;&gt;&gt; clipTermSign "+/" B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", [TTerm &lt;I0-L0-C0&gt; "+/foo"])
--   </pre>
clipTermSign :: String -> ClipTokenCL

-- | Clip term name.
--   
--   <pre>
--   &gt;&gt;&gt; clipTermName B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", [TTerm &lt;I0-L0-C0&gt; "/foo"])
--   </pre>
clipTermName :: ClipTokenCL

-- | Clip quoted term.
--   
--   <pre>
--   &gt;&gt;&gt; clipTermQ B.def Map.empty "foo bar baz"
--   (fromList [], " bar baz", [TText &lt;I0-L0-C0&gt; TextTerm "foo"])
--   </pre>
clipTermQ :: ClipTokenCL

-- | Clip token beginning with <tt>"|"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clipBar B.def "-- C"
--   (" C", TText /0.0.0/ TextBar "|--")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clipBar B.def "| ..."
--   ("...", TText /0.0.0/ TextRaw "||")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clipBar B.def "12:00| ..."
--   (" ...", TText /0.0.0/ TextBar "|12:00|")
--   </pre>
clipBar :: CodePos -> String -> ClipResult


-- | Code section.
module Koshucode.Baala.Syntax.Token.Section

-- | Select scanner based on section name.
type ChangeSection = String -> Maybe TokenScanMap

-- | Line begins with triple equal signs is treated as section delimter.
section :: ChangeSection -> (InputText -> TokenScan) -> TokenScanMap

-- | Token scanner.
type Scanner = ChangeSection -> TokenScanMap

-- | Scan tokens in <tt>end</tt> section.
scanEnd :: Scanner

-- | Scan tokens in <tt>note</tt> section.
scanNote :: Scanner

-- | Scan tokens in <tt>license</tt> section.
scanLicense :: Scanner

-- | Scan entire line as text.
scanLine :: TextForm -> Scanner

-- | Section for <tt>koshu-text-assert</tt> command.
scanTextAssert :: Scanner


-- | Tokenizer for relational section.
module Koshucode.Baala.Syntax.Token.Rel

-- | Scan a next token in relational section.
scanRel :: Scanner

-- | Scan interpretation content between <tt>{|</tt> and <tt>|}</tt>.
scanInterp :: Scanner


-- | Token line and clause.
module Koshucode.Baala.Syntax.Token.Clause

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Tokenize lazy bytestring.
tokenLines :: (ToCode code) => IxIOPoint -> code -> [TokenLine]

-- | Tokenize lazy bytestring.
tokenLinesTextAssert :: (ToCode code) => IxIOPoint -> code -> [TokenLine]

-- | Test string is short prefix.
isShortPrefix :: Test String

-- | Read token lines from file.
readTokenLines :: FilePath -> IOAb [TokenLine]

-- | Code clause of tokens.
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]

-- | Read clause list from file.
--   
--   Content of file <tt>clause.txt</tt>:
--   
--   <pre>
--   **
--   **  This is an example file for 'readClauses' function
--   **  defined in Koshucode.Baala.Syntax.Token.Clause module.
--   **
--   
--   aa
--   bb
--    cc
--   
--   ** dd
--   ee
--   </pre>
--   
--   Read this file and parse to token clauses.
--   
--   <pre>
--   &gt;&gt;&gt; O.printList =&lt;&lt; B.abortLeft =&lt;&lt; readClauses "clause.txt"
--   CodeClause {clauseLines = ..., clauseTokens = [TText /0.1.0/ TextRaw "aa"]}
--   CodeClause {clauseLines = ..., clauseTokens = [TText /0.2.0/ TextRaw "bb",
--                                                  TText /0.3.1/ TextRaw "cc"]}
--   CodeClause {clauseLines = ..., clauseTokens = [TText /0.6.0/ TextRaw "ee"]}
--   </pre>
readClauses :: FilePath -> IOAb [TokenClause]

-- | Read clauses and extract tokens.
readClauseTokens :: FilePath -> IOAb [[Token]]

-- | Abbreviated tokenizer.
toks :: String -> [Token]

-- | Tokenize and print for debug.
--   
--   Words and quotations.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["aa", "'bb", "\"cc\"", "&lt;dd&gt;", "'/ee", "|012|"]
--   TText /0.1.0/ TextRaw "aa"
--   TText /0.2.0/ TextQ "bb"
--   TText /0.3.0/ TextQQ "cc"
--   TText /0.4.0/ TextUnk "dd"
--   TText /0.5.0/ TextTerm "ee"
--   TText /0.6.0/ TextBar "|012|"
--   </pre>
--   
--   Judgement.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["|-- R  /a A0 /b 31"]
--   TText /0.1.0/ TextBar "|--"
--   TSpace /0.1.3/ 1
--   TText /0.1.4/ TextRaw "R"
--   TSpace /0.1.5/ 2
--   TTerm /0.1.7/ "/a"
--   TSpace /0.1.9/ 1
--   TText /0.1.10/ TextRaw "A0"
--   TSpace /0.1.12/ 1
--   TTerm /0.1.13/ "/b"
--   TSpace /0.1.15/ 1
--   TText /0.1.16/ TextRaw "31"
--   </pre>
--   
--   Brackets.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["aa (bb x y (z))"]
--   TText /0.1.0/ TextRaw "aa"
--   TSpace /0.1.2/ 1
--   TOpen /0.1.3/ "("
--   TText /0.1.4/ TextRaw "bb"
--   TSpace /0.1.6/ 1
--   TText /0.1.7/ TextRaw "x"
--   TSpace /0.1.8/ 1
--   TText /0.1.9/ TextRaw "y"
--   TSpace /0.1.10/ 1
--   TOpen /0.1.11/ "("
--   TText /0.1.12/ TextRaw "z"
--   TClose /0.1.13/ ")"
--   TClose /0.1.14/ ")"
--   </pre>
--   
--   Comment.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["abc ** this is a comment", "def",""]
--   TText /0.1.0/ TextRaw "abc"
--   TSpace /0.1.3/ 1
--   TComment /0.1.4/ " this is a comment"
--   TText /0.2.0/ TextRaw "def"
--   </pre>
toksPrint :: [String] -> IO ()

-- | Parse string to clause and print it for inspection.
--   
--   <pre>
--   &gt;&gt;&gt; clausePrint ["|-- A /x 0 /y 1", "", "|== B : ", "  source A /x /y"]
--   ********** |-- A /x 0 /y 1
--   TText /0.1.0/ TextBar "|--"
--   TText /0.1.4/ TextRaw "A"
--   TTerm /0.1.6/ "/x"
--   TText /0.1.9/ TextRaw "0"
--   TTerm /0.1.11/ "/y"
--   TText /0.1.14/ TextRaw "1"
--   ********** |== B : 
--   TText /0.3.0/ TextBar "|=="
--   TText /0.3.4/ TextRaw "B"
--   TText /0.3.6/ TextRaw ":"
--   TText /0.4.2/ TextRaw "source"
--   TText /0.4.9/ TextRaw "A"
--   TTerm /0.4.11/ "/x"
--   TTerm /0.4.14/ "/y"
--   </pre>
clausePrint :: [String] -> IO ()


-- | Token and tokenizer.
module Koshucode.Baala.Syntax.Token


-- | Bracket type.
module Koshucode.Baala.Syntax.TTree.Bracket

-- | Type of bracket.
data BracketType

-- | <b>1.</b> Round brackets for grouping:
--   
--   <pre>
--   ( E ... )
--   </pre>
BracketGroup :: BracketType

-- | <b>2.</b> Round-single brackets for term path:
--   
--   <pre>
--   (- /N ... -)
--   </pre>
BracketTerm :: BracketType

-- | <b>3.</b> Square brackets for lists:
--   
--   <pre>
--   [ C | ... ]
--   </pre>
BracketList :: BracketType

-- | <b>4.</b> Curely braces for sets:
--   
--   <pre>
--   { C | ... }
--   </pre>
BracketSet :: BracketType

-- | <b>5.</b> Curely-single braces for ties:
--   
--   <pre>
--   {- /N C ... -}
--   </pre>
BracketTie :: BracketType

-- | <b>6.</b> Curely-double braces for relations:
--   
--   <pre>
--   {= /N ... [ C | ... ][ C | ... ] =}
--   </pre>
BracketRel :: BracketType

-- | <b>7.</b> Curely-bar braces for data interpretation:
--   
--   <pre>
--   {| ... /N ... |}
--   </pre>
BracketInterp :: BracketType

-- | <b>8.</b> Square-single brackets for type:
--   
--   <pre>
--   [- ... -]
--   </pre>
BracketType :: BracketType

-- | <b>9.</b> Round-bar brackets for calculation form:
--   
--   <pre>
--   (| V ... | E ... |)
--   </pre>
BracketForm :: BracketType

-- | <b>10.</b> Unknown bracket
BracketUnknown :: BracketType

-- | Bracket type of token.
getBracketType :: GetBracketType BracketType Token

-- | Group bracket — <tt>"("</tt> and <tt>")"</tt>
bracketGroup :: (String, String)

-- | Term bracket — <tt>"(-"</tt> and <tt>"-)"</tt>
bracketTerm :: (String, String)

-- | List bracket — <tt>"["</tt> and <tt>"]"</tt>
bracketList :: (String, String)

-- | Set bracket — <tt>"{"</tt> and <tt>"}"</tt>
bracketSet :: (String, String)

-- | Tie bracket — <tt>"{-"</tt> and <tt>"-}"</tt>
bracketTie :: (String, String)

-- | Relation bracket — <tt>"{="</tt> and <tt>"=}"</tt>
bracketRel :: (String, String)

-- | Interpretation bracket — <tt>"{|"</tt> and <tt>"|}"</tt>
bracketInterp :: (String, String)

-- | Type bracket — <tt>"[-"</tt> and <tt>"-]"</tt>
bracketType :: (String, String)
instance GHC.Classes.Ord Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance GHC.Show.Show Koshucode.Baala.Syntax.TTree.Bracket.BracketType
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.TTree.Bracket.BracketType


-- | Patterns for token tree.
module Koshucode.Baala.Syntax.TTree.Pattern

-- | Token leaf.

-- | Text leaf.

-- | Raw text leaf.

-- | Single-hyphen attribute text leaf.

-- | Double-hyphen attribute text leaf.

-- | Single-quoted text leaf.

-- | Double-quoted text leaf.

-- | Slot leaf.

-- | Term leaf.

-- | Token branch.

-- | Group branch.

-- | List branch.

-- | Set branch.

-- | Term path branch.

-- | Form branch.


-- | Syntax patterns. There are three one-letter patterns: <a>B</a> for
--   tree branch, <a>L</a> for tree leaf, and <a>T</a> for text token.
module Koshucode.Baala.Syntax.Pattern


-- | Parser for token tree.
module Koshucode.Baala.Syntax.TTree.Parse

-- | Tree of tokens.
type Tree = CodeTree BracketType Token

-- | Tree of tokens.

-- | <i>Deprecated: Use <a>Tree</a> instead.</i>
type TTree = Tree

-- | Pair of token trees and its name.
type NamedTrees = Named [Tree]

-- | Convert to token trees.
class ToTrees a where toTree a = ttreeGroup <$> toTrees a toTrees' = unabort . toTrees toTree' = unabort . toTree

-- | Convert to list of token trees.
toTrees :: ToTrees a => a -> Ab [Tree]

-- | Convert to token tree.
toTree :: ToTrees a => a -> Ab Tree

-- | List of token trees or error.
toTrees' :: ToTrees a => a -> [Tree]

-- | Token tree or error.
toTree' :: ToTrees a => a -> Tree

-- | Wrap trees in group.
ttreeGroup :: [Tree] -> Tree

-- | Call function with token trees.
--   
--   <pre>
--   &gt;&gt;&gt; withTrees id "a"
--   Right [TreeL (TText /0.1.0/ TextRaw "a")]
--   </pre>
withTrees :: (ToTrees a) => ([Tree] -> b) -> a -> Ab b

-- | Read clauses and convert to token trees.
readClauseTrees :: FilePath -> IOAb [[Tree]]

-- | Convert token trees to <a>Doc</a> value for pretty printing.
treesDoc :: [Tree] -> Doc

-- | Pretty print token trees.
--   
--   <pre>
--   &gt;&gt;&gt; ppTrees "a ( b c )"
--   | TText /1.0/ TextRaw "a"
--   &lt;group&gt; TOpen /1.2/ "(" -- TClose /1.8/ ")"
--     | TText /1.4/ TextRaw "b"
--     | TText /1.6/ TextRaw "c"
--   </pre>
ppTrees :: (ToTrees a) => a -> IO ()
instance Koshucode.Baala.Syntax.TTree.Parse.ToTrees GHC.Base.String
instance Koshucode.Baala.Syntax.TTree.Parse.ToTrees [Koshucode.Baala.Syntax.Token.Token.Token]
instance Koshucode.Baala.Syntax.TTree.Parse.ToTrees [Koshucode.Baala.Syntax.TTree.Parse.Tree]


-- | Split token trees.
module Koshucode.Baala.Syntax.TTree.Split

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "b c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Left [ TText  CodePos {..} TextRaw "b"
--        , TSpace CodePos {..} 1
--        , TText  CodePos {..} TextRaw "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "a | b | c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Right ( [ TText CodePos {..} TextRaw "a", TSpace CodePos {..} 1]
--         , TText CodePos {..} TextRaw "|"
--         , [ TText  CodePos {..} TextRaw "b"
--           , TSpace CodePos {..} 1
--           , TText  CodePos {..} TextRaw "|"
--           , TText  CodePos {..} TextRaw "c" ] )
--   </pre>
splitTokensBy :: Test String -> SplitList3e Token

-- | Split token trees by quoteless token of given string.
splitTreesBy :: Test String -> SplitList3e Tree

-- | Divide token trees by quoteless token of given string.
divideTreesBy :: Test String -> [Tree] -> [[Tree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
divideTreesByBar :: [Tree] -> [[Tree]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: [Tree] -> [[Tree]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: [Tree] -> [[Tree]]


-- | Token trees.
module Koshucode.Baala.Syntax.TTree


-- | Parameter.
module Koshucode.Baala.Syntax.Para


-- | Message list.
module Koshucode.Baala.Syntax.Attr.Message

-- | Abortable scope for attribute.
abAttr :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for attribute.
abAttrTrees :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for slot.
abSlot :: (GetCodePos cp) => Abortable cp b

-- | Unexpected attribute / Duplicate
dupAttr :: [TermName] -> Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unmatch any patterns
unexpAttrMulti :: [(String, ParaUnmatch String)] -> Ab a


-- | Bundle of message modules.
module Koshucode.Baala.Syntax.Message


-- | Slot substitution.
module Koshucode.Baala.Syntax.Attr.Slot

-- | Attribute name and its contents.
type AttrTree = (AttrName, [Tree])

-- | Global slot name and its content.
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [Tree]


-- | Attribute editor.
module Koshucode.Baala.Syntax.Attr.AttrEd

-- | Attribute editor with source code information.
type AttrEd = Codic AttrEdBody

-- | Operators for attribute editors.
data AttrEdBody

-- | <b>id:</b> Identity editor
AttrEdId :: AttrEdBody

-- | <b>add:</b> Add attribute
AttrEdAdd :: Bool -> String -> [Tree] -> AttrEdBody

-- | <b>rename:</b> Rename attribute keyword
AttrEdRename :: (String, String) -> AttrEdBody

-- | <b>fill:</b> Fill positional attributes
AttrEdFill :: [Maybe Tree] -> AttrEdBody

-- | <b>nest:</b> Nested relation reference
AttrEdNest :: String -> [Tree] -> AttrEdBody

-- | Append editors
AttrEdAppend :: [AttrEd] -> AttrEdBody

-- | Construct attribute editor.
consAttrEd :: [Tree] -> Ab AttrEd

-- | Edit relmap attributes.
runAttrEd :: AttrEd -> AbMap [AttrTree]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody


-- | Attributes of relmap operator.
module Koshucode.Baala.Syntax.Attr.Attr

-- | Attribute layout.
data AttrLayout
AttrLayout :: [(Maybe ParaTag, AttrBranch)] -> AttrLayout

-- | Single layout.
data AttrBranch
AttrBranch :: AttrUsage -> AttrParaSpec -> Map AttrName -> AttrBranch

-- | Usage description
[attrUsage] :: AttrBranch -> AttrUsage

-- | Parameter specification
[attrParaSpec] :: AttrBranch -> AttrParaSpec

-- | Attribute classifier
[attrClassifier] :: AttrBranch -> Map AttrName

-- | Parameter specification for attribute name.
type AttrParaSpec = ParaSpec AttrName

-- | Usage text of attribute layout.
type AttrUsage = String

-- | List of attribute usages.
attrUsages :: AttrLayout -> [AttrUsage]

-- | Concatenated attribute usage.
attrUsageString :: AttrLayout -> String

-- | Attribute parameter.
type AttrPara = Para AttrName Tree

-- | Parameterizer for attribute of relmap operator.
type AttrParaze = [Tree] -> Ab AttrPara

-- | Parameterize named attributes.
attrPara :: AttrParaze

-- | Parameterize attributes by its layout.
attrParaBy :: AttrLayout -> AttrParaze

-- | Take out hyphened text (like <tt>"-x"</tt>) from token tree.
maybeSingleHyphen :: Tree -> Maybe String

-- | Take out double-hyphened text (like <tt>"--xyz"</tt>) from token tree.
maybeDoubleHyphen :: Tree -> Maybe String

-- | Convertible to attribute layout.
--   
--   <ul>
--   <li><b><tt>-</tt>Word</b> — Normal attribute</li>
--   <li><b><tt>-</tt>Word<tt>/</tt></b> — Relmap attribute</li>
--   <li><b><tt>-</tt>Word<tt>/^</tt></b> — Local relmap attribute</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; toAttrLayout "-a"
--   AttrLayout [(Nothing, AttrBranch (
--     ParaSpec { paraSpecPos = ParaItem 1 [AttrNormal "a"]
--              , paraSpecReqP = [AttrNormal "a"]
--              , paraSpecOptP = [], paraSpecReqN = []
--              , paraSpecOptN = [AttrNormal "@trunk"]
--              , paraSpecFirst = [], paraSpecLast = [], paraSpecMulti = [] }
--              ))]
--   </pre>
class ToAttrLayout a
toAttrLayout :: ToAttrLayout a => a -> AttrLayout

-- | Parse relmap attribute layout.

-- | <i>Deprecated: Use <a>toAttrLayout</a> instead.</i>
parseAttrLayout :: String -> AttrLayout
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrLayout
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrBranch
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout Koshucode.Baala.Syntax.Attr.Attr.AttrLayout
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout GHC.Base.String
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout [GHC.Base.String]
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout [(Koshucode.Baala.Syntax.Attr.Attr.AttrUsage, GHC.Base.String)]


-- | Syntax for attributes.
module Koshucode.Baala.Syntax.Attr


-- | Bundle of syntax modules.
module Koshucode.Baala.Syntax
