-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Syntax for Koshucode
--   
--   Syntax for Koshucode
@package koshucode-baala-syntax
@version 0.210.0.0


-- | Term types and related functions.
module Koshucode.Baala.Syntax.Symbol.Term

-- | Judgement material.
type RawJudge c = (JudgeClass, [Term c])

-- | Term with judgement class.
type JudgeTerm c = (JudgeClass, Term c)

-- | Name of judgement class, in other words, name of propositional
--   function.
type JudgeClass = String

-- | Term type: pair of term name and content.
type Term c = (TermName, c)

-- | Create term.
--   
--   <pre>
--   &gt;&gt;&gt; term "size" 10 :: Term Int
--   (TermName EQ "size", 10)
--   </pre>
term :: (ToTermName n) => n -> c -> Term c

-- | Name of term, e.g., <tt>"size"</tt> for the term name <tt>/size</tt>.
data TermName

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]

-- | Convert to term name.
--   
--   <pre>
--   &gt;&gt;&gt; toTermName "/a"
--   TermName EQ "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toTermName "+/a"
--   TermName GT "a"
--   </pre>
class (Ord a) => ToTermName a
toTermName :: ToTermName a => a -> TermName

-- | <tt>Textual</tt> and <a>ToTermName</a> values.
class (Textual t, ToTermName t) => TextualTermName t

-- | Add necessary slash character indicating term name.
--   
--   <pre>
--   &gt;&gt;&gt; enslash &lt;$&gt; ["foo", "/bar", "+/baz", "-/qux"]
--   ["/foo", "/bar", "+/baz", "-/qux"]
--   </pre>
enslash :: (Textual t) => Map t

-- | Decode term name from string.

-- | <i>Deprecated: Use <a>toTermName</a> instead.</i>
textualTermName :: (Textual t) => t -> TermName

-- | Convert string to multiple term names.
--   
--   <pre>
--   &gt;&gt;&gt; stringTermNames "/a /b /c"
--   [TermName EQ "a", TermName EQ "b", TermName EQ "c"]
--   </pre>
stringTermNames :: String -> [TermName]

-- | Encode term name into string.
--   
--   <pre>
--   &gt;&gt;&gt; termNameString $ toTermName "/size"
--   "/size"
--   </pre>
termNameString :: TermName -> String

-- | Encode term path into string.
--   
--   <pre>
--   &gt;&gt;&gt; termPathString [toTermName "r", toTermName "x"]
--   "/r/x"
--   </pre>
termPathString :: TermPath -> String

-- | Extract internal name.
--   
--   <pre>
--   &gt;&gt;&gt; termNameContent $ toTermName "/size"
--   "size"
--   </pre>
termNameContent :: TermName -> String

-- | Sign of term name.
termNameSign :: TermName -> Ordering

-- | Alter sign of term name.
termNameAltSign :: Ordering -> Map TermName

-- | Convert to ordering pair.
orderingTermName :: TermName -> (Ordering, TermName)

-- | Tuple of 2 term names.
type TermName2 = (TermName, TermName)

-- | Tuple of 3 term names.
type TermName3 = (TermName, TermName, TermName)

-- | Tuple of 4 term names.
type TermName4 = (TermName, TermName, TermName, TermName)

-- | Tuple of 5 term names.
type TermName5 = (TermName, TermName, TermName, TermName, TermName)

-- | Tuple of 6 term names.
type TermName6 = (TermName, TermName, TermName, TermName, TermName, TermName)

-- | Term index.
type TermIndex = Int

-- | Term name and index.
type IndexTerm = (TermName, TermIndex)

-- | Test present term.
--   
--   <pre>
--   &gt;&gt;&gt; termP 2
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termP 0
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termP (-1)
--   False
--   </pre>
termP :: Test TermIndex

-- | Test new term.
termN :: Test TermIndex

-- | Test all terms are present.
termsP :: Test [TermIndex]

-- | Test all terms are new.
--   
--   <pre>
--   &gt;&gt;&gt; termsN [-1, -1]
--   True
--   </pre>
termsN :: Test [TermIndex]

-- | Test present and new terms.
--   
--   <pre>
--   &gt;&gt;&gt; termsPN [1,2] [-1]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termsPN [1,2] [-1,0]
--   False
--   </pre>
termsPN :: Test2 [TermIndex] [TermIndex]
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Term.TermName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Term.TermName
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Data.String.IsString Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Koshucode.Baala.Syntax.Symbol.Term.TermName
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName GHC.Base.String
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Koshucode.Baala.Overture.Shorthand.Tx
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName Koshucode.Baala.Overture.Shorthand.Tz
instance Koshucode.Baala.Syntax.Symbol.Term.ToTermName GHC.Types.Int
instance Koshucode.Baala.Syntax.Symbol.Term.TextualTermName GHC.Base.String
instance Koshucode.Baala.Syntax.Symbol.Term.TextualTermName Koshucode.Baala.Overture.Shorthand.Tx
instance Koshucode.Baala.Syntax.Symbol.Term.TextualTermName Koshucode.Baala.Overture.Shorthand.Tz


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Syntax.Symbol.AngleText

-- | Convert string into double-quoted and angle-quoted form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "\t"
--   &lt;tab&gt;
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ angleQuote "aaa\nbbb\r\nccc\r\n\r\nddd"
--   "aaa" &lt;lf&gt; "bbb" &lt;crlf&gt; "ccc" &lt;crlf&gt; &lt;crlf&gt; "ddd"
--   </pre>
angleQuote :: (Textual t) => t -> t

-- | Table of coresspondences of angle text and its replacement.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" angleTexts
--   Just "\n"
--   </pre>
angleTexts :: (Textual t) => [(t, t)]


-- | Parameter type.
module Koshucode.Baala.Syntax.Para.Para

-- | Named and positional parameter.
data Para n a
Para :: [ParaTag] -> [a] -> [a] -> ParaMap n a -> Para n a

-- | Parameter tags.
[paraTags] :: Para n a -> [ParaTag]

-- | All parameter elements.
[paraAll] :: Para n a -> [a]

-- | Positional parameters.
[paraPos] :: Para n a -> [a]

-- | Named parameters.
[paraName] :: Para n a -> ParaMap n a

-- | Parameter tag.
type ParaTag = String

-- | Mapping parameter name to its contents.
type ParaMap n a = Map n [[a]]

-- | Test and take parameter name.
type ParaName n a = a -> Maybe n

-- | Parse list into parameter.
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b"
--   Para { paraAll = ["a","b"], paraPos = ["a","b"], paraName = fromList [] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; para paraHyphen $ words "a b -x c d"
--   Para { paraAll = ["a","b","-x","c"]
--        , paraPos = ["a","b"]
--        , paraName = fromList [("x",[["c","d"]])] }
--   </pre>
para :: (Ord n) => ParaName n a -> [a] -> Para n a

-- | Association list of named parameters.
paraNameList :: Para n a -> [(n, [[a]])]

-- | List of parameter names.
paraNames :: Para n a -> [n]

-- | List of names which appear more than once.
paraMultipleNames :: Para n a -> [n]

-- | Lookup named parameter.
paraLookup :: (Ord n) => n -> Para n a -> Maybe [[a]]

-- | Lookup single-occurence parameter.
paraLookupSingle :: (Ord n) => n -> Para n a -> Maybe [a]

-- | Give names to positional parameters.
paraPosName :: (Ord n, Monad m) => ([a] -> m [(n, [a])]) -> Para n a -> m (Para n a)

-- | Add named parameter.
paraNameAdd :: (Ord n) => n -> [a] -> Map (Para n a)

-- | Map names of named parameters.
paraNameMapKeys :: (Ord n2) => (n1 -> n2) -> Para n1 a -> Para n2 a

-- | Take first element from multiply given named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = para paraHyphen $ words "a -x 1 -x 2 -x 3"
--   
--   &gt;&gt;&gt; p
--   Para { ..., paraName = fromList [("x", [["1"],["2"],["3"]])] }
--   
--   &gt;&gt;&gt; paraTakeFirst "x" p
--   Para { ..., paraName = fromList [("x", [["1"]])] }
--   </pre>
paraTakeFirst :: (Ord n) => n -> Para n a -> Para n a

-- | Take last element from multiply given named parameter.
paraTakeLast :: (Ord n) => n -> Para n a -> Para n a

-- | String-named parameter.
type SimplePara a = Para String a

-- | Composition of word separation and parameter parsing.
paraWords :: (Ord n) => ParaName n String -> String -> Para n String

-- | Parameter name is beginning with hyphen.
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "-foo"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; paraHyphen "bar"
--   Nothing
--   </pre>
paraHyphen :: ParaName String String
instance (GHC.Classes.Ord n, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Classes.Eq n, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance (GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.Para.Para n a)
instance GHC.Classes.Ord n => GHC.Base.Monoid (Koshucode.Baala.Syntax.Para.Para.Para n a)


-- | Parameter specification.
module Koshucode.Baala.Syntax.Para.ParaSpec

-- | Parameter specification.
data ParaSpec n
ParaSpec :: ParaSpecPos n -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> ParaSpec n

-- | <b>Positional:</b> Positional parameter
[paraSpecPos] :: ParaSpec n -> ParaSpecPos n

-- | <b>Positional:</b> Positional required parameters
[paraSpecReqP] :: ParaSpec n -> [n]

-- | <b>Positional:</b> Positional optional parameters
[paraSpecOptP] :: ParaSpec n -> [n]

-- | <b>Named:</b> Explicitly-named required parameters
[paraSpecReqN] :: ParaSpec n -> [n]

-- | <b>Named:</b> Explicitly-named optional parameters
[paraSpecOptN] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use first parameters
[paraSpecFirst] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use last parameters
[paraSpecLast] :: ParaSpec n -> [n]

-- | <b>Named:</b> Allow multiple-occurence, use all parameters
[paraSpecMulti] :: ParaSpec n -> [n]

-- | Name list of all parameters.
paraSpecNames :: ParaSpec n -> [n]

-- | Name list of positional parameters.
paraSpecNamesP :: ParaSpec n -> [n]

-- | Name list of explicitly-named parameters.
paraSpecNamesN :: ParaSpec n -> [n]

-- | Positional parameter specification.
data ParaSpecPos n

-- | Named positional parameters
ParaItem :: Int -> [n] -> ParaSpecPos n

-- | Named positional and optional parameters
ParaItemOpt :: Int -> [n] -> [n] -> ParaSpecPos n

-- | Named positional and rest parameters
ParaItemRest :: Int -> [n] -> n -> ParaSpecPos n

-- | Lower bound of parameter length
ParaMin :: Int -> ParaSpecPos n

-- | Lower and upper bound of parameter length
ParaRange :: Int -> Int -> ParaSpecPos n

-- | Minimal length of positional parameters.
paraMinLength :: ParaSpecPos n -> Int

-- | Unmatch reason of real parameter and its specifition.
data ParaUnmatch n

-- | Positional parameter is unmatched.
ParaPos :: Int -> (ParaSpecPos n) -> ParaUnmatch n

-- | Unknown parameter is specified.
ParaUnknown :: [n] -> ParaUnmatch n

-- | Required parameter is missing.
ParaMissing :: [n] -> ParaUnmatch n

-- | Parameter occurs more than once.
ParaMultiple :: [n] -> ParaUnmatch n

-- | Either something or parameter.
type ParaOr left n a = Either left (Para n a)

-- | Test and revise parameter to satisfy specification.
paraMatch :: (Eq n, Ord n) => ParaSpec n -> Para n a -> ParaOr (ParaUnmatch n) n a

-- | Select matched specification and apply parameter value function.
paraSelect :: (Eq n, Ord n) => b -> [(ParaSpec n, Para n a -> b)] -> Para n a -> b

-- | Collect parameter tags.
paraChoose :: (Ord n) => [(Maybe ParaTag, ParaSpec n)] -> Para n a -> ParaOr [ParaUnmatch n] n a

-- | Mapping of parameter specification.
type ParaSpecMap n = Map (ParaSpec n)

-- | Create parameter specification.
paraSpec :: (Show n, Ord n) => ParaSpecMap n -> ParaSpec n

-- | Lower bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMin 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaPos ...
--   </pre>
paraMin :: Int -> ParaSpecMap n

-- | Upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraMax 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Left ParaPos ...
--   </pre>
paraMax :: Int -> ParaSpecMap n

-- | Fixed-length positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraJust 1
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen ""
--   Left ParaPos ...
--   </pre>
paraJust :: Int -> ParaSpecMap n

-- | Lower and upper bound of length of positional parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraRange 1 2
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a"
--   Right Para ...
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Left ParaPos ...
--   </pre>
paraRange :: Int -> Int -> ParaSpecMap n

-- | No positional parameter.
para0 :: ParaSpecMap n

-- | Named one positional parameter.
para1 :: n -> ParaSpecMap n

-- | Named two positional parameters.
para2 :: n -> n -> ParaSpecMap n

-- | Named three positional parameters.
para3 :: n -> n -> n -> ParaSpecMap n

-- | Named arbitrary positional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItem ["x", "y", "z", "w"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]), ..., ("w",[["d"]])] })
--   </pre>
paraItem :: [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemOpt ["x", "y"] ["z"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]])] })
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c"]])] })
--   </pre>
paraItemOpt :: [n] -> [n] -> ParaSpecMap n

-- | Named arbitrary and one optional parameters.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraItemRest ["x", "y"] "z"
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "a b c d"
--   Right (Para { ..., paraName = fromList [("x",[["a"]]),("y",[["b"]]),("z",[["c","d"]])] })
--   </pre>
paraItemRest :: [n] -> n -> ParaSpecMap n

-- | Required named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Left (ParaUnknown ["y"])
--   </pre>
paraReq :: [n] -> ParaSpecMap n

-- | Optional named parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let p = S.paraWords S.paraHyphen "-x a -y b"
--   
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraOpt ["y"]
--   
--   &gt;&gt;&gt; paraMatch s p
--   Right (Para { ..., paraName = fromList [("x", [["a"]]), ("y", [["b"]])] })
--   </pre>
paraOpt :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use first parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraFirst ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"]])] })
--   </pre>
paraFirst :: [n] -> ParaSpecMap n

-- | Allow multiple-occurence and use last parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraLast ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["b","c"]])] })
--   </pre>
paraLast :: [n] -> ParaSpecMap n

-- | Multiple-occurence parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let s = paraSpec $ paraReq ["x"] . paraMulti ["x"]
--   
--   &gt;&gt;&gt; paraMatch s $ S.paraWords S.paraHyphen "-x a -x b c"
--   Right (Para { ..., paraName = fromList [("x", [["a"],["b","c"]])] })
--   </pre>
paraMulti :: [n] -> ParaSpecMap n
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos n)
instance Data.Default.Class.Default (Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec n)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpec
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaSpecPos
instance GHC.Base.Functor Koshucode.Baala.Syntax.Para.ParaSpec.ParaUnmatch


-- | Parse parameter specification.
module Koshucode.Baala.Syntax.Para.Parse

-- | Parse parameter layout. This function divides a given string by
--   vertical bar <tt>"|"</tt>, then parse each layouts.
parseParaSpec :: String -> [(Maybe ParaTag, ParaSpec String)]

-- | Parse list of single layout.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaList [ "a : -a", "ab : -a -b" ]
--   [ (Just "a", ParaSpec { paraSpecPos = ParaItem 1 ["-a"]
--                         , paraSpecReqP = ["-a"], ... })
--   , (Just "ab", ParaSpec { paraSpecPos = ParaItem 2 ["-a","-b"]
--                          , paraSpecReqP = ["-a","-b"], ... }) ]
--   </pre>
parseParaList :: [String] -> [(Maybe ParaTag, ParaSpec String)]

-- | Parse single layout.
--   
--   <pre>
--   &gt;&gt;&gt; parseParaSingle "ab : -a -b"
--   (Just "ab", ParaSpec { paraSpecPos = ParaItem 2 ["-a","-b"]
--                        , paraSpecReqP = ["-a","-b"], ...} )
--   </pre>
parseParaSingle :: String -> (Maybe ParaTag, ParaSpec String)

-- | Report bug of parameter specification.
paraBug :: String -> String -> a
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Para.Parse.Ror
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Para.Parse.Ror
instance GHC.Show.Show Koshucode.Baala.Syntax.Para.Parse.Ror


-- | Getters for parameter.
module Koshucode.Baala.Syntax.Para.Get

-- | Named parageter.
paraGet :: (Ord n) => Para n a -> n -> Ab [a]

-- | Named parameter with default content.
paraGetOpt :: (Ord n) => [a] -> Para n a -> n -> Ab [a]

-- | Multiple-occurence parameter.
paraGetList :: (Ord n) => Para n a -> n -> Ab [[a]]

-- | S.Parameter as switch, just given or not.
paraGetSwitch :: (Ord n) => Para n a -> n -> Ab Bool

-- | Whole positional parameter list.
paraGetPos :: Para n a -> Ab [a]

-- | First positional parameter.
paraGetFst :: Para n a -> Ab a

-- | Second positional parameter.
paraGetSnd :: Para n a -> Ab a

-- | Third positional parameter.
paraGetTrd :: Para n a -> Ab a

-- | Positional parameter list but first element.
paraGetRest :: Para n a -> Ab [a]

-- | Positional parameter list but first and second element.
paraGetRRest :: Para n a -> Ab [a]


-- | Message list.
module Koshucode.Baala.Syntax.Token.Message

-- | Abortable scope for token.
abToken :: (GetCodePos cp) => Abortable cp b

-- | Forbidden input
forbiddenInput :: (Textual t) => t -> Ab a

-- | Unexpedted section delimiter
unexpSect :: [String] -> Ab a

-- | Unknown bracket text
unkAngleText :: String -> Ab a


-- | Message list.
module Koshucode.Baala.Syntax.Symbol.Message

-- | <ul>
--   <li><i>Expect plain symbol</i></li>
--   </ul>
expPlainSym :: Ab a

-- | <ul>
--   <li><i>Quotation not end in line</i></li>
--   </ul>
quotNotEnd :: Ab a


-- | Next character sequence.
module Koshucode.Baala.Syntax.Symbol.Next

-- | Split next character sequence from input text.
type Next t a = t -> (t, a)

-- | Split next character sequence from input text.
type AbNext t a = t -> Ab (t, a)

-- | Get next spaces. Space character is decided by <a>isSpace</a>.
--   
--   <pre>
--   &gt;&gt;&gt; nextSpace " abc"
--   ("abc", 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSpace " \tabc"
--   ("abc", 2)
--   </pre>
nextSpace :: (Textual t) => Next t Int

-- | Get next double quoted text. A single double quote ends text. A double
--   double quote does not end text, but it is converted to double quote.
--   
--   <pre>
--   &gt;&gt;&gt; nextQQ "abc\" def"
--   Right (" def","abc")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextQQ "abc\"\"def\" ghi"
--   Right (" ghi","abc\"def")
--   </pre>
nextQQ :: (Textual t) => AbNext t t

-- | Get next text before given delimiter.
--   
--   <pre>
--   &gt;&gt;&gt; nextBefore "''" "abc'' def"
--   Right (" def","abc")
--   </pre>
nextBefore :: (Textual t) => t -> AbNext t t


-- | Symbol type.
module Koshucode.Baala.Syntax.Symbol.Symbol

-- | Symbol class.
--   
--   Relation between character classes and symbol classes. The char class
--   <tt>number'</tt> means Unicode number except for <tt>0-9</tt>.
--   <tt>G</tt> for general symbol, <tt>P</tt> for plain, <tt>N</tt> for
--   numeric.
--   
--   <pre>
--   Char class   Symbol class        Symbol type
--   ------------ ------------------- -----------------
--   "0-9"        ( G ) ( P ) ( N )   SymbolCommon
--   "-"          ( G ) ( P ) ( N )   SymbolCommon
--   letter       ( G )   P           SymbolPlain
--   mark         ( G )   P           SymbolPlain
--   number'      ( G )   P           SymbolPlain
--   "_!?"        ( G )   P           SymbolPlain
--   "+"          ( G )         N     SymbolNumeric
--   "*=&lt;&gt;~"        G                 SymbolGeneral
--   ".#"                       N     SymbolNumeric
--   </pre>
--   
--   Partial order between the symbol classes.
--   
--   <pre>
--                     ( GPN ) Common
--                    /      |
--           Plain ( GP )  ( GN ) Numeric
--                /  |    /  |
--   Short ( P.P )   |   /   |
--            :      |  /    |
--         General ( G )     |
--            :      :     ( N ) Numeric
--            :      :       :
--            ................ Unknown
--   </pre>
data Symbol t

-- | <b>1.</b> General-plain-numeric symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "1"
--   ("", SymbolCommon "1")
--   </pre>
SymbolCommon :: t -> Symbol t

-- | <b>2.</b> Plain (include general) symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "a"
--   ("", SymbolPlain "a")
--   </pre>
SymbolPlain :: t -> Symbol t

-- | <b>3.</b> Numeric (include general) symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "+"
--   ("", SymbolNumeric "+")
--   </pre>
SymbolNumeric :: t -> Symbol t

-- | <b>4.</b> General (not plain nor numeric) symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "="
--   ("", SymbolGeneral "=")
--   </pre>
SymbolGeneral :: t -> Symbol t

-- | <b>5.</b> Short symbol (Plain <tt>"."</tt> Plain)
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "a.xxx"
--   ("", SymbolShort "a" "xxx")
--   </pre>
SymbolShort :: t -> t -> Symbol t

-- | <b>6.</b> Unknown symbol
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "a+"
--   ("", SymbolUnknown "a+")
--   </pre>
SymbolUnknown :: t -> Symbol t

-- | Test symbol is general, in other words, <a>SymbolCommon</a>,
--   <a>SymbolPlain</a> or <a>SymbolGeneral</a>.
isGeneralSymbol :: Test (Symbol t)

-- | Test symbol is plain, in other words, <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
isPlainSymbol :: Test (Symbol t)

-- | Test symbol is numeric, in other words, <a>SymbolCommon</a> or
--   <a>SymbolNumeric</a>.
isNumericSymbol :: Test (Symbol t)

-- | Test symbol is <a>SymbolShort</a>.
isShortSymbol :: Test (Symbol t)

-- | Test character is a symbol component.
isSymbolChar :: Test Char

-- | Test character is a general-symbol component.
isGeneralChar :: Test Char

-- | Test character is a plain-symbol component.
isPlainChar :: Test Char

-- | Test character is a numeric-symbol component.
isNumericChar :: Test Char

-- | Get next symbol.
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "foo bar"
--   (" bar", SymbolPlain "foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "0.50"
--   ("", SymbolNumeric "0.50")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbol "= /a"
--   (" /a", SymbolGeneral "=")
--   </pre>
nextSymbol :: (Textual t) => Next t (Symbol t)

-- | Get next plain symbol, i.e., <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbolPlain "foo bar"
--   Right (" bar","foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nextSymbolPlain "12.0"
--   Left (AbortReason "Expect ordinary symbol" ...)
--   </pre>
nextSymbolPlain :: (Textual t) => AbNext t t
instance GHC.Classes.Ord t => GHC.Classes.Ord (Koshucode.Baala.Syntax.Symbol.Symbol.Symbol t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Koshucode.Baala.Syntax.Symbol.Symbol.Symbol t)
instance GHC.Show.Show t => GHC.Show.Show (Koshucode.Baala.Syntax.Symbol.Symbol.Symbol t)


-- | Short sign.
module Koshucode.Baala.Syntax.Symbol.Short

-- | Something with short definition.
data Short t a
Short :: [TCodePos t] -> [ShortDef t] -> a -> Short t a

-- | Source information
[shortSource] :: Short t a -> [TCodePos t]

-- | Definition of short signs
[shortHead] :: Short t a -> [ShortDef t]

-- | Body with short signs
[shortBody] :: Short t a -> a

-- | Short prefix and replacement.
type ShortDef t = (t, t)

-- | Omit empty body.
shortTrim :: Map [Short t [a]]

-- | Evaluate body of short structures.
shortListM :: (Monad m) => [Short t (m a)] -> m [Short t a]

-- | Group short structures.
shortGroup :: (Eq t) => [Short t a] -> [Short t [a]]

-- | String shortener.
shortText :: [ShortDef String] -> TransText String
instance (GHC.Classes.Eq t, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Syntax.Symbol.Short.Short t a)
instance (GHC.Classes.Ord a, Koshucode.Baala.Overture.Text.Textual.Textual t) => GHC.Classes.Ord (Koshucode.Baala.Syntax.Symbol.Short.Short t a)
instance (GHC.Show.Show a, Koshucode.Baala.Overture.Text.Textual.Textual t) => GHC.Show.Show (Koshucode.Baala.Syntax.Symbol.Short.Short t a)
instance GHC.Base.Functor (Koshucode.Baala.Syntax.Symbol.Short.Short t)


-- | Symbols
module Koshucode.Baala.Syntax.Symbol


-- | Subtree.
module Koshucode.Baala.Syntax.Subtree.Subtree

-- | Subtree pattern.
data SubtreePattern

-- | Leaf
SubtreeL :: SubtreeTerm -> (Sivmap String) -> SubtreePattern

-- | Branch
SubtreeB :: SubtreeTerm -> (Sivmap String) -> [SubtreePattern] -> SubtreePattern

-- | Recursive branch
SubtreeR :: (Sivmap String) -> [SubtreePattern] -> SubtreePattern

-- | Create non-termification leaf pattern.
--   
--   <pre>
--   &gt;&gt;&gt; subtreeL $ S.sivmapEq "foo"
--   SubtreeL SubtreeNone (SivmapEq "foo")
--   </pre>
subtreeL :: Sivmap String -> SubtreePattern

-- | Create non-termification branch pattern.
subtreeB :: Sivmap String -> [SubtreePattern] -> SubtreePattern

-- | Termification of subtree content.
data SubtreeTerm
SubtreeNone :: SubtreeTerm
SubtreeText :: [JudgeClass] -> TermName -> SubtreeTerm
SubtreeSeq :: [JudgeClass] -> TermName -> SubtreeTerm

-- | Create text term.
--   
--   <pre>
--   &gt;&gt;&gt; subtreeText "A" "/x"
--   SubtreeText ["A"] (TermName EQ "x")
--   </pre>
subtreeText :: (ToTermName n) => JudgeClass -> n -> SubtreeTerm

-- | Create text term with multiple classes.
subtreeTexts :: (ToTermName n) => [JudgeClass] -> n -> SubtreeTerm

-- | Subtree.
type Subtree a = RawTree [SubtreePattern] a a

-- | Subtree with termified elements.
type SubtreeOutput a = RawTree [SubtreePattern] (SubtreeTerm, a) (SubtreeTerm, a)

-- | Subtree with value.
type SubtreeValue = SubtreeOutput Value

-- | Test string matches selection rule.
--   
--   <pre>
--   &gt;&gt;&gt; subtreeStringTest (S.sivmapEq "foo") &lt;$&gt; ["foo", "foobar", "barfoo"]
--   [True,False,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; subtreeStringTest (S.sivmapKeep "foo(*)") &lt;$&gt; ["foo", "foobar", "barfoo"]
--   [True,True,False]
--   </pre>
subtreeStringTest :: Sivmap String -> String -> Bool

-- | Select subtree.
--   
--   <pre>
--   &gt;&gt;&gt; let tree = B.TreeB [] "Y1" [B.TreeL "Z1", B.TreeL "Z2", B.TreeB [] "Y2" [B.TreeL "Z3"]]
--   
--   &gt;&gt;&gt; B.printTree tree
--   &gt; [] "Y1"
--     - "Z1"
--     - "Z2"
--     &gt; [] "Y2"
--       - "Z3"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.printTrees $ subtree [subtreeB (S.sivmapEq "Y1") [subtreeL (S.sivmapEq "Z1")]] [tree]
--   &gt; [] (SubtreeNone,"Y1")
--     - (SubtreeNone,"Z1")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.printTrees $ subtree [SubtreeR (S.sivmapId) [subtreeL (S.sivmapEq "Z3")]] [tree]
--   &gt; [] (SubtreeNone,"Y1")
--     &gt; [] (SubtreeNone,"Y2")
--       - (SubtreeNone,"Z3")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.printTrees $ subtree [SubtreeR (S.sivmapId) [subtreeL (S.sivmapEq "Z1")]] [tree]
--   &gt; [] (SubtreeNone,"Y1")
--     - (SubtreeNone,"Z1")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.printTrees $ subtree [SubtreeB (subtreeText "A" "/y") (S.sivmapId) [SubtreeL (subtreeText "A" "/z") (S.sivmapEq "Z1")]] [tree]
--   &gt; [] (SubtreeText ["A"] (TermName EQ "y"),"Y1")
--     - (SubtreeText ["A"] (TermName EQ "z"),"Z1")
--   </pre>
subtree :: [SubtreePattern] -> [Subtree String] -> [SubtreeOutput String]

-- | Select subtree by element tester.
subtreeBy :: (Sivmap String -> a -> Bool) -> [SubtreePattern] -> [Subtree a] -> [SubtreeOutput a]

-- | Select subtree.
subtreeOne :: [SubtreePattern] -> Map [Subtree String]

-- | Extract data from subtree.
subtreeData :: SubtreeValue -> [RawJudge Value]
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Subtree.Subtree.SubtreePattern
instance GHC.Show.Show Koshucode.Baala.Syntax.Subtree.Subtree.SubtreePattern
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Subtree.Subtree.SubtreeTerm
instance GHC.Show.Show Koshucode.Baala.Syntax.Subtree.Subtree.SubtreeTerm


-- | Directory tree.
module Koshucode.Baala.Syntax.Subtree.DirTree

-- | Create selective directory trees.
--   
--   <pre>
--   &gt;&gt;&gt; import Koshucode.Baala.Syntax.Subtree.Filter as S
--   
--   &gt;&gt;&gt; B.printTrees O.# dirTrees [] "." [S.SubtreeR (S.sivmapId O.++ S.sivmapOmit "dist") [S.subtreeL $ S.sivmapKeep "S(*)"]]
--   &gt; [] "data"
--     - "SLOC.k"
--   &gt; [] "Koshucode"
--     &gt; [] "Baala"
--       &gt; [] "Syntax"
--         &gt; [] "Attr"
--           - "Slot.hs"
--         &gt; [] "Subtree"
--           - "Subtree.hs"
--         - "Subtree.hs"
--         &gt; [] "Symbol"
--           - "Short.hs"
--           - "Symbol.hs"
--         - "Symbol.hs"
--         &gt; [] "Token"
--           - "Section.hs"
--         &gt; [] "Tree"
--           - "Split.hs"
--       - "Syntax.hs"
--   </pre>
dirTrees :: [FilePath] -> FilePath -> [SubtreePattern] -> IO [Subtree FilePath]

-- | Same as <a>withCurrentDirectory</a>.
withCurrentDirectory :: FilePath -> IO a -> IO a

-- | Same as <a>listDirectory</a>.
listDirectory :: FilePath -> IO [FilePath]


-- | XML tree.
module Koshucode.Baala.Syntax.Subtree.Xml

-- | XML token.
data XmlToken s

-- | Open tag and attributes
XmlOpen :: s -> [(s, s)] -> XmlToken s

-- | Close tag
XmlClose :: s -> XmlToken s

-- | Terminal token
XmlTerm :: (XmlTerm s) -> XmlToken s

-- | Terminal of XML tree.
type XmlTerm s = (XmlKey s, s)

-- | Key data of XML tree.
data XmlKey s

-- | Element node
XmlElem :: s -> [(s, s)] -> XmlKey s

-- | Attribute of element
XmlAttr :: s -> XmlKey s

-- | Text node
XmlText :: XmlKey s

-- | Comment node
XmlComment :: XmlKey s

-- | Tokenize XML document.
--   
--   <pre>
--   &gt;&gt;&gt; xmlTokens "&lt;hello&gt;wonderful&lt;/world&gt;"
--   [XmlOpen "hello", XmlTerm (XmlText, "wonderful"), XmlClose "hello"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; xmlTokens "&lt;a x='xx' y='yy'&gt;"
--   [XmlOpen "a", XmlTerm (XmlAttr "x", "xx"), XmlTerm (XmlAttr "y", "yy"), XmlClose "a"]
--   </pre>
xmlTokens :: (StringLike s) => s -> [XmlToken s]

-- | XML tree.
type XmlTree s = Subtree (XmlTerm s)

-- | Convert XML tokens to XML tree.
xmlTrees :: (Ord s, StringLike s) => [XmlToken s] -> Ab [XmlTree s]

-- | Decode XML trees.
--   
--   <pre>
--   &gt;&gt;&gt; B.printTrees O.# B.abortLeft (xmlDecode "&lt;hello&gt;wonderful&lt;/world&gt;")
--   &gt; () (XmlElem "hello","hello")
--     - (XmlText,"wonderful")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.printTrees O.# B.abortLeft (xmlDecode "&lt;a x='xx' y='yy'&gt;")
--   &gt; () (XmlElem "a","a")
--     - (XmlAttr "x","xx")
--     - (XmlAttr "y","yy")
--   </pre>
xmlDecode :: (Ord s, StringLike s) => s -> Ab [XmlTree s]

-- | XML output tree.
type XmlOutput s = SubtreeOutput (XmlTerm s)

-- | Calculate subtree of XML tree.
xmlOutput :: [SubtreePattern] -> [XmlTree String] -> [XmlOutput String]

-- | Extract data from XML output tree.
xmlData :: XmlOutput String -> [RawJudge Value]

-- | Calculate XML subtree and extract data.
xmlSubtreeData :: [SubtreePattern] -> [XmlTree String] -> [RawJudge Value]
instance GHC.Classes.Ord s => GHC.Classes.Ord (Koshucode.Baala.Syntax.Subtree.Xml.XmlToken s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Koshucode.Baala.Syntax.Subtree.Xml.XmlToken s)
instance GHC.Show.Show s => GHC.Show.Show (Koshucode.Baala.Syntax.Subtree.Xml.XmlToken s)
instance GHC.Classes.Ord s => GHC.Classes.Ord (Koshucode.Baala.Syntax.Subtree.Xml.XmlKey s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Koshucode.Baala.Syntax.Subtree.Xml.XmlKey s)
instance GHC.Show.Show s => GHC.Show.Show (Koshucode.Baala.Syntax.Subtree.Xml.XmlKey s)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Syntax.Subtree.Xml.XmlToken s)


-- | Tokens in Koshucode.
module Koshucode.Baala.Syntax.Token.Token

-- | Type wihch has subtype and its name.
class SubtypeName a
subtypeName :: SubtypeName a => a -> String

-- | Character sequence.
type Chars = String

-- | Mapping from chars to chars.
type CharsMap = Map Chars

-- | Convert textual value to character sequence.
tChars :: (Textual t) => t -> Chars

-- | Convert character sequence to textual value.
csT :: (Textual t) => Chars -> t

-- | Convert string to character sequence.
stringChars :: String -> Chars

-- | String token.
type Token = TToken Chars

-- | Textual token.
data TToken t

-- | <b>1 Textual:</b> Text — <tt>'code</tt>, <tt>"text"</tt>, etc
TText :: (TCodePos t) -> TextForm -> t -> TToken t

-- | <b>2 Textual:</b> Prefixed shorten text — <tt>short.proper</tt>
TShort :: (TCodePos t) -> t -> t -> TToken t

-- | <b>3 Textual:</b> Term name — <tt>/term</tt>
TTerm :: (TCodePos t) -> t -> TToken t

-- | <b>4 Symbolic:</b> Local name — <tt>^r</tt>, <tt>^/r</tt>
TLocal :: (TCodePos t) -> LocalRef -> Int -> [TToken t] -> TToken t

-- | <b>5 Symbolic:</b> Slot name. <a>Int</a> represents slot level, i.e.,
--   0 for local positional slots, 1 for local named slots, 2 for global
--   slots — <tt>@slot</tt>, <tt>@@global</tt>
TSlot :: (TCodePos t) -> Int -> t -> TToken t

-- | <b>6 Symbolic:</b> Blank name. (This is only used in building content
--   expression)
TName :: (TCodePos t) -> BlankName -> TToken t

-- | <b>7 Punctuational:</b> Opening bracket — <tt>(</tt>, <tt>{</tt>,
--   <tt>{=</tt>, etc
TOpen :: (TCodePos t) -> t -> TToken t

-- | <b>8 Punctuational:</b> Closing bracket — <tt>=}</tt>, <tt>}</tt>,
--   <tt>)</tt>, etc
TClose :: (TCodePos t) -> t -> TToken t

-- | <b>9 Punctuational:</b> <i>N</i> space characters
TSpace :: (TCodePos t) -> Int -> TToken t

-- | <b>10 Punctuational:</b> Comment — <tt>** comment line</tt>
TComment :: (TCodePos t) -> t -> TToken t

-- | <b>11 Other:</b> Unknown token
TUnknown :: (TCodePos t) -> t -> AbortReason -> TToken t

-- | Code point of token.
tokenCp :: TToken t -> TCodePos t

-- | Create raw text token.
rawTextToken :: (Textual t) => t -> TToken t

-- | Create unknown token.
unknownToken :: TCodePos t -> t -> Ab a -> TToken t

-- | Subtype of text token.
data TextForm

-- | <b>1.</b> Unknown keyword — <tt>&lt;unknown&gt;</tt>
TextUnk :: TextForm

-- | <b>2.</b> Naked text — <tt>raw</tt>
TextRaw :: TextForm

-- | <b>3.</b> Single-quoted text — <tt>'code</tt>
TextQ :: TextForm

-- | <b>4.</b> Double-quoted text — <tt>"text"</tt>
TextQQ :: TextForm

-- | <b>5.</b> Keyword literal — <tt>&lt;crlf&gt;</tt>
TextKey :: TextForm

-- | <b>6.</b> Quoted term name — <tt>'/term</tt>
TextTerm :: TextForm

-- | <b>7.</b> Text enclosed in bars — <tt>|9:30|</tt>
TextBar :: TextForm

-- | <b>8.</b> Text in license section — <tt>=== license</tt>
TextLicense :: TextForm

-- | Local relation reference.
data LocalRef

-- | Reference to local relation — <tt>^r</tt>
LocalSymbol :: String -> LocalRef

-- | Reference to nested relation — <tt>^/r</tt>
LocalNest :: TermName -> LocalRef

-- | Blank in form.
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName
instance Koshucode.Baala.Overture.Text.Textual.Textual t => GHC.Classes.Ord (Koshucode.Baala.Syntax.Token.Token.TToken t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Koshucode.Baala.Syntax.Token.Token.TToken t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => GHC.Show.Show (Koshucode.Baala.Syntax.Token.Token.TToken t)
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.LocalRef
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Base.Functor Koshucode.Baala.Syntax.Token.Token.TToken
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName (Koshucode.Baala.Syntax.Token.Token.TToken t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Syntax.Token.Token.TToken t)
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.TextForm
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.LocalRef
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.BlankName
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName Koshucode.Baala.Syntax.Token.Token.BlankName


-- | Token pattern.
module Koshucode.Baala.Syntax.Token.Pattern

-- | Text token.

-- | Unknown text.

-- | Raw text.

-- | Section sign: <tt>"==="</tt>

-- | Single-quoted text.

-- | Double-quoted text.

-- | Keyword text.

-- | Bar-enclosed text.

-- | License text.

-- | Term token.


-- | Token utilities.
module Koshucode.Baala.Syntax.Token.Utility

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; tokenContent $ S.TOpen B.def "("
--   "("
--   </pre>
tokenContent :: (Textual t) => TToken t -> String

-- | Get detail type string of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = S.rawTextToken "flower" in (S.subtypeName tok, tokenDetailTypeString tok)
--   ("text", Just "raw")
--   </pre>
tokenDetailTypeString :: TToken t -> Maybe String

-- | Get token parents from local token.
tokenParents :: Token -> [Token]

-- | Prepare token list for parsing.
--   
--   <ol>
--   <li>Remove spaces.</li>
--   <li>Remove comments.</li>
--   <li>Join fragmented texts.</li>
--   </ol>
prepareTokens :: (Textual t) => Map [TToken t]

-- | Remove blank tokens.
sweepToken :: Map [TToken t]

-- | Test token is blank, i.e., comment or space.
isBlankToken :: Test (TToken t)

-- | Test token is short-type token.
isShortToken :: Test (TToken t)

-- | Test token is term-type token.
isTermToken :: Test (TToken t)

-- | Test token is open-type token.
isOpenToken :: Test (TToken t)

-- | Test token is close-type token.
isCloseToken :: Test (TToken t)

-- | Create bracket testers.
isBracketTokenOf :: (Eq t) => (t, t) -> (Test (TToken t), Test (TToken t))

-- | Test token is unknown.
isUnknownToken :: Test (TToken t)


-- | Clip token text.
module Koshucode.Baala.Syntax.Token.Clip

-- | Test character is symbolic.
isSymbol :: Test Char

-- | Test character is space.
isSpace :: Test Char

-- | Test character is double-quote.
isQQ :: Test Char

-- | Test character is term slash.
isTerm :: Test Char

-- | Test character is content line, i.e., <tt>'-'</tt> or <tt>'='</tt>.
isJudge :: Test Char

-- | Test character is component of clock text.
isClock :: Test Char

-- | Code scanner for token list.
type TokenScan t = CodeScan TToken t

-- | Read single token.
type TokenScanMap t = Map (TokenScan t)

-- | Clip single-token result.
type ClipResult t = (t, TToken t)

-- | Clip single-token result with word cache.
type ClipResultC t = (WordCache t, t, TToken t)

-- | Clip multiple-tokens result with word cache.
type ClipResultCL t = (WordCache t, t, [TToken t])

-- | Clip a next token.

-- | <i>Warning: This is only used in defined module.</i>
type ClipToken t = TCodePos t -> t -> ClipResult t

-- | Clip a next token with word cache.

-- | <i>Warning: This is only used in defined module.</i>
type ClipTokenC t = TCodePos t -> WordCache t -> t -> ClipResultC t

-- | Clip a next token with word cache.

-- | <i>Warning: This is only used in defined module.</i>
type ClipTokenCL t = TCodePos t -> WordCache t -> t -> ClipResultCL t

-- | Update token scanner by clip result.
clipUpdate :: TokenScan t -> ClipResult t -> TokenScan t

-- | Update token scanner by clip result with word cache.
clipUpdateC :: TokenScan t -> ClipResultC t -> TokenScan t

-- | Update token scanner by clip result with word cache.
clipUpdateCL :: TokenScan t -> ClipResultCL t -> TokenScan t

-- | Clip space token.
--   
--   <pre>
--   &gt;&gt;&gt; clipSpace B.def "  foo bar baz"
--   ("foo bar baz", TSpace /0.0.0/ 3)
--   </pre>
clipSpace :: (Textual t) => ClipToken t

-- | Clip single-quoted text.
--   
--   <pre>
--   &gt;&gt;&gt; clipQ B.def O.emptyWordCache "foo bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextQ "foo")
--   </pre>
clipQ :: (Textual t) => ClipTokenC t

-- | Clip double-quoted text.
--   
--   <pre>
--   &gt;&gt;&gt; clipQq B.def O.emptyWordCache "foo\" bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextQQ "foo")
--   </pre>
clipQq :: (Textual t) => ClipTokenC t

-- | Clip quoted text before delimiter. This function must be called after
--   two single quotations.
--   
--   <pre>
--   &gt;&gt;&gt; clipQn B.def B.emptyWordCache "'foo''' bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextQQ "foo")
--   </pre>
clipQn :: (Textual t) => ClipTokenC t

-- | Clip symbolic token.
--   
--   <pre>
--   &gt;&gt;&gt; clipSymbol B.def O.emptyWordCache "foo bar baz"
--   (Cache 8 ["foo"] [], " bar baz", TText /0.0.0/ TextRaw "foo")
--   </pre>
clipSymbol :: (Textual t) => ClipTokenC t

-- | Clip slot name, like <tt>@foo</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clipSlot 1 B.def "foo bar baz"
--   (" bar baz", TSlot /0.0.0/ 1 "foo")
--   </pre>
clipSlot :: (Textual t) => Int -> ClipToken t

-- | Clip signed term name.
--   
--   <pre>
--   &gt;&gt;&gt; clipTermSign "+/" B.def B.def "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", [TTerm &lt;I0-L0-C0&gt; "+/foo"])
--   </pre>
clipTermSign :: (Textual t) => t -> ClipTokenCL t

-- | Clip term name.
--   
--   <pre>
--   &gt;&gt;&gt; clipTermName B.def Map.empty "foo bar baz"
--   (fromList [("foo","foo")], " bar baz", [TTerm &lt;I0-L0-C0&gt; "/foo"])
--   </pre>
clipTermName :: (Textual t) => ClipTokenCL t

-- | Clip quoted term.
--   
--   <pre>
--   &gt;&gt;&gt; clipTermQ B.def Map.empty "foo bar baz"
--   (fromList [], " bar baz", [TText &lt;I0-L0-C0&gt; TextTerm "foo"])
--   </pre>
clipTermQ :: (Textual t) => ClipTokenCL t

-- | Clip token beginning with <tt>"|"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clipBar B.def "-- C"
--   (" C", TText /0.0.0/ TextBar "|--")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clipBar B.def "| ..."
--   ("...", TText /0.0.0/ TextRaw "||")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clipBar B.def "12:00| ..."
--   (" ...", TText /0.0.0/ TextBar "|12:00|")
--   </pre>
clipBar :: (Textual t) => TCodePos t -> t -> ClipResult t


-- | Code section.
module Koshucode.Baala.Syntax.Token.Section

-- | Select scanner based on section name.
type ChangeSection t = t -> Maybe (TokenScanMap t)

-- | Line begins with triple equal signs is treated as section delimter.
section :: (Textual t) => ChangeSection t -> (t -> TokenScan t) -> TokenScanMap t

-- | Token scanner.
type Scanner t = ChangeSection t -> TokenScanMap t

-- | Scan tokens in <tt>end</tt> section.
scanEnd :: (Textual t) => Scanner t

-- | Scan tokens in <tt>note</tt> section.
scanNote :: (Textual t) => Scanner t

-- | Scan tokens in <tt>license</tt> section.
scanLicense :: (Textual t) => Scanner t

-- | Scan entire line as text.
scanLine :: (Textual t) => TextForm -> Scanner t

-- | Section for <tt>koshu-text-assert</tt> command.
scanTextAssert :: Scanner String


-- | Tokenizer for relational section.
module Koshucode.Baala.Syntax.Token.Rel

-- | Scan a next token in relational section.
scanRel :: (TextualTermName t) => Scanner t

-- | Scan interpretation content between <tt>{|</tt> and <tt>|}</tt>.
scanInterp :: (Textual t) => Scanner t


-- | Token line and clause.
module Koshucode.Baala.Syntax.Token.Clause

-- | Token list on a line.
type TokenLine t = CodeLine TToken t

-- | Tokenize with given scanner.
tokenLinesBy :: (ToLines i, TextualTermName t) => Scanner t -> IxIOPoint -> i -> [TokenLine t]

-- | Tokenize relational section.
tokenLines :: (ToLines i, TextualTermName t) => IxIOPoint -> i -> [TokenLine t]

-- | Tokenize lazy bytestring.
tokenLinesTextAssert :: (ToLines i) => IxIOPoint -> i -> [TokenLine String]

-- | Read token lines from file.
readTokenLines :: (TextualTermName t) => FilePath -> IOAb [TokenLine t]

-- | Code clause of tokens.
type TokenClause t = CodeClause TToken t

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine t] -> [TokenClause t]

-- | Read clause list from file.
--   
--   Content of file <tt>clause.txt</tt>:
--   
--   <pre>
--   **
--   **  This is an example file for 'readClauses' function
--   **  defined in Koshucode.Baala.Syntax.Token.Clause module.
--   **
--   
--   aa
--   bb
--    cc
--   
--   ** dd
--   ee
--   </pre>
--   
--   Read this file and parse to token clauses.
--   
--   <pre>
--   &gt;&gt;&gt; O.printList O.# B.abortLeft O.# readClauses "clause.txt"
--   CodeClause {clauseLines = ..., clauseTokens = [TText /0.1.0/ TextRaw "aa"]}
--   CodeClause {clauseLines = ..., clauseTokens = [TText /0.2.0/ TextRaw "bb",
--                                                  TText /0.3.1/ TextRaw "cc"]}
--   CodeClause {clauseLines = ..., clauseTokens = [TText /0.6.0/ TextRaw "ee"]}
--   </pre>
readClauses :: (TextualTermName t) => FilePath -> IOAb [TokenClause t]

-- | Read clauses and extract tokens.
readClauseTokens :: (TextualTermName t) => FilePath -> IOAb [[TToken t]]

-- | Abbreviated tokenizer.
toks :: (TextualTermName t) => String -> [TToken t]

-- | Print token list.
printToks :: [Token] -> IO ()

-- | Tokenize and print for debug.
--   
--   Words and quotations.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["aa", "'bb", "\"cc\"", "&lt;dd&gt;", "'/ee", "|012|"]
--   TText /0.1.0/ TextRaw "aa"
--   TText /0.2.0/ TextQ "bb"
--   TText /0.3.0/ TextQQ "cc"
--   TText /0.4.0/ TextUnk "dd"
--   TText /0.5.0/ TextTerm "ee"
--   TText /0.6.0/ TextBar "|012|"
--   </pre>
--   
--   Judgement.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["|-- R  /a A0 /b 31"]
--   TText /0.1.0/ TextBar "|--"
--   TSpace /0.1.3/ 1
--   TText /0.1.4/ TextRaw "R"
--   TSpace /0.1.5/ 2
--   TTerm /0.1.7/ "/a"
--   TSpace /0.1.9/ 1
--   TText /0.1.10/ TextRaw "A0"
--   TSpace /0.1.12/ 1
--   TTerm /0.1.13/ "/b"
--   TSpace /0.1.15/ 1
--   TText /0.1.16/ TextRaw "31"
--   </pre>
--   
--   Brackets.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["aa (bb x y (z))"]
--   TText /0.1.0/ TextRaw "aa"
--   TSpace /0.1.2/ 1
--   TOpen /0.1.3/ "("
--   TText /0.1.4/ TextRaw "bb"
--   TSpace /0.1.6/ 1
--   TText /0.1.7/ TextRaw "x"
--   TSpace /0.1.8/ 1
--   TText /0.1.9/ TextRaw "y"
--   TSpace /0.1.10/ 1
--   TOpen /0.1.11/ "("
--   TText /0.1.12/ TextRaw "z"
--   TClose /0.1.13/ ")"
--   TClose /0.1.14/ ")"
--   </pre>
--   
--   Comment.
--   
--   <pre>
--   &gt;&gt;&gt; toksPrint ["abc ** this is a comment", "def",""]
--   TText /0.1.0/ TextRaw "abc"
--   TSpace /0.1.3/ 1
--   TComment /0.1.4/ " this is a comment"
--   TText /0.2.0/ TextRaw "def"
--   </pre>
toksPrint :: [String] -> IO ()

-- | Parse string to clause and print it for inspection.
--   
--   <pre>
--   &gt;&gt;&gt; clausePrint ["|-- A /x 0 /y 1", "", "|== B : ", "  source A /x /y"]
--   ********** |-- A /x 0 /y 1
--   TText /0.1.0/ TextBar "|--"
--   TText /0.1.4/ TextRaw "A"
--   TTerm /0.1.6/ "/x"
--   TText /0.1.9/ TextRaw "0"
--   TTerm /0.1.11/ "/y"
--   TText /0.1.14/ TextRaw "1"
--   ********** |== B : 
--   TText /0.3.0/ TextBar "|=="
--   TText /0.3.4/ TextRaw "B"
--   TText /0.3.6/ TextRaw ":"
--   TText /0.4.2/ TextRaw "source"
--   TText /0.4.9/ TextRaw "A"
--   TTerm /0.4.11/ "/x"
--   TTerm /0.4.14/ "/y"
--   </pre>
clausePrint :: [String] -> IO ()


-- | Token and tokenizer.
module Koshucode.Baala.Syntax.Token


-- | Attribute name.
module Koshucode.Baala.Syntax.Attr.AttrName

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: Chars -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: Chars -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: Chars -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> Chars

-- | Attribute string with hyphen.
attrNameCode :: AttrName -> Chars

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrName.AttrName
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrName.AttrName


-- | Bracket type.
module Koshucode.Baala.Syntax.Tree.Bracket

-- | Type of bracket.
data BracketType

-- | <b>1.</b> Round brackets for grouping:
--   
--   <pre>
--   ( E ... )
--   </pre>
BracketGroup :: BracketType

-- | <b>2.</b> Round-single brackets for term path:
--   
--   <pre>
--   (- /N ... -)
--   </pre>
BracketTerm :: BracketType

-- | <b>3.</b> Square brackets for lists:
--   
--   <pre>
--   [ C | ... ]
--   </pre>
BracketList :: BracketType

-- | <b>4.</b> Curely braces for sets:
--   
--   <pre>
--   { C | ... }
--   </pre>
BracketSet :: BracketType

-- | <b>5.</b> Curely-single braces for ties:
--   
--   <pre>
--   {- /N C ... -}
--   </pre>
BracketTie :: BracketType

-- | <b>6.</b> Curely-double braces for relations:
--   
--   <pre>
--   {= /N ... [ C | ... ][ C | ... ] =}
--   </pre>
BracketRel :: BracketType

-- | <b>7.</b> Curely-bar braces for data interpretation:
--   
--   <pre>
--   {| ... /N ... |}
--   </pre>
BracketInterp :: BracketType

-- | <b>8.</b> Square-single brackets for type:
--   
--   <pre>
--   [- ... -]
--   </pre>
BracketType :: BracketType

-- | <b>9.</b> Round-bar brackets for calculation form:
--   
--   <pre>
--   (| V ... | E ... |)
--   </pre>
BracketForm :: BracketType

-- | <b>10.</b> Unknown bracket
BracketUnknown :: BracketType

-- | Bracket type of token.
getBracketType :: (Eq t, IsString t) => GetBracket BracketType (TToken t)

-- | Enclose mix text in brackets.
bracketWith :: (Bs, Bs) -> MixText -> MixText

-- | Group bracket — <tt>"("</tt> and <tt>")"</tt>
bracketGroup :: (IsString t) => (t, t)

-- | Term bracket — <tt>"(-"</tt> and <tt>"-)"</tt>
bracketTerm :: (IsString t) => (t, t)

-- | List bracket — <tt>"["</tt> and <tt>"]"</tt>
bracketList :: (IsString t) => (t, t)

-- | Set bracket — <tt>"{"</tt> and <tt>"}"</tt>
bracketSet :: (IsString t) => (t, t)

-- | Tie bracket — <tt>"{-"</tt> and <tt>"-}"</tt>
bracketTie :: (IsString t) => (t, t)

-- | Relation bracket — <tt>"{="</tt> and <tt>"=}"</tt>
bracketRel :: (IsString t) => (t, t)

-- | Interpretation bracket — <tt>"{|"</tt> and <tt>"|}"</tt>
bracketInterp :: (IsString t) => (t, t)

-- | Type bracket — <tt>"[-"</tt> and <tt>"-]"</tt>
bracketType :: (IsString t) => (t, t)
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Tree.Bracket.BracketType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Tree.Bracket.BracketType
instance GHC.Show.Show Koshucode.Baala.Syntax.Tree.Bracket.BracketType
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Tree.Bracket.BracketType


-- | Patterns for token tree.
module Koshucode.Baala.Syntax.Tree.Pattern

-- | Token leaf.

-- | Text leaf.

-- | Raw text leaf.

-- | Single-hyphen attribute text leaf.

-- | Double-hyphen attribute text leaf.

-- | Single-quoted text leaf.

-- | Double-quoted text leaf.

-- | Slot leaf.

-- | Term leaf.

-- | Token branch.

-- | Group branch.

-- | List branch.

-- | Set branch.

-- | Term path branch.

-- | Form branch.


-- | Syntax patterns. There are three one-letter patterns: <a>B</a> for
--   tree branch, <a>L</a> for tree leaf, and <a>T</a> for text token.
module Koshucode.Baala.Syntax.Pattern


-- | Parser for token tree.
module Koshucode.Baala.Syntax.Tree.Parse

-- | Tree of tokens.
type Tree = TTree Chars

-- | Tree of tokens.
type TTree t = CodeTree BracketType TToken t

-- | Convert to token trees.
class ToTrees t a where toTree a = ttreeGroup <$> toTrees a toTrees' = unabort . toTrees toTree' = unabort . toTree

-- | Convert to list of token trees.
toTrees :: (ToTrees t a, TextualTermName t) => a -> Ab [TTree t]

-- | Convert to token tree.
toTree :: (ToTrees t a, TextualTermName t) => a -> Ab (TTree t)

-- | List of token trees or error.
toTrees' :: (ToTrees t a, TextualTermName t) => a -> [TTree t]

-- | Token tree or error.
toTree' :: (ToTrees t a, TextualTermName t) => a -> TTree t

-- | Wrap trees in group.
ttreeGroup :: [TTree t] -> TTree t

-- | Call function with token trees.
--   
--   <pre>
--   &gt;&gt;&gt; withTrees Right "a"
--   Right [TreeL (TText /0.1.0/ TextRaw "a")]
--   </pre>
withTrees :: (TextualTermName t, ToTrees t a) => ([TTree t] -> Ab b) -> a -> Ab b

-- | Read clauses and convert to token trees.
readClauseTrees :: (TextualTermName t) => FilePath -> IOAb [[TTree t]]
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t GHC.Base.String
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t Koshucode.Baala.Overture.Shorthand.Tx
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t Koshucode.Baala.Overture.Shorthand.Tz
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t Koshucode.Baala.Overture.Shorthand.Bz
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t Koshucode.Baala.Overture.Shorthand.Bs
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t [Koshucode.Baala.Syntax.Token.Token.TToken t]
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t [Koshucode.Baala.Syntax.Tree.Parse.TTree t]
instance Koshucode.Baala.Syntax.Tree.Parse.ToTrees t (Koshucode.Baala.Syntax.Token.Clause.TokenClause t)


-- | Split token trees.
module Koshucode.Baala.Syntax.Tree.Split

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "b c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Left [ TText  CodePos {..} TextRaw "b"
--        , TSpace CodePos {..} 1
--        , TText  CodePos {..} TextRaw "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let Right t = S.toks "a | b | c"
--   
--   &gt;&gt;&gt; splitTokensBy (== "|") t
--   Right ( [ TText CodePos {..} TextRaw "a", TSpace CodePos {..} 1]
--         , TText CodePos {..} TextRaw "|"
--         , [ TText  CodePos {..} TextRaw "b"
--           , TSpace CodePos {..} 1
--           , TText  CodePos {..} TextRaw "|"
--           , TText  CodePos {..} TextRaw "c" ] )
--   </pre>
splitTokensBy :: Test t -> SplitList3e (TToken t)

-- | Split token trees by quoteless token of given string.
splitTreesBy :: Test t -> SplitList3e (TTree t)

-- | Divide token trees by raw text of given string.
divideTreesBy :: Test t -> [TTree t] -> [[TTree t]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; S.withTrees (Right . divideTreesByBar) "a | b x | c y z"
--   Right [ [ TreeL (TText /0.1.0/ TextRaw "a") ]
--         , [ TreeL (TText /0.1.4/ TextRaw "b")
--           , TreeL (TText /0.1.6/ TextRaw "x") ]
--         , [ TreeL (TText /0.1.10/ TextRaw "c")
--           , TreeL (TText /0.1.12/ TextRaw "y")
--           , TreeL (TText /0.1.14/ TextRaw "z") ]]
--   </pre>
divideTreesByBar :: (Textual t) => [TTree t] -> [[TTree t]]

-- | Divide token trees by double vertical bar <tt>"||"</tt>.
divideTreesByBar2 :: (Textual t) => [TTree t] -> [[TTree t]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: (Textual t) => [TTree t] -> [[TTree t]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: (Textual t) => [TTree t] -> [[TTree t]]


-- | Token trees.
module Koshucode.Baala.Syntax.Tree


-- | Decode subtree.
module Koshucode.Baala.Syntax.Subtree.Decode

-- | Read subtree clauses from file.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (S.printToks . B.clauseTokens) O.# B.abortLeft O.# readSubtreeClauses "subtree.txt"
--   ********** &gt; "a1"
--   TText /0.10.0/ TextRaw "&gt;"
--   TText /0.10.2/ TextQQ "a1"
--   TOpen /0.0.0/ "("
--   TText /0.11.2/ TextRaw "-"
--   TText /0.11.4/ TextQQ "bb"
--   TText /0.0.0/ TextRaw "|"
--   TText /0.12.2/ TextRaw "-"
--   TText /0.12.4/ TextQQ "cc"
--   TClose /0.0.0/ ")"
--   </pre>
readSubtreeClauses :: (TextualTermName t) => FilePath -> IOAb [TokenClause t]

-- | Insert open/sep/close to subtree clause.
subtreeClause :: (Textual t) => TokenClause t -> Ab (TokenClause t)

-- | Decode token trees to subtree patterns.
--   
--   <pre>
--   &gt;&gt;&gt; S.withTrees decodeSubtreePattern "- \"Z1\""
--   Right [SubtreeL SubtreeNone (SivmapEq "Z1")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.withTrees decodeSubtreePattern "&gt; \"Y1\" ( - \"Z1\" )"
--   Right [SubtreeB SubtreeNone (SivmapEq "Y1") [SubtreeL SubtreeNone (SivmapEq "Z1")]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.withTrees decodeSubtreePattern "&gt; \"Y1\" ( - \"Z1\" || - \"Z2\" )"
--   Right [SubtreeB SubtreeNone (SivmapEq "Y1")
--            [SubtreeL SubtreeNone (SivmapEq "Z1"),
--             SubtreeL SubtreeNone (SivmapEq "Z2")]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.withTrees decodeSubtreePattern "&gt;&gt; \"Y1\" ( - \"Z1\" )"
--   Right [SubtreeR (SivmapEq "Y1") [SubtreeL SubtreeNone (SivmapEq "Z1")]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; S.withTrees decodeSubtreePattern "&gt;&gt; \"Y1\" ( - A B /z \"Z1\" )"
--   Right [SubtreeR (SivmapEq "Y1") [SubtreeL (SubtreeText ["A","B"] (TermName EQ "z")) (SivmapEq "Z1")]]
--   </pre>
decodeSubtreePattern :: (TextualTermName t, ToSivExpr t) => [TTree t] -> Ab [SubtreePattern]


-- | Subtree.
module Koshucode.Baala.Syntax.Subtree


-- | Parameter.
module Koshucode.Baala.Syntax.Para


-- | Message list.
module Koshucode.Baala.Syntax.Attr.Message

-- | Abortable scope for attribute.
abAttr :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for attribute.
abAttrTrees :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for slot.
abSlot :: (GetCodePos cp) => Abortable cp b

-- | Unexpected attribute / Duplicate
dupAttr :: [TermName] -> Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | No slot content
noSlotName :: (Textual t) => Int -> t -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Require attribute
reqAttr :: (Textual t) => t -> Ab a

-- | Require attribute
reqAttrName :: (Textual t) => t -> Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unmatch any patterns
unexpAttrMulti :: [(String, ParaUnmatch String)] -> Ab a


-- | Bundle of message modules.
module Koshucode.Baala.Syntax.Message


-- | Slot substitution.
module Koshucode.Baala.Syntax.Attr.Slot

-- | Attribute name and its contents.
type AttrTree t = (AttrName, [TTree t])

-- | Global slot name and its content.
type GlobalSlot t = (String, [TTree t])

-- | Substitute slots by global and attribute slots.
substSlot :: (Textual t) => [GlobalSlot t] -> [AttrTree t] -> AbMap [TTree t]


-- | Attribute editor.
module Koshucode.Baala.Syntax.Attr.AttrEd

-- | Attribute editor with source code information.
type AttrEd t = Codic (AttrEdBody t)

-- | Operators for attribute editors.
data AttrEdBody t

-- | <b>id:</b> Identity editor
AttrEdId :: AttrEdBody t

-- | <b>add:</b> Add attribute
AttrEdAdd :: Bool -> t -> [TTree t] -> AttrEdBody t

-- | <b>rename:</b> Rename attribute keyword
AttrEdRename :: (t, t) -> AttrEdBody t

-- | <b>fill:</b> Fill positional attributes
AttrEdFill :: [Maybe (TTree t)] -> AttrEdBody t

-- | <b>nest:</b> Nested relation reference
AttrEdNest :: t -> [TTree t] -> AttrEdBody t

-- | Append editors
AttrEdAppend :: [AttrEd t] -> AttrEdBody t

-- | Construct attribute editor.
consAttrEd :: (Textual t) => [TTree t] -> Ab (AttrEd t)

-- | Edit relmap attributes.
runAttrEd :: AttrEd Chars -> AbMap [AttrTree Chars]
instance Koshucode.Baala.Overture.Text.Textual.Textual t => GHC.Classes.Ord (Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => GHC.Show.Show (Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody t)


-- | Attributes of relmap operator.
module Koshucode.Baala.Syntax.Attr.Attr

-- | Attribute layout.
data AttrLayout
AttrLayout :: [(Maybe ParaTag, AttrBranch)] -> AttrLayout

-- | Single layout.
data AttrBranch
AttrBranch :: AttrUsage -> AttrParaSpec -> Map AttrName -> AttrBranch

-- | Usage description
[attrUsage] :: AttrBranch -> AttrUsage

-- | Parameter specification
[attrParaSpec] :: AttrBranch -> AttrParaSpec

-- | Attribute classifier
[attrClassifier] :: AttrBranch -> Map AttrName

-- | Parameter specification for attribute name.
type AttrParaSpec = ParaSpec AttrName

-- | Usage text of attribute layout.
type AttrUsage = String

-- | List of attribute usages.
attrUsages :: AttrLayout -> [AttrUsage]

-- | Concatenated attribute usage.
attrUsageString :: AttrLayout -> String

-- | Attribute parameter.
type AttrPara t = Para AttrName (TTree t)

-- | Parameterizer for attribute of relmap operator.
type AttrParaze t = [TTree t] -> Ab (AttrPara t)

-- | Parameterize named attributes.
attrPara :: AttrParaze Chars

-- | Parameterize attributes by its layout.
attrParaBy :: AttrLayout -> AttrParaze Chars

-- | Take out hyphened text (like <tt>"-x"</tt>) from token tree.
maybeSingleHyphen :: (Textual t) => TTree t -> Maybe t

-- | Take out double-hyphened text (like <tt>"--xyz"</tt>) from token tree.
maybeDoubleHyphen :: (Textual t) => TTree t -> Maybe t

-- | Convertible to attribute layout.
--   
--   <ul>
--   <li><b><tt>-</tt>Word</b> — Normal attribute</li>
--   <li><b><tt>-</tt>Word<tt>/</tt></b> — Relmap attribute</li>
--   <li><b><tt>-</tt>Word<tt>/^</tt></b> — Local relmap attribute</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; toAttrLayout "-a"
--   AttrLayout [(Nothing, AttrBranch (
--     ParaSpec { paraSpecPos = ParaItem 1 [AttrNormal "a"]
--              , paraSpecReqP = [AttrNormal "a"]
--              , paraSpecOptP = [], paraSpecReqN = []
--              , paraSpecOptN = [AttrNormal "@trunk"]
--              , paraSpecFirst = [], paraSpecLast = [], paraSpecMulti = [] }
--              ))]
--   </pre>
class ToAttrLayout a
toAttrLayout :: ToAttrLayout a => a -> AttrLayout
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrLayout
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrBranch
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout Koshucode.Baala.Syntax.Attr.Attr.AttrLayout
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout GHC.Base.String
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout [GHC.Base.String]
instance Koshucode.Baala.Syntax.Attr.Attr.ToAttrLayout [(Koshucode.Baala.Syntax.Attr.Attr.AttrUsage, GHC.Base.String)]


-- | Syntax for attributes.
module Koshucode.Baala.Syntax.Attr


-- | Bundle of syntax modules.
module Koshucode.Baala.Syntax
