-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Additional data types for Koshucode
--   
--   Additional data types for Koshucode
@package koshucode-baala-type
@version 0.190.0.0


-- | Common properties of judgements and relations.
module Koshucode.Baala.Type.Judge.JudgeClass

-- | Name of judgement class, in other words, name of propositional
--   function.
type JudgeClass = String

-- | Get judge class.
class GetClass a
getClass :: GetClass a => a -> JudgeClass

-- | Get term list.
class GetTerms a
getTerms :: GetTerms a => a c -> [Term c]

-- | Get list of term names.
class GetTermNames a
getTermNames :: GetTermNames a => a -> [TermName]

-- | Get unique list of term names.
getTermNamesUnique :: (GetTermNames a) => a -> [TermName]
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTermNames [Koshucode.Baala.Syntax.Symbol.Term.TermName]
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTermNames GHC.Base.String


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Type.Judge.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of class, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement class represents certain sentence class
--   that gives intepretation of data. Sentence class has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c

-- | <pre>
--   |-- P /x 10 /y 20
--   </pre>
JudgeAffirm :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-x P /x 10 /y 20
--   </pre>
JudgeDeny :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-xx P /x 10 /y 20
--   </pre>
JudgeMultiDeny :: JudgeClass -> [Term c] -> Judge c

-- | <pre>
--   |-c P /x 10 +/y 20
--   </pre>
JudgeChange :: JudgeClass -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-cc P /x 10 +/y 20
--   </pre>
JudgeMultiChange :: JudgeClass -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-v P /x 10 /y 20
--   </pre>
JudgeViolate :: JudgeClass -> [Term c] -> Judge c

-- | Map function to terms.
judgeTermsMap :: ([Term a] -> [Term b]) -> Judge a -> Judge b

-- | Add a term into judgement.
judgeAdd :: Term c -> Map (Judge c)

-- | Construct judgement from its class and terms.
type JudgeOf c = JudgeClass -> [Term c] -> Judge c

-- | Construct affirmative judgement.
--   
--   <pre>
--   &gt;&gt;&gt; affirm "P" [("x",10), ("y",20)] :: Judge Int
--   JudgeAffirm "P" [("x",10), ("y",20)]
--   </pre>
affirm :: JudgeOf c

-- | Construct denial judgement.
deny :: JudgeOf c

-- | Affirm judgement, i.e., change logical quality to affirmative.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to denial.
--   
--   <pre>
--   &gt;&gt;&gt; denyJudge $ affirm "P" [("x",10), ("y",20)] :: Judge Int
--   JudgeDeny "P" [("x",10), ("y",20)]
--   </pre>
denyJudge :: Map (Judge c)

-- | Test which judgement is affirmed.
isAffirmative :: Test (Judge c)

-- | Test which judgement is denied.
isDenial :: Test (Judge c)

-- | Test which judgement is for violation.
isViolative :: Test (Judge c)

-- | Type of assertions.
data AssertType

-- | <tt>|==</tt> <i>C</i> <tt>:</tt> <i>R</i> generates affirmative
--   judges.
AssertAffirm :: AssertType

-- | <tt>|=x</tt> <i>C</i> <tt>:</tt> <i>R</i> generates denial judges.
AssertDeny :: AssertType

-- | <tt>|=xx</tt> <i>C</i> <tt>:</tt> <i>R</i> generates multiple-denial
--   judges.
AssertMultiDeny :: AssertType

-- | <tt>|=c</tt> <i>C</i> <tt>:</tt> <i>R</i> generates changement judges.
AssertChange :: AssertType

-- | <tt>|=cc</tt> <i>C</i> <tt>:</tt> <i>R</i> generates
--   multiple-changement judges.
AssertMultiChange :: AssertType

-- | <tt>|=v</tt> <i>C</i> <tt>:</tt> <i>R</i> generates violation judges.
AssertViolate :: AssertType

-- | Create judgement corresponding to assertion type.
assertAs :: AssertType -> JudgeOf c

-- | Frege's stroke and various assertion lines.
--   
--   <pre>
--   &gt;&gt;&gt; assertSymbol AssertAffirm
--   "|=="
--   </pre>
assertSymbol :: AssertType -> String

-- | Encode judgement with short sign converter.
type EncodeJudge c = TransString -> Judge c -> MixText

-- | Conventional line-break setting for judges: 4-spaces indent and
--   120-columns line.
judgeBreak :: LineBreak

-- | Encode judgement with term separator.
judgeMix :: (MixEncode c) => MixText -> EncodeJudge c

-- | Encode judgement with two-spaces term separator.
judgeMix2 :: (MixEncode c) => EncodeJudge c

-- | Encode judgement with tab term separator.
judgeMixTab :: (MixEncode c) => EncodeJudge c

-- | Conditional judgement encoder. If the first argument is true,
--   <a>judgeMix2</a> is used, otherwise <a>judgeMixTab</a>.
judgeMix2Tab :: (MixEncode c) => Bool -> EncodeJudge c

-- | Encode term name.
--   
--   <pre>
--   &gt;&gt;&gt; termNameToMix "foo"
--   MixText "/foo"
--   </pre>
termNameToMix :: TermName -> MixText

-- | Encode term list with one-space separator.
termsToMix1 :: (MixEncode c) => TransString -> [Term c] -> MixText

-- | Encode term list with two-spaces separator.
termsToMix2 :: (MixEncode c) => TransString -> [Term c] -> MixText
instance GHC.Classes.Ord Koshucode.Baala.Type.Judge.Judge.AssertType
instance GHC.Classes.Eq Koshucode.Baala.Type.Judge.Judge.AssertType
instance GHC.Show.Show Koshucode.Baala.Type.Judge.Judge.AssertType
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Type.Judge.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Type.Judge.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Type.Judge.Judge.Judge c)
instance GHC.Base.Functor Koshucode.Baala.Type.Judge.Judge.Judge
instance Koshucode.Baala.Type.Judge.JudgeClass.GetClass (Koshucode.Baala.Type.Judge.Judge.Judge c)
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTermNames (Koshucode.Baala.Type.Judge.Judge.Judge c)
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTerms Koshucode.Baala.Type.Judge.Judge.Judge
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode c => Koshucode.Baala.Base.MixText.MixEncode.MixEncode (Koshucode.Baala.Type.Judge.Judge.Judge c)


-- | Type for data interpretation.
module Koshucode.Baala.Type.Judge.Interp

-- | Data interpretation.
data Interp
Interp :: [InterpWord] -> [TermName] -> Interp

-- | Sentence which interpret data.
[interpWords] :: Interp -> [InterpWord]

-- | Terms in sentence.
[interpTerms] :: Interp -> [TermName]

-- | Component of data interpretation.
data InterpWord

-- | Constant part of interpretation.
InterpText :: String -> InterpWord

-- | Variable part of interpretation.
InterpTerm :: TermName -> InterpWord

-- | Create data interpretation.
interp :: [InterpWord] -> Interp
instance GHC.Classes.Ord Koshucode.Baala.Type.Judge.Interp.Interp
instance GHC.Classes.Eq Koshucode.Baala.Type.Judge.Interp.Interp
instance GHC.Show.Show Koshucode.Baala.Type.Judge.Interp.Interp
instance GHC.Classes.Ord Koshucode.Baala.Type.Judge.Interp.InterpWord
instance GHC.Classes.Eq Koshucode.Baala.Type.Judge.Interp.InterpWord
instance GHC.Show.Show Koshucode.Baala.Type.Judge.Interp.InterpWord
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTermNames Koshucode.Baala.Type.Judge.Interp.Interp
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Judge.Interp.Interp
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Judge.Interp.InterpWord


-- | Message list.
module Koshucode.Baala.Type.Message

-- | Divide by zero
divideByZero :: Ab a

-- | Different decimal length
heteroDecimal :: (MixEncode c) => c -> c -> Ab a

-- | Can't read as date
notDate :: Integer -> Int -> Int -> Ab a

-- | Not monthly date
notMonthlyDate :: Integer -> Int -> Int -> Ab a

-- | Not weekly date
notWeeklyDate :: Integer -> Int -> Int -> Ab a

-- | Not yearly date
notYearlyDate :: Integer -> Int -> Ab a

-- | Too large digit
tooLargeDigit :: String -> Ab a

-- | Can't read as number
notNumber :: String -> Ab a

-- | Abort reason with encodable values.
abortEncodables :: (MixEncode c) => String -> [c] -> AbortReason

-- | Numbered lines of encodables.
encodableLines :: (MixEncode c) => [c] -> [String]


-- | Parts of clock and time.
module Koshucode.Baala.Type.Time.Parts

-- | Synonym for MJD type.
type Mjd = Day

-- | Extract MJD integer value.
mjdInteger :: Mjd -> Integer

-- | Convert to the Modified Julian Day.
class ToMjd a
toMjd :: ToMjd a => a -> Mjd

-- | Convert to the Modified Just Day but abortable.
class ToMjdClip a where toMjdAb = Right . toMjdClip
toMjdClip :: ToMjdClip a => a -> Mjd
toMjdAb :: ToMjdClip a => a -> Ab Mjd

-- | Symbol of day of week.
data Dayw

-- | <b>1.</b> Day of the moon.
Monday :: Dayw

-- | <b>2.</b> Day of Mars
Tuesday :: Dayw

-- | <b>3.</b> Day between Tuesday and Thursday.
Wednesday :: Dayw

-- | <b>4.</b> Day of thunder.
Thursday :: Dayw

-- | <b>5.</b> Day of Venus.
Friday :: Dayw

-- | <b>6.</b> Day of Saturn.
Saturday :: Dayw

-- | <b>7.</b> Day of the sun.
Sunday :: Dayw

-- | Day of week.
--   
--   <pre>
--   &gt;&gt;&gt; mjdDayw (55555 :: Int)
--   Saturday
--   </pre>
mjdDayw :: (ToMjd day) => day -> Dayw

-- | Interval of weekday to next weekday.
--   
--   <pre>
--   &gt;&gt;&gt; daywDiff Wednesday Saturday
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; daywDiff Saturday Wednesday
--   4
--   </pre>
daywDiff :: Dayw -> Dayw -> Int

-- | Year type.
type Year = Integer

-- | Month type.
type Month = Int

-- | Week type.
type Week = Int

-- | Day type.
type Day = Int

-- | Decomposed date.
data DateParts

-- | MJD date
DateMjd :: Mjd -> DateParts

-- | Monthly date
DateYmd :: Year -> Month -> Day -> DateParts

-- | Weekly date
DateYwd :: Year -> Week -> Dayw -> DateParts

-- | Yearly date
DateYd :: Year -> Day -> DateParts

-- | End of month
DateEom :: Year -> Month -> DateParts

-- | <i>N</i>'th day of week in a month
DateYmnd :: Year -> Month -> Int -> Dayw -> DateParts

-- | Monthly date parts.
dateYmd :: Year -> Month -> Day -> DateParts

-- | Weekly date parts.
dateYwd :: Year -> Week -> Dayw -> DateParts

-- | Yearly date parts.
dateYd :: Year -> Day -> DateParts

-- | End of month.
dateEom :: Year -> Month -> DateParts

-- | <i>N</i>'th day of week in a month
--   
--   <pre>
--   &gt;&gt;&gt; toMjdClip $ dateYmnd 2013 4 3 Thursday
--   2013-04-18
--   </pre>
dateYmnd :: Year -> Month -> Int -> Dayw -> DateParts

-- | Integer type for the Modified Julian Day.
type Days = Integer

-- | Hour type.
type Hour = Int

-- | Minute type.
type Min = Int

-- | Second type.
type Sec = Int

-- | Decomposed clock.
data ClockParts
ClockPartsSec :: Days -> Hour -> Min -> Sec -> ClockParts
ClockPartsMin :: Days -> Hour -> Min -> ClockParts
ClockPartsHour :: Days -> Hour -> ClockParts
ClockPartsDays :: Days -> ClockParts

-- | Clock parts of days, hour, minute, and second.
clockDhms :: Days -> Hour -> Min -> Sec -> ClockParts

-- | Clock parts of days, hour, and minute.
clockDhm :: Days -> Hour -> Min -> ClockParts

-- | Clock parts of days and hour.
clockDh :: Days -> Hour -> ClockParts

-- | Clock parts of days only.
clockD :: Days -> ClockParts
instance GHC.Classes.Ord Koshucode.Baala.Type.Time.Parts.ClockParts
instance GHC.Classes.Eq Koshucode.Baala.Type.Time.Parts.ClockParts
instance GHC.Show.Show Koshucode.Baala.Type.Time.Parts.ClockParts
instance GHC.Classes.Ord Koshucode.Baala.Type.Time.Parts.DateParts
instance GHC.Classes.Eq Koshucode.Baala.Type.Time.Parts.DateParts
instance GHC.Show.Show Koshucode.Baala.Type.Time.Parts.DateParts
instance GHC.Classes.Ord Koshucode.Baala.Type.Time.Parts.Dayw
instance GHC.Classes.Eq Koshucode.Baala.Type.Time.Parts.Dayw
instance GHC.Show.Show Koshucode.Baala.Type.Time.Parts.Dayw
instance Koshucode.Baala.Type.Time.Parts.ToMjd Data.Time.Calendar.Days.Day
instance Koshucode.Baala.Type.Time.Parts.ToMjd GHC.Types.Int
instance Koshucode.Baala.Type.Time.Parts.ToMjd GHC.Integer.Type.Integer
instance GHC.Num.Num Data.Time.Calendar.Days.Day
instance GHC.Enum.Enum Koshucode.Baala.Type.Time.Parts.Dayw
instance Koshucode.Baala.Type.Time.Parts.ToMjdClip Koshucode.Baala.Type.Time.Parts.DateParts


-- | Date using the Modified Julian Day (MJD).
module Koshucode.Baala.Type.Time.Date

-- | Date.
data Date

-- | Date in <i>YYYY-MM-DD</i>
Monthly :: Mjd -> Date

-- | Date in <i>YYYY-#WW-D</i>
Weekly :: Mjd -> Date

-- | Date in <i>YYYY-##D</i>
Yearly :: Mjd -> Date

-- | Type for year, month, and day.
type Ymd = (Year, Month, Day)

-- | Create date from the Modified Julian Day.
--   
--   <pre>
--   &gt;&gt;&gt; dateFromMjd (55555 :: Int)
--   Date 2010-12-25
--   </pre>
dateFromMjd :: (ToMjd n) => n -> Date

-- | Create date from year, month, and day.
--   
--   <pre>
--   &gt;&gt;&gt; dateFromYmd 2013 4 18
--   Right Date 2013-04-18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dateFromYmd 2013 4 31
--   Left ...
--   </pre>
dateFromYmd :: Year -> Month -> Day -> Ab Date

-- | Create date from year, week, and day. Day 1 for Monday, 2 for Tuesday,
--   ..., and 7 for Sunday.
--   
--   <pre>
--   &gt;&gt;&gt; dateFromYwd 2013 16 4
--   Right Date 2013-#16-4 (2013-04-18)
--   </pre>
dateFromYwd :: Year -> Week -> Day -> Ab Date

-- | Create date from year and day.
--   
--   <pre>
--   &gt;&gt;&gt; dateFromYd 2013 108
--   Right Date 2013-##108 (2013-04-18)
--   </pre>
dateFromYd :: Year -> Day -> Ab Date

-- | Convert date into monthly date.
--   
--   <pre>
--   &gt;&gt;&gt; monthly $ dateFromMjd 55555
--   Date 2010-12-25
--   </pre>
monthly :: (ToMjd day) => day -> Date

-- | Convert date into weekly date.
--   
--   <pre>
--   &gt;&gt;&gt; weekly $ dateFromMjd 55555
--   Date 2010-#51-6 (2010-12-25)
--   </pre>
weekly :: (ToMjd day) => day -> Date

-- | Convert date into yearly date.
--   
--   <pre>
--   &gt;&gt;&gt; yearly $ dateFromMjd 55555
--   Date 2010-##359 (2010-12-25)
--   </pre>
yearly :: (ToMjd day) => day -> Date

-- | Alter the Modified Julian Day of date.
dateAltMjd :: Map Mjd -> Map Date

-- | Add days.
--   
--   <pre>
--   &gt;&gt;&gt; dateAdd 7 $ dateFromMjd 55555
--   Date 2011-01-01
--   </pre>
dateAdd :: (Integral n) => n -> Map Date

-- | Create mix text with two-width zeros.
--   
--   <pre>
--   &gt;&gt;&gt; mix02 5
--   MixText "05"
--   </pre>
mix02 :: Int -> MixText
instance GHC.Classes.Eq Koshucode.Baala.Type.Time.Date.Date
instance GHC.Classes.Ord Koshucode.Baala.Type.Time.Date.Date
instance GHC.Show.Show Koshucode.Baala.Type.Time.Date.Date
instance Koshucode.Baala.Type.Time.Parts.ToMjd Koshucode.Baala.Type.Time.Date.Date
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Time.Date.Date


-- | Clock: distance between two times.
module Koshucode.Baala.Type.Time.Clock

-- | Clock as distance between two times.
data Clock

-- | Clock represented by multiple of second
ClockDhms :: Days -> Sec -> Clock

-- | Clock represented by multiple of minute
ClockDhm :: Days -> Sec -> Clock

-- | Clock represented by multiple of hour
ClockDh :: Days -> Sec -> Clock

-- | Clock represented by multiple of day
ClockD :: Days -> Clock

-- | Convertible to clock.
class ToClock a
toClock :: ToClock a => a -> Clock

-- | Convert clock to mix text.
--   
--   <pre>
--   &gt;&gt;&gt; clockBodyToMix $ clockFromDhm 0 9 40
--   MixText "09:40"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.mixEncode $ clockFromDhm 0 9 40
--   MixText "|09:40|"
--   </pre>
clockBodyToMix :: Clock -> MixText

-- | Create clock from days, hour, minute, and second.
--   
--   <pre>
--   &gt;&gt;&gt; clockFromDhms 1 9 40 20
--   |1'09:40:20|
--   </pre>
clockFromDhms :: Days -> Hour -> Min -> Sec -> Clock

-- | Create clock from days, hour, and minute.
clockFromDhm :: Days -> Hour -> Min -> Clock

-- | Create clock from days and hour.
clockFromDh :: Days -> Hour -> Clock

-- | Create clock from days.
clockFromD :: Days -> Clock

-- | Decompose second into days, hour, minute and second parts.
--   
--   <pre>
--   &gt;&gt;&gt; dhmsFromSec 333333
--   (3,9,15,33)
--   </pre>
dhmsFromSec :: Sec -> (Days, Hour, Min, Sec)

-- | Aggregate hour, minute, and second into single second.
secFromHms :: (Hour, Min, Sec) -> Sec

-- | Days and second of clock.
--   
--   <pre>
--   &gt;&gt;&gt; clockDaysSec $ clockFromDhms 1 9 15 33
--   (1, 33333)
--   </pre>
clockDaysSec :: Clock -> DaysSec

-- | Split days part from clock.
--   
--   <pre>
--   &gt;&gt;&gt; clockDaysClock $ clockFromDhms 1 9 15 33
--   (1, |09:15:33|)
--   </pre>
clockDaysClock :: Clock -> (Days, Clock)

-- | Sign of clock as <tt>-1</tt>, <tt>0</tt>, <tt>1</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clockSign $ clockFromDhms 1 9 15 33
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clockSign $ clockFromDhms 0 0 0 0
--   0
--   </pre>
clockSign :: Clock -> Int

-- | Precision string of clock.
clockPrecision :: Clock -> String

-- | All attributes of clock.
clockAtts :: Clock -> (Days, Maybe Hour, Maybe Min, Maybe Sec)

-- | Replace elements of clock.
clockAlter :: Maybe Days -> Maybe Hour -> Maybe Min -> Maybe Sec -> Map Clock

-- | Map MDJ and second of clock.
clockMap :: Map Days -> Map Sec -> Map Clock

-- | Combine MDJ and second of two clocks.
clockMap2 :: Bin Days -> Bin Sec -> BinAb Clock

-- | Days and seconds.
type DaysSec = (Days, Sec)

-- | Calculate days and seconds.
--   
--   <pre>
--   &gt;&gt;&gt; daysSec 777777
--   (9, 177)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; daysSec (-777777)
--   (-10, 86223)
--   </pre>
daysSec :: Sec -> DaysSec

-- | Seconds in a day, i.e., 86400 seconds.
--   
--   <pre>
--   &gt;&gt;&gt; daySeconds :: Int
--   86400
--   </pre>
daySeconds :: (Num a) => a
instance GHC.Classes.Eq Koshucode.Baala.Type.Time.Clock.Clock
instance GHC.Classes.Ord Koshucode.Baala.Type.Time.Clock.Clock
instance Koshucode.Baala.Type.Time.Clock.ToClock Koshucode.Baala.Type.Time.Clock.Clock
instance Koshucode.Baala.Type.Time.Clock.ToClock Koshucode.Baala.Type.Time.Parts.ClockParts
instance GHC.Show.Show Koshucode.Baala.Type.Time.Clock.Clock
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Time.Clock.Clock


-- | Calculation on clock.
module Koshucode.Baala.Type.Time.ClockCalc

-- | Convert clock to positive clock.
clockPos :: Map Clock

-- | Convert clock to negative clock.
clockNeg :: Map Clock

-- | Set MJD to zero.
clockCutDay :: Map Clock

-- | Add MJD.
clockAddDay :: Days -> Map Clock

-- | Add second.
clockAddSec :: Sec -> Map Clock

-- | Calculation of clock plus clock.
clockAdd :: BinAb Clock

-- | Calculation of clock minus clock.
clockSub :: BinAb Clock

-- | Multiplication of clock.
clockTimes :: Int -> Map Clock

-- | Create sequence between two clocks.
--   
--   <pre>
--   &gt;&gt;&gt; clockRangeBy (clockStep 120) (clockFromDhm 0 0 0) (clockFromDhm 0 0 5)
--   [|00:00:00|, |00:02:00|, |00:04:00|]
--   </pre>
clockRangeBy :: Map (Days, Sec) -> RangeBy Clock

-- | Create clock step of given second.
clockStep :: Sec -> Map (Days, Sec)


-- | Time
module Koshucode.Baala.Type.Time.Time

-- | Time is a small duration on timeline.
data Time

-- | Date and clock with time zone
TimeYmdcz :: Date -> Clock -> Zone -> Time

-- | Date and clock
TimeYmdc :: Date -> Clock -> Time

-- | Year, month, and day
TimeYmd :: Date -> Time

-- | Year and week
TimeYw :: Mjd -> Time

-- | Year and month
TimeYm :: Mjd -> Time

-- | Time zone as offset from UTC.
type Zone = Sec

-- | Convert time to year/month/day tuple.
--   
--   <pre>
--   &gt;&gt;&gt; timeYmdTuple $ timeFromMjd 55555
--   (2010,12,25)
--   </pre>
timeYmdTuple :: Time -> Ymd

-- | Get the name of time precision.
timePrecision :: Time -> String

-- | Create monthly time.
--   
--   <pre>
--   &gt;&gt;&gt; monthlyTime (D.DateYmd 2013 4 18) (Just $ D.ClockPartsMin 0 12 05)
--   Right 2013-04-18 12:05
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; monthlyTime (D.DateYmd 2013 4 18) (Nothing :: Maybe D.ClockParts)
--   Right 2013-04-18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; monthlyTime (D.DateYmd 2013 4 31) (Nothing :: Maybe D.ClockParts)
--   Left AbortReason "Not monthly date" ...
--   </pre>
monthlyTime :: (ToMjdClip day, ToClock clock) => day -> Maybe clock -> Ab Time

-- | Create monthly clipped time.
monthlyClippedTime :: (ToMjdClip day, ToClock clock) => day -> Maybe clock -> Time

-- | Create monthly day-precision time.
monthlyTimeDate :: (ToMjdClip day) => day -> Ab Time

-- | Create monthly clock-precision time.
monthlyTimeClock :: (ToMjdClip day, ToClock clock) => day -> clock -> Ab Time

-- | Create time data from the Modified Julian day.
--   
--   <pre>
--   &gt;&gt;&gt; timeFromMjd (55555 :: Int)
--   2010-12-25
--   </pre>
timeFromMjd :: (ToMjd mjd) => mjd -> Time

-- | Create time data from year and month.
timeFromYmAb :: Year -> Month -> Ab Time

-- | Create time data from year and week.
timeFromYwAb :: Year -> Week -> Ab Time

-- | Create time data from date, clock, and time zone.
timeFromDczAb :: Date -> Clock -> Maybe Zone -> Ab Time

-- | Create time from year, month, and day.
--   
--   <pre>
--   &gt;&gt;&gt; timeFromYmd 2013 4 18
--   2013-04-18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timeFromYmd 2013 4 0
--   2013-04-01
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timeFromYmd 2013 4 33
--   2013-04-30
--   </pre>
timeFromYmd :: Year -> Month -> Day -> Time

-- | Craete time from tuple of year, month, and day.
--   
--   <pre>
--   &gt;&gt;&gt; timeFromYmdTuple (2013, 4, 18)
--   2013-04-18
--   </pre>
timeFromYmdTuple :: Ymd -> Time

-- | Get UTC.
--   
--   <pre>
--   &gt;&gt;&gt; nowUtc
--   2013-04-18 08:37:36 UTC
--   </pre>
nowUtc :: IO Time

-- | Get current time with time zone.
--   
--   <pre>
--   &gt;&gt;&gt; nowZoned
--   2013-04-18 17:37:36 +09:00
--   </pre>
nowZoned :: IO Time

-- | Get current local time without time zone.
--   
--   <pre>
--   &gt;&gt;&gt; now
--   2013-04-18 17:37:36
--   </pre>
now :: IO Time

-- | Get today.
--   
--   <pre>
--   &gt;&gt;&gt; today
--   2013-04-18
--   </pre>
today :: IO Time

-- | Cut clock part.
timeCutClock :: Map Time

-- | Alter time zone part.
timeAltZone :: Map Zone -> Map Time

-- | Cut timezone.
timeCutZone :: Map Time

-- | Cut timezone and convert to local time, i.e., addition of UTC and time
--   zone.
timeLocalize :: Map Time

-- | Alter day part.
timeAltDate :: Map Date -> Map Time

-- | Alter integer content of the Modified Julian Day.
timeAltDays :: Map Days -> Map Time

-- | Convert local time to Koshu time content.
timeFromZonedTime :: ZonedTime -> Time

-- | Days and seconds of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeDaysSec $ timeFromMjd 55555
--   (55555,0)
--   </pre>
timeDaysSec :: Time -> DaysSec
instance GHC.Classes.Ord Koshucode.Baala.Type.Time.Time.Time
instance GHC.Classes.Eq Koshucode.Baala.Type.Time.Time.Time
instance Data.Default.Class.Default Koshucode.Baala.Type.Time.Time.Time
instance Koshucode.Baala.Type.Time.Parts.ToMjd Koshucode.Baala.Type.Time.Time.Time
instance GHC.Show.Show Koshucode.Baala.Type.Time.Time.Time
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Time.Time.Time


-- | Calculation on time.
module Koshucode.Baala.Type.Time.TimeCalc

-- | Add days to time.
timeAddDay :: Days -> Map Time

-- | Add weeks to time.
timeAddWeek :: Integer -> Map Time

-- | Add months to time.
timeAddMonth :: Integer -> Map Time

-- | Add years to time.
timeAddYear :: Year -> Map Time

-- | Add clock to time.
timeAddClock :: Clock -> AbMap Time

-- | Calculate clock from time to time.
timeDiff :: Time -> Time -> Ab Clock

-- | Convert to the first day of month.
--   
--   <pre>
--   &gt;&gt;&gt; timeFloorMonth $ timeFromYmd 2014 11 3
--   2014-11-01
--   </pre>
timeFloorMonth :: Map Time

-- | Convert to the first day of year.
--   
--   <pre>
--   &gt;&gt;&gt; timeFloorYear $ timeFromYmd 2014 11 3
--   2014-01-01
--   </pre>
timeFloorYear :: Map Time

-- | Convert to the first day of next month.
--   
--   <pre>
--   &gt;&gt;&gt; timeCeilMonth $ timeFromYmd 2014 11 3
--   2014-12-01
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timeCeilMonth $ timeFromYmd 2014 12 25
--   2015-01-01
--   </pre>
timeCeilMonth :: Map Time

-- | Convert to the first day of next year.
--   
--   <pre>
--   &gt;&gt;&gt; timeCeilYaer $ timeFromYmd 2014 11 3
--   2015-01-01
--   </pre>
timeCeilYaer :: Map Time

-- | Create range of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeRangeDay (D.timeFromYmd 2014 11 3) (D.timeFromYmd 2014 11 5)
--   [2014-11-03, 2014-11-04, 2014-11-05]
--   </pre>
timeRangeDay :: RangeBy Time

-- | Create range of time.
--   
--   <pre>
--   &gt;&gt;&gt; timeRangeMonth (timeFromYmd 2014 12 31) (timeFromYmd 2015 03 5)
--   [2014-12-31, 2015-01-31, 2015-02-28]
--   </pre>
timeRangeMonth :: RangeBy Time

-- | Create range of time.
timeRangeYear :: RangeBy Time


-- | Extra functions for rational numbers.
module Koshucode.Baala.Type.Decimal.Rational

-- | <a>Rational</a> version of <a>%</a>.
(%%) :: Integer -> Integer -> Rational

-- | Integer part and proper fraction part of ratio of two numbers, i.e.,
--   <i>x</i> <a>//.</a> <i>y</i> == (<i>integer</i>,
--   <i>proper-fraction</i>) of <i>x</i> <a>%</a> <i>y</i>.
(//.) :: (Integral n) => n -> n -> (n, Ratio n)

-- | Synonym of <a>quotRem</a>.
(//) :: (Integral n) => n -> n -> (n, n)

-- | 1 <a>%</a> 2
ratioHalf :: (Integral n) => Ratio n

-- | Unit rational number for decimal fractional length.
ratioFracle :: (Integral i, Integral n) => i -> Ratio n

-- | Round rational number at decimal fractional length.
ratioRoundAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round-to-even rational number at decimal fractional length.
ratioRoundEvenAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round rational number per unit rational number.
ratioRoundPer :: (Integral n) => Bin (Ratio n)

-- | Round-to-even rational number per unit rational number.
ratioRoundEvenPer :: (Integral n) => Bin (Ratio n)

-- | Truncate rational number at decimal fractional length.
ratioTruncAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Truncate rational number per unit rational number.
ratioTruncPer :: (Integral n) => Bin (Ratio n)

-- | Round out (toward infinity) rational number at decimal fractional
--   length.
ratioRoundOutAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round out (toward infinity) rational number per unit rational number.
ratioRoundOutPer :: (Integral n) => Bin (Ratio n)

-- | Floor rational number at decimal fractional length.
ratioFloorAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Floor rational number per unit rational number.
ratioFloorPer :: (Integral n) => Bin (Ratio n)

-- | Ceiling rational number at decimal fractional length.
ratioCeilAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Ceiling rational number per unit rational number.
ratioCeilPer :: (Integral n) => Bin (Ratio n)

-- | Quotient of two ratio numbers.
--   
--   <pre>
--   &gt;&gt;&gt; ratioQuo (5 %% 1) (2 %% 3)
--   7 % 1
--   </pre>
ratioQuo :: (Integral n) => Bin (Ratio n)

-- | Remainder of two ratio numbers.
--   
--   <pre>
--   &gt;&gt;&gt; ratioRem (5 %% 1) (2 %% 3)
--   1 % 3
--   </pre>
ratioRem :: (Integral n) => Bin (Ratio n)

-- | Quotient and remainder of two ratio numbers.
--   
--   <pre>
--   &gt;&gt;&gt; ratioQuoRem (5 %% 1) (2 %% 3)
--   (7 % 1, 1 % 3)
--   </pre>
ratioQuoRem :: (Integral n) => Ratio n -> Ratio n -> (Ratio n, Ratio n)


-- | Decimal number.
--   
--   A decimal number in Koshucode is internally represented using a
--   rational number (<a>decimalRatio</a>) with a length of fractional part
--   (<a>decimalFracle</a>) . For example, the decimal number 11.250
--   correnponds to the rational number 45/4 with the fraction length 3.
--   
--   <ul>
--   <li><i>Decimal number</i> Number represented using 10 digits and the
--   decimal separator.</li>
--   <li><i>Decimal separator</i> Symbol between integer part and
--   fractional part.</li>
--   <li><i>Fractional part</i> The right part of decimal numbers, e.g.,
--   250 for 11.250.</li>
--   <li><i>Integer part</i> The left part of decimal numbers, e.g., 11 for
--   11.250.</li>
--   <li><i>Integral decimal</i> Decimal number without fractional
--   part.</li>
--   </ul>
module Koshucode.Baala.Type.Decimal.Decimal

-- | Type for numerator or denominator for decimal numbers.
type DecimalInteger = Integer

-- | Rational number of decimal type.
type DecimalRatio = Ratio DecimalInteger

-- | Length of fractional part.
type DecimalFracle = Int

-- | Decimal number.
data Decimal
Decimal :: DecimalFracle -> DecimalRatio -> Decimal

-- | Length of the fractional part
[decimalFracle] :: Decimal -> DecimalFracle

-- | Rational number for the decimal number
[decimalRatio] :: Decimal -> DecimalRatio

-- | Change decimal fracle.
decimalFracleSet :: DecimalFracle -> AbMap Decimal

-- | Map function to rational number in decimal.
decimalRatioMap :: Map DecimalRatio -> Map Decimal

-- | Binary operation for two decimals.
type BinDecimal = Bin Decimal

-- | Abortable binary operation for two decimals.
type BinAbDecimal = BinAb Decimal

-- | Combinate fracle.
type BinFracle = Bin DecimalFracle

-- | Combinate rational number.
type BinRatio = Bin DecimalRatio

-- | Binary operation for two decimals.
decimalBin :: BinFracle -> BinRatio -> BinDecimal

-- | Abortable binary operation for two decimals.
decimalBinAb :: BinFracle -> BinRatio -> BinAbDecimal

-- | Convert integral number to integral decimal number.
integralDecimal :: (Integral n) => n -> Decimal

-- | Convert real number to decimal number.
realDecimal :: (Real n) => DecimalFracle -> n -> Decimal

-- | Convert decimal number to fractional number.
decimalFractional :: (Fractional n) => Decimal -> n

-- | Convert decimal number to double.
decimalDouble :: Decimal -> Double
instance GHC.Show.Show Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Eq Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Ord Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Enum.Enum Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Num.Num Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Real.Real Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Real.Fractional Koshucode.Baala.Type.Decimal.Decimal.Decimal
instance GHC.Real.RealFrac Koshucode.Baala.Type.Decimal.Decimal.Decimal


-- | Decimal functions.
module Koshucode.Baala.Type.Decimal.Fraction

-- | Integer part of decimal.
decimalIntPart :: Map Decimal

-- | Fractional part of decimal.
decimalFracPart :: Map Decimal

-- | Integer and fractional parts of decimal.
--   
--   <pre>
--   &gt;&gt;&gt; decimalIntFrac $ D.realDecimal 2 (4.5 :: Double)
--   (Decimal (2) 4, Decimal (2) 0 + 1 % 2)
--   </pre>
decimalIntFrac :: Decimal -> (Decimal, Decimal)

-- | Numerator part of decimal number.
decimalNum :: Decimal -> DecimalInteger

-- | Denominator part of decimal number.
decimalDenom :: Decimal -> DecimalInteger

-- | Round decimal per self fractional length.
decimalRound :: Map Decimal

-- | Round decimal per fractional length.
decimalRoundAt :: Bin Decimal

-- | Round decimal per unit decimal.
decimalRoundPer :: Bin Decimal

-- | Round decimal to even per self fractional length.
decimalRoundEven :: Map Decimal

-- | Round decimal to even per fractional length.
decimalRoundEvenAt :: Bin Decimal

-- | Round decimal to even per unit decimal.
decimalRoundEvenPer :: Bin Decimal

-- | Truncate decimal per self fractional length.
decimalTrunc :: Map Decimal

-- | Truncate decimal per fractional length.
decimalTruncAt :: Bin Decimal

-- | Truncate decimal per unit decimal.
decimalTruncPer :: Bin Decimal

-- | Truncation error of decimal.
decimalTruncError :: Map Decimal

-- | Round out (toward infinity) decimal to even per self fractional
--   length.
decimalRoundOut :: Map Decimal

-- | Round out (toward infinity) decimal to even per fractional length.
decimalRoundOutAt :: Bin Decimal

-- | Round out (toward infinity) decimal to even per unit decimal.
decimalRoundOutPer :: Bin Decimal

-- | Floor decimal per self fractional length.
decimalFloor :: Map Decimal

-- | Floor decimal per fractional length.
decimalFloorAt :: Bin Decimal

-- | Floor decimal per unit decimal.
decimalFloorPer :: Bin Decimal

-- | Ceiling decimal per self fractional length.
decimalCeil :: Map Decimal

-- | Ceiling decimal per fractional length.
decimalCeilAt :: Bin Decimal

-- | Ceiling decimal per unit decimal.
decimalCeilPer :: Bin Decimal

-- | <tt>chopDigitsTrancate</tt> <i>d</i> <i>n</i> returns a number which
--   does not have the tailing <i>d</i> digits. If <i>d</i> is zero or
--   negative, it returns just <i>n</i>.
chopDigitsTrancate :: (Integral d, Integral n) => d -> n -> n

-- | <tt>chopDigitsRound</tt> is similar to <a>chopDigitsTrancate</a>, but
--   rounds chopped digit.
chopDigitsRound :: (Integral d, Integral n) => d -> n -> n

-- | Round the last (least significant) digit.
roundLastDigit :: (Integral n) => n -> n


-- | Decode and encode of decimals.
--   
--   <ul>
--   <li><i>Decimal</i> Head Int Frac ? Tail</li>
--   <li><i>Head</i> Sign ...</li>
--   <li><i>Int</i> Digit ...</li>
--   <li><i>Frac</i> Separator Digit ...</li>
--   <li><i>Tail</i> Sign ...</li>
--   <li><i>Sign</i> Space | <tt>"-"</tt> | <tt>"+"</tt></li>
--   <li><i>Digit</i> Space | <tt>"0"</tt> | ... | <tt>"9"</tt> |
--   <tt>"a"</tt> | ... | <tt>"z"</tt> | <tt>"A"</tt> | ... |
--   <tt>"Z"</tt></li>
--   <li><i>Separator</i> <tt>"."</tt></li>
--   <li><i>Space</i> <tt>" "</tt></li>
--   </ul>
module Koshucode.Baala.Type.Decimal.Coder

-- | Decode to <tt>a</tt>.
type DecodeAb a = String -> Ab a

-- | Decode base-2 digits to decimal.
decodeBinary :: DecodeAb Decimal

-- | Decode base-8 digits to decimal.
decodeOctal :: DecodeAb Decimal

-- | Decode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11"
--   Right Decimal (0) 11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "-12 345.00"
--   Right Decimal (2) -12345
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11.250 +"
--   Right Decimal (3) 11 + 1 % 4
--   </pre>
decodeDecimal :: DecodeAb Decimal

-- | Decode base-16 digits to decimal.
decodeHex :: DecodeAb Decimal

-- | Decode digits to number.
decodeBase :: Integer -> DecodeAb Decimal

-- | Encode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal 0 (12345 D.%% 10)
--   "1 234"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal 2 (12345 D.%% 10)
--   "1 234.50"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodeDecimal $ D.realDecimal (-2) (12345 D.%% 10)
--   "1 2oo"
--   </pre>
encodeDecimal :: Decimal -> String

-- | Encode decimals without spaces.
encodeDecimalCompact :: Decimal -> String
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Decimal.Decimal.Decimal


-- | Arithmetics on decimals.
module Koshucode.Baala.Type.Decimal.BinaryAb

-- | Fracle-selection mode in composing decimals.
data FracleSide

-- | Select longer fracle (<tt>+</tt>)
FracleLong :: FracleSide

-- | Select left fracle (<tt>.+</tt>)
FracleLeft :: FracleSide

-- | Select right fracle (<tt>+.</tt>)
FracleRight :: FracleSide

-- | Check same fracles (<tt>.+.</tt>)
FracleStrict :: FracleSide

-- | Addition: <i>x</i> + <i>y</i>
decimalAdd :: FracleSide -> BinAbDecimal

-- | Add all decimals.
decimalSum :: [Decimal] -> Ab Decimal

-- | Subtruction: <i>x</i> - <i>y</i>
decimalSub :: FracleSide -> BinAbDecimal

-- | Multiplication: <i>x</i> × <i>y</i>
decimalMul :: BinAbDecimal

-- | Division: <i>x</i> ÷ <i>y</i>
decimalDiv :: BinAbDecimal

-- | Quotient: integral part of <i>x</i> ÷ <i>y</i>
decimalQuo :: BinAbDecimal

-- | Remainder: <i>y</i> × fractional part of <i>x</i> ÷ <i>y</i>
decimalRem :: BinAbDecimal
instance GHC.Classes.Eq Koshucode.Baala.Type.Decimal.BinaryAb.FracleSide
instance GHC.Classes.Ord Koshucode.Baala.Type.Decimal.BinaryAb.FracleSide
instance GHC.Show.Show Koshucode.Baala.Type.Decimal.BinaryAb.FracleSide


-- | Bundle of time modules.
module Koshucode.Baala.Type.Time


-- | Judgement and related types.
module Koshucode.Baala.Type.Judge


-- | Type for types.
module Koshucode.Baala.Type.Type

-- | Type for types.
data Type

-- | Everything
TypeAny :: Type

-- | Type of types
TypeType :: Type

-- | Term name
TypeTerm :: Type

-- | Data interpreation
TypeInterp :: Type

-- | Empty
TypeEmpty :: Type

-- | End
TypeEnd :: Type

-- | Boolean
TypeBool :: Type

-- | Text
TypeText :: Type

-- | Code
TypeCode :: Type

-- | Decimal
TypeDec :: Type

-- | Clock
TypeClock :: (Maybe String) -> Type

-- | Time
TypeTime :: (Maybe String) -> Type

-- | Binary data
TypeBin :: Type

-- | List
TypeList :: Type -> Type

-- | Set
TypeSet :: Type -> Type

-- | Tagged type
TypeTag :: String -> Type -> Type

-- | Tie
TypeTie :: [Term Type] -> Type

-- | Relation
TypeRel :: [Term Type] -> Type

-- | Tuple (Product type)
TypeTuple :: [Type] -> Type

-- | Sum type
TypeSum :: [Type] -> Type

-- | Term type, i.e., term name and type of its content.
type NamedType = Named Type

-- | Print type as tree.
typeExplain :: Type -> Doc

-- | Encode term types.
typeTermMix :: Type -> MixText

-- | Create relation type from term names.
typeFlatRel :: [TermName] -> Type

-- | Add term name to relation type.
typeConsRel :: TermName -> Map Type

-- | Add term name and type to relation type.
typeConsNest :: TermName -> Type -> Map Type

-- | Add term names to relation type.
typeAppendRel :: [TermName] -> Map Type

-- | Get term names from relation type.
typeRelTermNames :: Type -> [TermName]

-- | Get degree of relation type.
typeRelDegree :: Type -> Int

-- | Get named type from relation type or tie type.
typeTerms :: Type -> [Term Type]

-- | Test type is relational.
isTypeRel :: Type -> Bool

-- | Calculate term index.
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeConsNest "r" (typeFlatRel ["a", "b"]) (typeFlatRel [])) ["r", "b"]
--   [0, 1]
--   </pre>
typeRelIndex :: Type -> TermPath -> [Int]

-- | Modify terms of relation type.
typeRelMapTerms :: Map [Term Type] -> Map Type

-- | Modify term of relation type.
typeRelMapTerm :: Map (Term Type) -> Map Type

-- | Modify term name of relation type.
typeRelMapName :: Map TermName -> Map Type
instance GHC.Classes.Ord Koshucode.Baala.Type.Type.Type
instance GHC.Classes.Eq Koshucode.Baala.Type.Type.Type
instance GHC.Show.Show Koshucode.Baala.Type.Type.Type
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Type.Type


-- | Term picker is a data for picking target terms based on input heading
--   terms.
module Koshucode.Baala.Type.Rel.TermPicker

-- | Data for picking shared and proper terms.
type TermPicker c = Picker TermName c

-- | Type for picking terms.
type TermPick c = TermPicker c -> [c] -> [c]

-- | Double picker.
type TermPick2 a b = (TermPick a, TermPick b)

-- | Create term picker from left and right term names
termPicker :: (GetTermNames target, GetTermNames input) => target -> input -> TermPicker c

-- | List of present terms. The first argument of <a>termPicker</a> is
--   treated as target terms, and the second is terms of input heading.
--   Because firstly target terms are given to relmap operator, secondly
--   input heading is fixed.
--   
--   <pre>
--   &gt;&gt;&gt; preTerms $ termPicker "/a /b /c" "/a /b /d /e"
--   [TermName EQ "a",TermName EQ "b"]
--   </pre>
preTerms :: TermPicker c -> [TermName]

-- | List of new terms.
--   
--   <pre>
--   &gt;&gt;&gt; newTerms $ termPicker "/a /b /c" "/a /b /d /e"
--   [TermName EQ "c"]
--   </pre>
newTerms :: TermPicker c -> [TermName]

-- | Test present terms exist.
--   
--   <pre>
--   &gt;&gt;&gt; preTermsExist $ termPicker "/d /e" "/a /b /c"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preTermsExist $ termPicker "/c /d /e" "/a /b /c"
--   True
--   </pre>
preTermsExist :: Test (TermPicker c)

-- | Test new terms exist.
--   
--   <pre>
--   &gt;&gt;&gt; newTermsExist $ termPicker "/a /b /c" "/a /b /d /e"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; newTermsExist $ termPicker "/a /b" "/a /b /d /e"
--   False
--   </pre>
newTermsExist :: Test (TermPicker c)

-- | Indices of target terms on input terms.
--   
--   <pre>
--   &gt;&gt;&gt; termsIndex $ termPicker "/b /d" "/a /b /c /d"
--   [1,3]
--   </pre>
termsIndex :: TermPicker c -> [Int]

-- | Pick contents of target terms.
--   
--   <pre>
--   &gt;&gt;&gt; pickDirect "/b /d" "/a /b /c /d" "ABCD"
--   "BD"
--   </pre>
pickDirect :: (GetTermNames target, GetTermNames input) => target -> input -> Map [c]

-- | Pick target terms from input terms.
--   
--   <pre>
--   &gt;&gt;&gt; pickTerms (termPicker "/b /d" "/a /b /c /d") "ABCD"
--   "BD"
--   </pre>
pickTerms :: TermPick c

-- | Cut target terms from input terms.
--   
--   <pre>
--   &gt;&gt;&gt; cutTerms (termPicker "/b /d" "/a /b /c /d") "ABCD"
--   "AC"
--   </pre>
cutTerms :: TermPick c

-- | Move target terms forward.
--   
--   <pre>
--   &gt;&gt;&gt; forwardTerms (termPicker "/b /d" "/a /b /c /d") "ABCD"
--   "BDAC"
--   </pre>
forwardTerms :: TermPick c

-- | Move target terms backward.
--   
--   <pre>
--   &gt;&gt;&gt; backwardTerms (termPicker "/b /d" "/a /b /c /d") "ABCD"
--   "ACBD"
--   </pre>
backwardTerms :: TermPick c

-- | Move target terms forward if <a>True</a> or backward if <a>False</a>.
towardTerms :: Bool -> TermPick c

-- | Double <a>pickTerms</a>.
pickTerms2 :: TermPick2 a b

-- | Double <a>cutTerms</a>.
cutTerms2 :: TermPick2 a b

-- | Double <a>forwardTerms</a>.
forwardTerms2 :: TermPick2 a b

-- | Double <a>backwardTerms</a>.
backwardTerms2 :: TermPick2 a b


-- | Heading of relations
module Koshucode.Baala.Type.Rel.Head

-- | Heading of relations.
data Head
Head :: Type -> Head
[headType] :: Head -> Type

-- | Pretty print head of relation.
--   
--   <pre>
--   &gt;&gt;&gt; headExplain $ headFrom ["a", "b"]
--   rel /a any
--       /b any
--   </pre>
headExplain :: Head -> Doc

-- | Make head of given type..
headOf :: Type -> Head

-- | Make head from term names.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["a", "b"]
--   Head { headType = TypeRel [("a", TypeAny), ("b", TypeAny)] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; B.mixEncode $ headFrom ["a", "b"]
--   MixText "/a /b"
--   </pre>
headFrom :: (ToTermName n) => [n] -> Head

-- | Test two heads are equivalent.
headEquiv :: Head -> Head -> Bool

-- | Test heading is subset of another heading.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["a", "b"] `isSubhead` headFrom ["a", "b", "c"]
--   True
--   
--   &gt;&gt;&gt; headFrom ["a", "e"] `isSubhead` headFrom ["a", "b", "c"]
--   False
--   </pre>
isSubhead :: Head -> Head -> Bool

-- | Test heading is superset of another heading.
isSuperhead :: Head -> Head -> Bool

-- | Degree of relation, i.e., number of terms.
--   
--   <pre>
--   &gt;&gt;&gt; headDegree $ headFrom ["a", "b"]
--   2
--   </pre>
headDegree :: Head -> Int

-- | Select nested terms.
headNested :: Head -> [(TermName, Head)]

-- | Index of a term.
headIndex1 :: Head -> TermPath -> [Int]

-- | Get types of relation terms.
headTypes :: Head -> [Type]

-- | Add term name to head.
--   
--   <pre>
--   &gt;&gt;&gt; headCons "c" $ headFrom ["a", "b"]
--   Head { headType = TypeRel [("c",TypeAny), ("a",TypeAny), ("b",TypeAny)] }
--   </pre>
headCons :: TermName -> Map Head

-- | Add term names to head.
headAppend :: [TermName] -> Map Head

-- | Add term name for nested relation.
headConsNest :: TermName -> Head -> Map Head

-- | Create nested relation terms.
--   
--   <pre>
--   &gt;&gt;&gt; headNests ["x", "y"] $ headFrom ["a"]
--   Head { headType = TypeRel [("x", TypeRel [("a",TypeAny)]), ("y", TypeRel [("a",TypeAny)])] }
--   </pre>
headNests :: [TermName] -> Map Head

-- | Term whose content is type.
type TypeTerm = Term Type

-- | Reconstruct head.
--   
--   <pre>
--   &gt;&gt;&gt; headMap reverse $ headFrom ["a", "b"]
--   Head {headType = TypeRel [("b",TypeAny),("a",TypeAny)]}
--   </pre>
headMap :: Map [TypeTerm] -> Map Head

-- | Convert term names.
--   
--   <pre>
--   &gt;&gt;&gt; headMapName ("x" ++) $ headFrom ["a", "b"]
--   Head { headType = TypeRel [("xa",TypeAny), ("xb",TypeAny)] }
--   </pre>
headMapName :: Map TermName -> Map Head

-- | Move up nested relation.
headUp :: Map Head

-- | Move terms forward.
--   
--   <pre>
--   &gt;&gt;&gt; headForward ["c"] ["a", "b", "c"] ["x", "y", "z"]
--   ["z", "y", "x"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headForward (headFrom ["a", "b"]) (headFrom ["b", "a"]) ["x", "y"]
--   ["y", "x"]
--   </pre>
headForward :: (GetTermNames t1, GetTermNames t2) => t1 -> t2 -> Map [c]

-- | Move terms forward.
bodyForward :: (GetTermNames t1, GetTermNames t2) => t1 -> t2 -> Map [[c]]
instance GHC.Classes.Ord Koshucode.Baala.Type.Rel.Head.Head
instance GHC.Classes.Eq Koshucode.Baala.Type.Rel.Head.Head
instance GHC.Show.Show Koshucode.Baala.Type.Rel.Head.Head
instance GHC.Base.Monoid Koshucode.Baala.Type.Rel.Head.Head
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTermNames Koshucode.Baala.Type.Rel.Head.Head
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode Koshucode.Baala.Type.Rel.Head.Head


-- | Relation type
module Koshucode.Baala.Type.Rel.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Head -> Body c -> Rel c

-- | Heading of relation
[relHead] :: Rel c -> Head

-- | Body of relation
[relBody] :: Rel c -> Body c

-- | Body of relation, i.e., a list of tuples. Tuple is a list of contents.
type Body c = [[c]]

-- | Relation with judgement class.
data JudgeRel c
JudgeRel :: JudgeClass -> (Rel c) -> JudgeRel c

-- | Sort head and body of relation.
relSort :: (Ord c) => Map (Rel c)

-- | Sort relation body according to order specification.
relBodyOrder :: (Ord c) => [TermName] -> Head -> Map [[c]]

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldum :: Rel Bool)
--   {= =}
--   </pre>
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldee :: Rel Bool)
--   {= [] =}
--   </pre>
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c

-- | Type for having relations.
class SelectRel r where selectJudgeRel r cl ns = JudgeRel cl $ selectRel r cl ns

-- | Convert judges to relation.
selectRel :: (SelectRel r, Ord c, Default c) => r c -> RelSelect c

-- | Convert judges to judgemental relation.
selectJudgeRel :: (SelectRel r, Ord c, Default c) => r c -> JudgeRelSelect c

-- | Select relation.
type RelSelect c = JudgeClass -> [TermName] -> Rel c

-- | Select judgemental relation.
type JudgeRelSelect c = JudgeClass -> [TermName] -> JudgeRel c

-- | Convert relation to list of judges.
judgesFromRel :: JudgeOf c -> JudgeClass -> Rel c -> [Judge c]
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Type.Rel.Rel.JudgeRel c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Type.Rel.Rel.JudgeRel c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Type.Rel.Rel.JudgeRel c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Type.Rel.Rel.Rel c)
instance GHC.Base.Functor Koshucode.Baala.Type.Rel.Rel.Rel
instance Koshucode.Baala.Type.Judge.JudgeClass.GetTermNames (Koshucode.Baala.Type.Rel.Rel.Rel c)
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode c => Koshucode.Baala.Base.MixText.MixEncode.MixEncode (Koshucode.Baala.Type.Rel.Rel.Rel c)


-- | Content type for nested relations.
module Koshucode.Baala.Type.Rel.Mono

-- | Content type for monotype relation.
data Mono c

-- | Terminal content
MonoTerm :: c -> Mono c

-- | Nested relation
MonoNest :: (RelMono c) -> Mono c

-- | Monotype relation.
type RelMono c = Rel (Mono c)

-- | Text relation.
type RelText = RelMono String

-- | Test terminal content.
isMonoTerm :: Mono c -> Bool

-- | Test nested relation.
isMonoNest :: Mono c -> Bool

-- | Get terminal content.
gMonoTerm :: Mono c -> c

-- | Get nested relation.
gMonoNest :: Mono c -> RelMono c

-- | Put terminal content.
pMonoTerm :: c -> Mono c

-- | Put nested relation.
pMonoNest :: RelMono c -> Mono c
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Type.Rel.Mono.Mono c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Type.Rel.Mono.Mono c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Type.Rel.Mono.Mono c)


-- | Relation type.
module Koshucode.Baala.Type.Rel


-- | Decimal number type.
module Koshucode.Baala.Type.Decimal


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Type
