-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.193.0.0


-- | Result of relational calculation.
module Koshucode.Baala.Core.Relmap.Result

-- | Result of calculation.
data Result c
Result :: ResultWriter c -> Bool -> Bool -> Int -> Int -> [InputPoint] -> IOPoint -> [[String]] -> [[String]] -> [ShortResultChunks c] -> [ShortResultChunks c] -> [JudgeClass] -> Result c
[resultWriter] :: Result c -> ResultWriter c
[resultPrintHead] :: Result c -> Bool
[resultPrintFoot] :: Result c -> Bool
[resultGutter] :: Result c -> Int
[resultMeasure] :: Result c -> Int
[resultInput] :: Result c -> [InputPoint]
[resultOutput] :: Result c -> IOPoint
[resultEcho] :: Result c -> [[String]]
[resultLicense] :: Result c -> [[String]]
[resultViolated] :: Result c -> [ShortResultChunks c]
[resultNormal] :: Result c -> [ShortResultChunks c]
[resultClass] :: Result c -> [JudgeClass]

-- | Input point of data resource.
data InputPoint
InputPoint :: IOPoint -> [Tree] -> InputPoint

-- | Input point
[inputPoint] :: InputPoint -> IOPoint

-- | Common terms
[inputPointAbout] :: InputPoint -> [Tree]

-- | Chunk of judgements.
data ResultChunk c

-- | List of judges
ResultJudge :: [Judge c] -> ResultChunk c

-- | Named relation instead of judges
ResultRel :: JudgeClass -> (Rel c) -> ResultChunk c

-- | Commentary note
ResultNote :: [String] -> ResultChunk c

-- | Short block in result.
type ShortResultChunks c = Short [ResultChunk c]

-- | Writer of calculation result.
data ResultWriter c

-- | Write from result
ResultWriterRaw :: String -> (ResultWriterRaw c) -> ResultWriter c

-- | Write from short chunks
ResultWriterChunk :: String -> (ResultWriterChunk c) -> ResultWriter c

-- | Write from judges
ResultWriterJudge :: String -> (ResultWriterJudge c) -> ResultWriter c

-- | Type of result writer function.
type ResultWriterFrom d c = Handle -> Result c -> ExitCode -> d -> IO ExitCode

-- | Write result based on result itself.
type ResultWriterRaw c = ResultWriterFrom () c

-- | Write result based on its short chunks.
type ResultWriterChunk c = ResultWriterFrom [ShortResultChunks c] c

-- | Write result based on its judges.
type ResultWriterJudge c = ResultWriterFrom [Judge c] c

-- | Dump result.
resultDump :: (Show c) => ResultWriter c

-- | Print calculation result.
putResult :: Result c -> IO ExitCode

-- | Print result of calculation, and return status.
hPutResult :: Handle -> Result c -> IO ExitCode
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Core.Relmap.Result.Result c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Core.Relmap.Result.Result c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Core.Relmap.Result.Result c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Core.Relmap.Result.ResultChunk c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Core.Relmap.Result.ResultChunk c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Core.Relmap.Result.ResultChunk c)
instance GHC.Classes.Ord Koshucode.Baala.Core.Relmap.Result.InputPoint
instance GHC.Classes.Eq Koshucode.Baala.Core.Relmap.Result.InputPoint
instance GHC.Show.Show Koshucode.Baala.Core.Relmap.Result.InputPoint
instance GHC.Show.Show c => Data.Default.Class.Default (Koshucode.Baala.Core.Relmap.Result.Result c)
instance GHC.Show.Show (Koshucode.Baala.Core.Relmap.Result.ResultWriter c)
instance Koshucode.Baala.Syntax.Token.Token.SubtypeName (Koshucode.Baala.Core.Relmap.Result.ResultWriter c)
instance GHC.Classes.Ord (Koshucode.Baala.Core.Relmap.Result.ResultWriter c)
instance GHC.Classes.Eq (Koshucode.Baala.Core.Relmap.Result.ResultWriter c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Core.Relmap.Result.ResultWriter c)


-- | Lexmap trees
module Koshucode.Baala.Core.Lexmap.LexmapTrees

-- | Tree representation of lexmap.
data LexmapTrees
LexmapTrees :: [Tree] -> TTreePara -> AttrEd -> LexmapTrees

-- | Positional attribute.
[lexmapTrees] :: LexmapTrees -> [Tree]

-- | Parameter
[lexmapPara] :: LexmapTrees -> TTreePara

-- | Attribute editor
[lexmapAttrEd] :: LexmapTrees -> AttrEd

-- | Construct lexmap tree.
consLexmapTrees :: TTreePara -> Ab LexmapTrees

-- | Token tree parameter.
type TTreePara = SimplePara Tree

-- | Make token tree parameter with single-hyphen names.
ttreePara1 :: [Token] -> Ab TTreePara

-- | Make token tree parameter with double-hyphen names.
ttreePara2 :: [Token] -> Ab TTreePara
instance GHC.Classes.Ord Koshucode.Baala.Core.Lexmap.LexmapTrees.LexmapTrees
instance GHC.Classes.Eq Koshucode.Baala.Core.Lexmap.LexmapTrees.LexmapTrees
instance GHC.Show.Show Koshucode.Baala.Core.Lexmap.LexmapTrees.LexmapTrees


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap.Lexmap

-- | Intermediate data that represents use of relmap operator. Lexmap is
--   constructed from a list of <a>TTree</a>, and generic relmap is
--   constructed from a lexmap.
data Lexmap
Lexmap :: LexmapType -> Token -> AttrPara -> [(String, Lexmap)] -> [String] -> Lexmap

-- | Type of lexmap
[lexType] :: Lexmap -> LexmapType

-- | Token of operator
[lexToken] :: Lexmap -> Token

-- | Attribute of relmap operation
[lexAttr] :: Lexmap -> AttrPara

-- | Submaps in the attribute
[lexSubmap] :: Lexmap -> [(String, Lexmap)]

-- | Messages on lexmap
[lexMessage] :: Lexmap -> [String]

-- | Type of lexmap.
data LexmapType

-- | Relmap of built-in operator
LexmapBase :: LexmapType

-- | Derived or user-defined relmap
LexmapDerived :: LexmapType

-- | Local relation reference like <tt>^/r</tt> or <tt>^r</tt>
LexmapLocal :: LexmapType

-- | Name of relmap operator.
type RopName = String

-- | Name of relmap operator
lexName :: Lexmap -> RopName

-- | Lexmap local reference.
lexLocalRef :: Lexmap -> Maybe LocalRef

-- | Add message to lexmap.
lexAddMessage :: String -> Map Lexmap

-- | Get message list from lexmap.
lexMessageList :: Lexmap -> [String]

-- | Attribute of relmap operation.
lexAttrTree :: Lexmap -> [AttrTree]
instance GHC.Classes.Ord Koshucode.Baala.Core.Lexmap.Lexmap.Lexmap
instance GHC.Classes.Eq Koshucode.Baala.Core.Lexmap.Lexmap.Lexmap
instance GHC.Show.Show Koshucode.Baala.Core.Lexmap.Lexmap.Lexmap
instance GHC.Classes.Ord Koshucode.Baala.Core.Lexmap.Lexmap.LexmapType
instance GHC.Classes.Eq Koshucode.Baala.Core.Lexmap.Lexmap.LexmapType
instance GHC.Show.Show Koshucode.Baala.Core.Lexmap.Lexmap.LexmapType
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos Koshucode.Baala.Core.Lexmap.Lexmap.Lexmap
instance Data.Default.Class.Default Koshucode.Baala.Core.Lexmap.Lexmap.Lexmap


-- | Convert relation to text table.
module Koshucode.Baala.Core.Assert.RelTable

-- | Render relation in table layout.
relTable :: (CRel c, MixEncode c) => [ShortDef] -> Rel c -> String

-- | Render relation in table layout.
relTableLines :: (CRel c, MixEncode c) => [ShortDef] -> Rel c -> [String]

-- | Convert contents of relation into strings.
relText :: (CRel c, MixEncode c) => [ShortDef] -> Rel c -> RelText


-- | Message list.
module Koshucode.Baala.Core.Resource.Message

-- | Abortable scope for clause.
abClause :: (GetCodePos cp) => Abortable cp b

-- | Duplicate prefix
dupPrefix :: [String] -> Ab a

-- | Duplicate replacement
dupReplacement :: [String] -> Ab a

-- | HTTP Error
httpError :: String -> Int -> String -> Ab a

-- | Invalid prefix character
invalidPrefix :: [String] -> Ab a

-- | File not found
noFile :: FilePath -> String -> Ab a

-- | Same I/O points
sameIOPoints :: IOPoint -> Ab a

-- | Unknown clause
unkClause :: [String] -> Ab a

-- | Unresolved prefix
unresPrefix :: String -> Ab a


-- | Message list.
module Koshucode.Baala.Core.Relmap.Message

-- | Abortable scope for option.
abOption :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for relmap.
abRelmap :: (GetCodePos cp) => Abortable cp b

-- | Abortable scope for specialization.
abSpecialize :: (GetCodePos cp) => Abortable cp b

-- | Unknown nested relation reference.
unkNestVar :: String -> [Token] -> [((Token, LocalRef), Head)] -> Ab a

-- | Disabled feature: input clause
disabledInputClause :: Ab b

-- | Disabled feature: output clause
disabledOutputClause :: Ab b


-- | Assertion options.
module Koshucode.Baala.Core.Relmap.Option

-- | Option type.
type Option c = Map String (OptionContent c)

-- | Content of assertion option.
data OptionContent c
OptionBool :: Bool -> OptionContent c
OptionChar :: [Char] -> Char -> OptionContent c
OptionTerms :: [TermName] -> OptionContent c

-- | Option set.
option :: (CBool c, CText c) => Option c

-- | Get boolean option value.
optionBool :: String -> Option c -> Bool

-- | Parse assertion option.
optionParse :: (Eq c, CBool c, CText c) => CalcContent c -> [Token] -> AbMap (Option c)
instance GHC.Classes.Ord (Koshucode.Baala.Core.Relmap.Option.OptionContent c)
instance GHC.Classes.Eq (Koshucode.Baala.Core.Relmap.Option.OptionContent c)
instance GHC.Show.Show (Koshucode.Baala.Core.Relmap.Option.OptionContent c)


-- | Message list.
module Koshucode.Baala.Core.Relkit.Message

-- | Abortable scope for running relkit.
abRun :: (GetCodePos cp) => Abortable cp b

-- | Unknown local relation
unkLocalRel :: Token -> String -> [String] -> Ab a


-- | Message list.
module Koshucode.Baala.Core.Lexmap.Message

-- | Abortable scope for lexmap.
abLexmap :: (GetCodePos cp) => Abortable cp b

-- | Ambiguous relmaps
ambRelmap :: String -> [d] -> Ab a

-- | Require grouping paren
reqGroup :: Ab a

-- | Unknown relmap operator
unkRelmap :: String -> Ab a


-- | Construction of lexical relmaps.
module Koshucode.Baala.Core.Lexmap.Construct

-- | First step of constructing relmap, construct lexmap from token trees.
--   The function returns lexmap and related lexmap links.
consLexmap :: RopParaze -> ConsLexmap

-- | Construct lexmap.
type ConsLexmap = [GlobalSlot] -> FindDeriv -> SecNo -> ConsLexmapBody

-- | Find derived relmap operator.
type FindDeriv = SecNo -> RopName -> [LexmapClause]

-- | Source of relmap: its name, replacement, and attribute editor.
type LexmapClause = NNamed LexmapTrees

-- | Find parameterizer for relmap operator.
type RopParaze = RopName -> Maybe AttrParaze

-- | Construct lexmap from token trees.
type ConsLexmapBody = [Tree] -> Ab (Lexmap, LexmapLinkTable)

-- | Lexmap and linked lexmap.
type LexmapLinkTable = [(Lexmap, Lexmap)]

-- | Section number.
type SecNo = Int

-- | Numbered name.
type NName = (SecNo, String)

-- | Pair which key is a numbered name.
type NNamed a = (NName, a)


-- | Message list.
module Koshucode.Baala.Core.Assert.Message

-- | Abortable scope for assertion.
abAssert :: (GetCodePos cp) => Abortable cp b

-- | Unknown option
unkOption :: ParaUnmatch String -> Ab a


-- | Bundle of message modules.
module Koshucode.Baala.Core.Message


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relkit.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Head -> Maybe Head -> RelkitBody c -> Relkit c

-- | Input heading
[relkitInput] :: Relkit c -> Maybe Head

-- | Output heading
[relkitOutput] :: Relkit c -> Maybe Head

-- | Calculation function
[relkitBody] :: Relkit c -> RelkitBody c

-- | Relkit of output heading and its body.

-- | Body of relkit.
type RelkitBody c = Codic (RelkitCore c)

-- | Calculation of relation-to-relation mapping.
data RelkitCore c

-- | <b>Safe flow:</b> Arbitrary relation mapping, i.e., mapping from
--   multiple tuples to multiple tuples.
RelkitWhole :: Bool -> (Flow [[c]] [[c]]) -> RelkitCore c

-- | <b>Safe flow:</b> Mapping from single tuple to multiple tuples,
--   include no tuples.
RelkitMany :: Bool -> (Flow [c] [[c]]) -> RelkitCore c

-- | <b>Safe flow:</b> Mapping from single tuple to single tuple.
RelkitLine :: Bool -> (Flow [c] [c]) -> RelkitCore c

-- | <b>Safe flow:</b> Filter tuples
RelkitTest :: (Test [c]) -> RelkitCore c

-- | <b>Abortable flow:</b> Filter by calculation.
RelkitAbTest :: (AbTest [c]) -> RelkitCore c

-- | <b>Abortable confluence:</b> Filter by data.
RelkitAbSemi :: (AbTest [[c]]) -> (RelkitBody c) -> RelkitCore c

-- | <b>Abortable confluence:</b> Multiple to multiple.
RelkitAbWhole :: Bool -> (Confl c [[c]] [[c]]) -> [RelkitBody c] -> RelkitCore c

-- | <b>Abortable confluence:</b> Single to multiple.
RelkitAbMany :: Bool -> (Confl c [c] [[c]]) -> [RelkitBody c] -> RelkitCore c

-- | <b>Abortable confluence:</b> Single to single.
RelkitAbLine :: Bool -> (Confl c [c] [c]) -> [RelkitBody c] -> RelkitCore c

-- | <b>Connection:</b> Append two mapping.
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c

-- | <b>Connection:</b> Identity mapping, i.e., output input relation
--   without modification.
RelkitId :: RelkitCore c

-- | <b>Source:</b> Ignore input, and output constant relation.
RelkitConst :: [[c]] -> RelkitCore c

-- | <b>Source:</b> Ignore input, and output relation from data source.
RelkitSource :: JudgeClass -> [TermName] -> RelkitCore c

-- | <b>Reference:</b> Link point to other relmap.
RelkitLink :: RopName -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c

-- | <b>Reference:</b> Give indecies to nested relations.
RelkitNest :: Token -> [IndexTerm] -> (RelkitBody c) -> RelkitCore c

-- | <b>Reference:</b> Give a name to input relation.
RelkitCopy :: Token -> RopName -> (RelkitBody c) -> RelkitCore c

-- | <b>Reference:</b> Local relation reference, i.e., <tt>^/r</tt> or
--   <tt>^r</tt>.
RelkitLocal :: Token -> LocalRef -> RelkitCore c

-- | Relkit search table.
type RelkitTable c = [(RelkitKey, Relkit c)]

-- | Search key of relkit.
type RelkitKey = (Maybe Head, [Lexmap])

-- | Flow mapping.
type Flow from to = from -> to

-- | Abortable flow mapping.
type FlowAb from to = from -> Ab to

-- | Confluent mapping.
type Confl c from to = [BodyMap c] -> from -> Ab to

-- | Mapping for body of relation.
type BodyMap c = AbMap [[c]]

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitFlow c = Maybe Head -> Ab (Relkit c)

-- | Make <a>Relkit</a> from hook data and input heading.
type RelkitHook' h c = h c -> RelkitFlow c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitFlow c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [Relkit c] -> RelkitFlow c
instance GHC.Show.Show (Koshucode.Baala.Core.Relkit.Relkit.RelkitCore c)


-- | Relkit constructors.
module Koshucode.Baala.Core.Relkit.Construct

-- | Construct relkit with output heading and relation-to-relation
--   calculation.
relkit :: Maybe Head -> RelkitCore c -> Relkit c

-- | Relkit for identity relmap.
relkitId :: Maybe Head -> Relkit c

-- | Indeterminate relkit. This is used when input heading is
--   indeterminate, therefore output heading cannot be determinate.
relkitUnfixed :: Ab (Relkit c)

-- | Set relkit code position.
relkitSetCp :: (GetCodePos cp) => cp -> Map (Relkit c)

-- | Create non-abortble one-to-one (linear) relkit.
relkitLine :: Bool -> Head -> Flow [c] [c] -> Relkit c

-- | Create non-abortble one-to-many relkit.
relkitMany :: Bool -> Head -> Flow [c] [[c]] -> Relkit c

-- | Create non-abortble whole-mapping relkit.
relkitWhole :: Bool -> Head -> Flow [[c]] [[c]] -> Relkit c

-- | Create abortable one-to-one (linear) relkit.
relkitLineAb :: Bool -> Head -> FlowAb [c] [c] -> Relkit c

-- | Create abortable one-to-many relkit.
relkitManyAb :: Bool -> Head -> FlowAb [c] [[c]] -> Relkit c

-- | Create abortable whole-mapping relkit.
relkitWholeAb :: Bool -> Head -> FlowAb [[c]] [[c]] -> Relkit c

-- | Create abortable filtering relkit.
relkitFilterAb :: Head -> AbTest [c] -> Relkit c

-- | Create abortable one-to-one (linear) confluent relkit.
relkitConflLine :: Bool -> Head -> Confl c [c] [c] -> [RelkitBody c] -> Relkit c

-- | Create abortable one-to-many confluent relkit.
relkitConflMany :: Bool -> Head -> Confl c [c] [[c]] -> [RelkitBody c] -> Relkit c

-- | Create abortable whole-mapping confluent relkit.
relkitConflWhole :: Bool -> Head -> Confl c [[c]] [[c]] -> [RelkitBody c] -> Relkit c

-- | Create abortable confluent filtering relkit.
relkitConflFilter :: Head -> AbTest [[c]] -> RelkitBody c -> Relkit c

-- | Relkit for constant relmap.
relkitConst :: Head -> [[c]] -> Relkit c

-- | Relkit outputs constant relation.
relkitConstRel :: Rel c -> Relkit c

-- | Relkit for relmap which output empty relation.
relkitConstEmpty :: [TermName] -> Relkit c

-- | Relkit for relmap which outputs singleton relation.
relkitConstSingleton :: [TermName] -> [c] -> Relkit c

-- | Relkit for constant relmap.
relkitConstBody :: [TermName] -> [[c]] -> Relkit c

-- | Relkit for source relmap.
relkitSource :: JudgeClass -> Head -> Relkit c

-- | Relkit with nested relation index.
relkitNest :: Token -> [IndexTerm] -> Map (Relkit c)

-- | Relkit for copy relmap.
relkitCopy :: Token -> String -> Map (Relkit c)

-- | Relkit for local relation reference.
relkitLocal :: Token -> LocalRef -> Head -> Relkit c
instance GHC.Base.Monoid (Koshucode.Baala.Core.Relkit.Relkit.Relkit c)


-- | Link and run relmaps.
module Koshucode.Baala.Core.Relkit.Run

-- | Resolve relmap reference.
relkitLink :: (Ord c) => RelkitTable c -> Map (Relkit c)

-- | Run relkit.
relkitRun :: (CContent c, SelectRel h) => h c -> [LocalTable c] -> RelkitBody c -> AbMap [[c]]

-- | Calculate fixed relation.
fixedRelation :: (Ord c) => Map (AbMap [[c]])

-- | Change term order.
bmapAlign :: Head -> Head -> Map (AbMap [[c]])

-- | Lexical point and table of local relations.

-- | <i>Warning: This is only used in defined module.</i>
type LocalTable c = (Token, [(LocalRef, [[c]])])


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relkit


-- | Generic relmap.
module Koshucode.Baala.Core.Relmap.Relmap

-- | Generic relmap.
data Relmap' h c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap' h c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgeClass -> [TermName] -> Relmap' h c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap' h c] -> Relmap' h c

-- | Relmap that maps relations to a relation with hook data
RelmapHook :: Lexmap -> (RelkitHook' h c) -> Relmap' h c

-- | Relmap for environment of input relation
RelmapCopy :: Lexmap -> String -> (Relmap' h c) -> Relmap' h c

-- | Relmap for environment of nested relations
RelmapNest :: Lexmap -> (Relmap' h c) -> Relmap' h c

-- | Relmap reference
RelmapLink :: Lexmap -> Relmap' h c

-- | Connect two relmaps
RelmapAppend :: (Relmap' h c) -> (Relmap' h c) -> Relmap' h c

-- | Identity relmap.
relmapId :: Relmap' h c

-- | Extract lexmap list from relmap.
relmapLexmaps :: Relmap' h c -> [Lexmap]

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap' h c -> [Relmap' h c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap' h c -> [String]
instance GHC.Show.Show (Koshucode.Baala.Core.Relmap.Relmap.Relmap' h c)
instance GHC.Classes.Ord (Koshucode.Baala.Core.Relmap.Relmap.Relmap' h c)
instance GHC.Classes.Eq (Koshucode.Baala.Core.Relmap.Relmap.Relmap' h c)
instance GHC.Base.Monoid (Koshucode.Baala.Core.Relmap.Relmap.Relmap' h c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Core.Relmap.Relmap.Relmap' h c)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Core.Relmap.Relmap.Relmap' h c)


-- | Relmap operators.
module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator.
data Rop' h c
Rop :: RopName -> RopGroup -> AttrLayout -> AttrParaze -> RopCons' h c -> Rop' h c

-- | Operator name
[ropName] :: Rop' h c -> RopName

-- | Operator group
[ropGroup] :: Rop' h c -> RopGroup

-- | Attribute of operator
[ropAttr] :: Rop' h c -> AttrLayout

-- | Attribute parameterizer
[ropParaze] :: Rop' h c -> AttrParaze

-- | Constructor of operator
[ropCons] :: Rop' h c -> RopCons' h c

-- | Group of operators.
type RopGroup = String

-- | Find relmap operator based on its name.
type FindRop' h c = RopName -> Maybe (Rop' h c)

-- | Usage text of relmap operator.
ropUsage :: Rop' h c -> String

-- | Constructor of relmap operator, i.e., function from intermediate
--   relamp to generic relmap.
type RopCons' h c = Intmed' h c -> Ab (Relmap' h c)

-- | Intermediate relmap, that is in between lexmap and generic relmap.
data Intmed' h c
Intmed :: h c -> Lexmap -> [(String, Relmap' h c)] -> Intmed' h c
[medHook] :: Intmed' h c -> h c

-- | Syntactic data of operator use
[medLexmap] :: Intmed' h c -> Lexmap

-- | Subrelmaps
[medSubmap] :: Intmed' h c -> [(String, Relmap' h c)]
instance GHC.Show.Show (h c) => GHC.Show.Show (Koshucode.Baala.Core.Relmap.Rop.Intmed' h c)
instance GHC.Show.Show (Koshucode.Baala.Core.Relmap.Rop.Rop' h c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Core.Relmap.Rop.Rop' h c)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Core.Relmap.Rop.Intmed' h c)


-- | Construction of relmaps.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make a constant relmap.
relmapConst :: Intmed' h c -> Rel c -> Relmap' h c

-- | Relmap for retrieving relation from dataset.
relmapSource :: Intmed' h c -> JudgeClass -> [TermName] -> Relmap' h c

-- | Make a flow relmap. Flow relmaps take no submaps.
relmapFlow :: Intmed' h c -> RelkitFlow c -> Relmap' h c

-- | Relmap with hook data.
relmapHook :: Intmed' h c -> RelkitHook' h c -> Relmap' h c

-- | Make a binary relmap. Binary relmaps take one submap.
relmapBinary :: Intmed' h c -> RelkitBinary c -> Relmap' h c -> Relmap' h c

-- | Make a confluent relmap. Confluent relmaps take multiple submaps.
relmapConfl :: Intmed' h c -> RelkitConfl c -> [Relmap' h c] -> Relmap' h c

-- | Link-to-other relmap.
relmapLink :: Intmed' h c -> Relmap' h c

-- | Reference base of nested relation references. This base is refered by
--   <a>relmapLocalNest</a>.
relmapNest :: Intmed' h c -> Map (Relmap' h c)

-- | Relation reference for nested relation.
relmapLocalNest :: Intmed' h c -> TermName -> Relmap' h c

-- | Reference base of copy-of-input relation reference. This base is
--   refered by <a>relmapLocalSymbol</a>.
relmapCopy :: Intmed' h c -> RopName -> Map (Relmap' h c)

-- | Relation reference for locally introduced relation.
relmapLocalSymbol :: Intmed' h c -> RopName -> Relmap' h c

-- | Second step of constructing relmap, make relmap from lexmap.
type ConsRelmap' h c = Lexmap -> Ab (Relmap' h c)

-- | Construct relmap from lexmap.
consRelmap :: FindRop' h c -> h c -> ConsRelmap' h c


-- | Global parameters.
module Koshucode.Baala.Core.Relmap.Global

-- | Global parameters
data Global' h c
Global :: String -> Version -> OpSet' h c -> Feature -> String -> [String] -> [HttpProxy] -> Time -> Result c -> Option c -> Int -> Int -> [IxIOPoint] -> h c -> Global' h c

-- | One-line description of calculator
[globalSynopsis] :: Global' h c -> String

-- | Version of calculator
[globalVersion] :: Global' h c -> Version

-- | Set of operators
[globalOpset] :: Global' h c -> OpSet' h c

-- | Features
[globalFeature] :: Global' h c -> Feature

-- | Name of invoked program
[globalProgram] :: Global' h c -> String

-- | Command line arguments
[globalArgs] :: Global' h c -> [String]

-- | Proxy setting from environment variables
[globalProxy] :: Global' h c -> [HttpProxy]

-- | Invocation time
[globalTime] :: Global' h c -> Time

-- | Result template
[globalResult] :: Global' h c -> Result c

-- | Options
[globalOption] :: Global' h c -> Option c

-- | Limit number of including sources
[globalSourceLimit] :: Global' h c -> Int

-- | Sequential number for sources
[globalSourceCount] :: Global' h c -> Int

-- | Included sources
[globalSources] :: Global' h c -> [IxIOPoint]

-- | Usually, data resource is used as hook
[globalHook] :: Global' h c -> h c

-- | Textual representation of version number.
globalVersionText :: Global' h c -> String

-- | Command line text, i.e., program name and arguments.
globalCommandLine :: Global' h c -> [String]

-- | Make complete global parameter by filling auto-generated part.
globalFill :: (CContent c) => Map (Global' h c)

-- | List of relmap operators.
globalRops :: Global' h c -> [Rop' h c]

-- | Add relmap operators.
globalRopsAdd :: [Rop' h c] -> Map (Global' h c)

-- | List of content operators.
globalCops :: Global' h c -> [Cop c]

-- | Set of content operators.
globalCopset :: Global' h c -> CopSet c

-- | List of settings of infix operators.
globalInfix :: Global' h c -> [Named InfixHeight]

-- | Abort with command line.
globalAbort :: Global' h c -> AbortReason -> IO a

-- | Empty global parameters.
global' :: (Show c, CBool c, CText c) => h c -> Global' h c

-- | Type which has global parameter.
class GetGlobal' h

-- | Get global parameter.
getGlobal' :: GetGlobal' h => h c -> Global' h c

-- | Type which has global parameter.
class GetGlobal a

-- | Get global parameter.
getGlobal :: (GetGlobal a, GetGlobal' h) => a h c -> Global' h c

-- | Get operator set from <tt>Intmed</tt>.
ropCopset :: (GetGlobal' h) => Intmed' h c -> CopSet c

-- | Set of relmap and content operators.
data OpSet' h c
OpSet :: [Rop' h c] -> FindRop' h c -> CopSet c -> OpSet' h c

-- | Relmap operators.
[opsetRopList] :: OpSet' h c -> [Rop' h c]

-- | Operator finder.
[opsetFindRop] :: OpSet' h c -> FindRop' h c

-- | Content operators.
[opsetCop] :: OpSet' h c -> CopSet c

-- | Make complete operator set by filling auto-generated part.
opsetFill :: Map (OpSet' h c)

-- | Enable or disable featrues.
data Feature
Feature :: Bool -> Bool -> Bool -> Feature

-- | Enable <tt>input</tt> clause
[featInputClause] :: Feature -> Bool

-- | Enable <tt>output</tt> clause
[featOutputClause] :: Feature -> Bool

-- | Automatic output when no assertions.
[featAutoOutput] :: Feature -> Bool
instance GHC.Classes.Ord Koshucode.Baala.Core.Relmap.Global.Feature
instance GHC.Classes.Eq Koshucode.Baala.Core.Relmap.Global.Feature
instance GHC.Show.Show Koshucode.Baala.Core.Relmap.Global.Feature
instance GHC.Show.Show (Koshucode.Baala.Core.Relmap.Global.Global' h c)
instance Koshucode.Baala.Core.Relmap.Global.GetGlobal Koshucode.Baala.Core.Relmap.Rop.Intmed'
instance Data.Default.Class.Default (Koshucode.Baala.Core.Relmap.Global.OpSet' h c)
instance Data.Default.Class.Default Koshucode.Baala.Core.Relmap.Global.Feature


-- | Specialize generic relmaps. Generic relmaps are represented by
--   <a>Relmap</a>, specialized relmaps by <a>Relkit</a>.
module Koshucode.Baala.Core.Relmap.Specialize

-- | Specializes generic relmap to specialized relmap. Specialized relmaps
--   have fixed input/output headings. In constrast, generic relmaps do
--   not. Specialized relmaps are also called relkits. This function
--   returns relkit and extended table of relkits.
relmapSpecialize :: h c -> RelmapLinkTable' h c -> RelkitTable c -> Maybe Head -> Relmap' h c -> Ab (RelkitTable c, Relkit c)

-- | Table for referencing relmap of <a>RelmapLink</a>.
type RelmapLinkTable' h c = [(Lexmap, Relmap' h c)]


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert' h c
Assert :: SecNo -> AssertType -> JudgeClass -> [Token] -> TTreePara -> Maybe (Relmap' h c) -> RelmapLinkTable' h c -> Assert' h c

-- | Section number
[assSection] :: Assert' h c -> SecNo

-- | Logical quality
[assType] :: Assert' h c -> AssertType

-- | Judgement class
[assClass] :: Assert' h c -> JudgeClass

-- | Source token list
[assToken] :: Assert' h c -> [Token]
[assPara] :: Assert' h c -> TTreePara

-- | Relmap
[assRelmap] :: Assert' h c -> Maybe (Relmap' h c)
[assLinks] :: Assert' h c -> RelmapLinkTable' h c

-- | Assertion with short signs.
type ShortAssert' h c = Short (Assert' h c)

-- | Assertion list with short signs.
type ShortAsserts' h c = Short [Assert' h c]

-- | Select affirmative or denial assertions.
assertNormal :: Map [ShortAssert' h c]

-- | Select violated assertions.
assertViolated :: Map [ShortAssert' h c]
instance GHC.Show.Show (Koshucode.Baala.Core.Assert.Assert.Assert' h c)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Core.Assert.Assert.Assert' h c)


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, CContent c, SelectRel h, GetGlobal' h) => h c -> Option c -> ShortAsserts' h c -> Ab (ShortResultChunks c)


-- | Line-like token-level structure of source code.
module Koshucode.Baala.Core.Resource.Clause

-- | Line-like structure of source code.
data Clause
Clause :: ClauseHead -> ClauseBody -> Clause

-- | Common part of the clause.
[clauseHead] :: Clause -> ClauseHead

-- | Proper part of the clause.
[clauseBody] :: Clause -> ClauseBody

-- | Common part of clause.
data ClauseHead
ClauseHead :: SecNo -> [ShortDef] -> [Token] -> TokenClause -> ClauseHead

-- | Section number of the clause.
[clauseSecNo] :: ClauseHead -> SecNo

-- | Short setting.
[clauseShort] :: ClauseHead -> [ShortDef]

-- | About setting.
[clauseAbout] :: ClauseHead -> [Token]

-- | Source code of the clause.
[clauseSource] :: ClauseHead -> TokenClause

-- | Proper part of clause.
data ClauseBody

-- | <b>Relational:</b> Judge
CJudge :: AssertType -> JudgeClass -> [Token] -> ClauseBody

-- | <b>Relational:</b> Assertion
CAssert :: AssertType -> JudgeClass -> [Token] -> ClauseBody

-- | <b>Relational:</b> Source of relmap
CRelmap :: String -> [Token] -> ClauseBody

-- | <b>Relational:</b> Global slot
CSlot :: String -> [Token] -> ClauseBody

-- | <b>Resource:</b> Input point
CInput :: [Token] -> ClauseBody

-- | <b>Resource:</b> Output point
COutput :: [Token] -> ClauseBody

-- | <b>Resource:</b> Option settings
COption :: [Token] -> ClauseBody

-- | <b>Resource:</b> Exporting name
CExport :: String -> ClauseBody

-- | <b>Other:</b> Echo text
CEcho :: TokenClause -> ClauseBody

-- | <b>Other:</b> License text
CLicense :: String -> ClauseBody

-- | <b>Other:</b> Multiple bodies
CBodies :: [ClauseBody] -> ClauseBody

-- | <b>Other:</b> Unknown clause
CUnknown :: (Ab ()) -> ClauseBody

-- | Name of clause type. e.g., <tt>"relmap"</tt>, <tt>"assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <tt>TTokmap</tt> and <a>CAssert</a> are contained. This function does
--   not depend on <a>ConsLexmap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consClause . B.tokenize $ "a : source A /x /y"
--   [ TTokmap ( TokenClause
--                [TText 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TText 1 0 "a", ...]] )
--            "a" [ TText 5 0 "source"
--                , TText 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
--   
--   First step of constructing <tt>Resource</tt>.
consClause :: [Token] -> SecNo -> [TokenLine] -> [Clause]
instance GHC.Show.Show Koshucode.Baala.Core.Resource.Clause.Clause
instance GHC.Show.Show Koshucode.Baala.Core.Resource.Clause.ClauseBody
instance GHC.Show.Show Koshucode.Baala.Core.Resource.Clause.ClauseHead
instance Data.Default.Class.Default Koshucode.Baala.Core.Resource.Clause.ClauseHead
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos Koshucode.Baala.Core.Resource.Clause.Clause
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos Koshucode.Baala.Core.Resource.Clause.ClauseHead


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Internal representation of relational data resource. Data resource
--   bundles data themselves and calculation stuffs. In Koshucode, data is
--   represented as set of judgements, and calculation is as
--   relation-to-relation mapping. This internal representation is usually
--   constructed from computer files or web resources addressed by URI.
--   Result of calculation on some resource becomes also data resource.
module Koshucode.Baala.Core.Resource.Resource

-- | Relational data resource
data Resource c
Resource :: Global c -> SecNo -> CacheT -> Option c -> [String] -> [Resource c] -> InputQueue -> [Judge c] -> Dataset c -> [NamedTrees] -> [LexmapClause] -> [ShortAssert c] -> IOPoint -> [[TokenLine]] -> [(SecNo, String)] -> [String] -> Resource c

-- | <b>Global:</b> Global parameter
[resGlobal] :: Resource c -> Global c

-- | <b>Global:</b> Last section number
[resLastSecNo] :: Resource c -> SecNo

-- | <b>Global:</b> Term name cache
[resCacheT] :: Resource c -> CacheT

-- | <b>Setting:</b> Options
[resOption] :: Resource c -> Option c

-- | <b>Setting:</b> Exporting names
[resExport] :: Resource c -> [String]

-- | <b>Input:</b> Importing resources
[resImport] :: Resource c -> [Resource c]

-- | <b>Input:</b> Input points
[resInputQueue] :: Resource c -> InputQueue

-- | <b>Input:</b> Affirmative or denial judgements
[resJudge] :: Resource c -> [Judge c]

-- | <b>Input:</b> Dataset
[resDataset] :: Resource c -> Dataset c

-- | <b>Calc:</b> Global slots
[resSlot] :: Resource c -> [NamedTrees]

-- | <b>Calc:</b> Source of relmaps
[resLexmap] :: Resource c -> [LexmapClause]

-- | <b>Calc:</b> Assertions of relmaps
[resAssert] :: Resource c -> [ShortAssert c]

-- | <b>Output:</b> Output point
[resOutput] :: Resource c -> IOPoint

-- | <b>Output:</b> Echo text
[resEcho] :: Resource c -> [[TokenLine]]

-- | <b>Output:</b> License text
[resLicense] :: Resource c -> [(SecNo, String)]

-- | <b>Output:</b> Collection of messages
[resMessage] :: Resource c -> [String]

-- | Abort or resource.
type AbResource c = Ab (Resource c)

-- | Included sources, i.e., done-part of input queue.
resIncluded :: Resource c -> [IxIOPoint]

-- | <a>IOPoint</a> of all inputs.
resInput :: Resource c -> [IOPoint]

-- | All input points.
resInputPoint :: Resource c -> [InputPoint]

-- | List of all judgement classes.
resClass :: Resource c -> [JudgeClass]

-- | Get feature from resource.
resFeature :: Resource c -> Feature

-- | Add messages.
resMessagesAdd :: [String] -> Map (Resource c)

-- | Queue for input code: <i>todo</i>, <i>ready</i> and <i>done</i>.
type InputQueue = (Queue InputPoint, [IxIOPoint])

-- | Add input to todo-part of input queue.
resQueueTodo :: InputPoint -> Map (Resource c)

-- | Add input to done-part of input queue.
resQueueDone :: IxIOPoint -> Map (Resource c)

-- | Assertion of relation.
type Assert c = Assert' Resource c

-- | Relmap construction.
type ConsRelmap c = ConsRelmap' Resource c

-- | Global parameter.
type Global c = Global' Resource c

-- | Make relkit with data resource.
type RelkitHook c = RelkitHook' Resource c

-- | Generic relmap.
type Relmap c = Relmap' Resource c

-- | Lexmap-to-relmap table.
type RelmapLinkTable c = RelmapLinkTable' Resource c

-- | Relmap operator.
type Rop c = Rop' Resource c

-- | Constructor of relmap operator.
type RopCons c = RopCons' Resource c

-- | Intermediate relmap.
type Intmed c = Intmed' Resource c

-- | Assertion with short signs.
type ShortAssert c = ShortAssert' Resource c

-- | Assertion list with short signs.
type ShortAsserts c = ShortAsserts' Resource c

-- | Default global parameter.
global :: (CContent c) => Global c
instance GHC.Show.Show (Koshucode.Baala.Core.Resource.Resource.Resource c)
instance Koshucode.Baala.Type.Rel.Rel.SelectRel Koshucode.Baala.Core.Resource.Resource.Resource
instance Koshucode.Baala.Core.Relmap.Global.GetGlobal' Koshucode.Baala.Core.Resource.Resource.Resource
instance Koshucode.Baala.Data.Class.Content.CContent c => Data.Default.Class.Default (Koshucode.Baala.Core.Resource.Resource.Resource c)


-- | Concrete content type.
module Koshucode.Baala.Core.Resource.Concrete

-- | <tt>about</tt> clause.
data About c
About :: [Term c] -> About c

-- | Judges with about setting.
type AboutJudges c = (Maybe (About c), [Judge c])

-- | <tt>About</tt> for concrete baala content.
type AboutC = About Content

-- | <tt>AboutJudges</tt> for concrete baala content.
type AboutJudgesC = AboutJudges Content

-- | <tt>Global</tt> for concrete baala content.
type GlobalC = Global Content

-- | <tt>Resource</tt> for concrete baala content.
type ResourceC = Resource Content

-- | <tt>Result</tt> for concrete baala content.
type ResultC = Result Content

-- | <tt>ResultWriter</tt> for concrete baala content.
type ResultWriterC = ResultWriter Content
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Core.Resource.Concrete.About c)
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode c => Koshucode.Baala.Base.MixText.MixEncode.MixEncode (Koshucode.Baala.Core.Resource.Concrete.About c)


-- | Resource as bundle of relational expressions.
module Koshucode.Baala.Core.Resource.Include

-- | Include source code into resource.
resInclude :: (CContent c) => [Token] -> FilePath -> Resource c -> IxIOPoint -> Bz -> AbResource c


-- | Read data resource.
module Koshucode.Baala.Core.Resource.Read

-- | Read data resource from multiple input points.
resRead :: (CContent c) => Global c -> [IOPoint] -> IO (AbResource c, Global c)

-- | Read data resource from single input point.
resReadSingle :: (CContent c) => Global c -> IOPoint -> IO (AbResource c, Global c)

-- | Read data resource from lazy bytestring.
resReadBz :: (CContent c) => Resource c -> Bz -> AbResource c

-- | Read data resource from text.
resReadString :: (CContent c) => Resource c -> String -> AbResource c


-- | Run resource.
module Koshucode.Baala.Core.Resource.Run

-- | Run resource.
resRun :: (CContent c) => Resource c -> Ab (Result c)

-- | Assemble relmap of assert clause.
assembleRelmap :: AbMap (Resource c)

-- | Make a constructor pair of lexmap and relmap.
relmapCons :: (GetGlobal' h) => h c -> (ConsLexmap, ConsRelmap' h c)


-- | Runtime structure for calculations written in Koshucode.
--   <a>Resource</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Resource


-- | Bundle of core modules.
module Koshucode.Baala.Core
