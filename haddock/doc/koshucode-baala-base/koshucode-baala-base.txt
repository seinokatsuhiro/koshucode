-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.160.0.0


-- | Unicode general categories.
module Koshucode.Baala.Base.Text.Unicode

-- | Major category of the Unicode general categories.
data MajorGeneralCategory

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: MajorGeneralCategory

-- | Mn Mc Me
UnicodeMark :: MajorGeneralCategory

-- | Nd Nl No
UnicodeNumber :: MajorGeneralCategory

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: MajorGeneralCategory

-- | Sm Sc Sk So
UnicodeSymbol :: MajorGeneralCategory

-- | Zs Zl Zp
UnicodeSeperator :: MajorGeneralCategory

-- | Cc Cf Cs Co Cn
UnicodeOther :: MajorGeneralCategory

-- | Major general category of character.
majorGeneralCategory :: Char -> MajorGeneralCategory

-- | Convert general category to major category.
toMajorGeneralCategory :: GeneralCategory -> MajorGeneralCategory

-- | Name of general category. This function returns one of
--   <tt>letter</tt>, <tt>mark</tt>, <tt>number</tt>, <tt>punct</tt>,
--   <tt>symbol</tt>, <tt>sep</tt>, or <tt>other</tt>.
generalCategoryName :: MajorGeneralCategory -> String

-- | Major-minor category symbols like <tt>Lu</tt>.
generalCategoryLetter :: GeneralCategory -> String

-- | One-letter representation of general category. This function returns
--   one of <tt>L</tt> (letter), <tt>M</tt> (mark), <tt>N</tt> (number),
--   <tt>P</tt> (punctuation), <tt>S</tt> (symbol), <tt>Z</tt> (seperator),
--   or <tt>C</tt> (other).
generalCategoryMajorLetter :: MajorGeneralCategory -> Char

-- | One-letter representation of minor general category.
generalCategoryMinorLetter :: GeneralCategory -> Char
instance GHC.Enum.Bounded Koshucode.Baala.Base.Text.Unicode.MajorGeneralCategory
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Unicode.MajorGeneralCategory
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Unicode.MajorGeneralCategory
instance GHC.Show.Show Koshucode.Baala.Base.Text.Unicode.MajorGeneralCategory


-- | Line break setting for mix text.
module Koshucode.Baala.Base.Text.LineBreak

-- | Line break setting.
data LineBreak
LineBreak :: Maybe Int -> String -> String -> String -> LineBreak

-- | Max width of line.
[breakWidth] :: LineBreak -> Maybe Int

-- | Newline string.
[breakNewline] :: LineBreak -> String

-- | Newline string for breaking long line.
[breakContinue] :: LineBreak -> String

-- | Indent string for breaking long line.
[breakIndent] :: LineBreak -> String

-- | LF: <tt>"\n"</tt>
lfString :: String

-- | CRLF: <tt>"\r\n"</tt>
crlfString :: String

-- | Line break by single space.
noBreak :: LineBreak

-- | Line break by LF.
lfBreak :: LineBreak

-- | Line break by CRLF.
crlfBreak :: LineBreak

-- | Line break by LF with 2 spaces indent and given-length column.
lf2 :: Int -> LineBreak

-- | Line break by LF with 4 spaces indent and given-length column.
lf4 :: Int -> LineBreak

-- | Line break by LF with 8 spaces indent and given-length column.
lf8 :: Int -> LineBreak

-- | Line break by CRLF with 2 spaces indent and given-length column.
crlf2 :: Int -> LineBreak

-- | Line break by CRLF with 4 spaces indent and given-length column.
crlf4 :: Int -> LineBreak

-- | Line break by CRLF with 8 spaces indent and given-length column.
crlf8 :: Int -> LineBreak
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.LineBreak.LineBreak
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.LineBreak.LineBreak
instance GHC.Show.Show Koshucode.Baala.Base.Text.LineBreak.LineBreak
instance Data.Default.Class.Default Koshucode.Baala.Base.Text.LineBreak.LineBreak

module Koshucode.Baala.Base.Text.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec
emacsModeComment :: String
commentLine :: String -> String
putCommentLines :: [String] -> IO ()
hPutCommentLines :: Handle -> [String] -> IO ()
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Show.Show Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Comment.CommentSec
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Comment.CommentSec
instance GHC.Show.Show Koshucode.Baala.Base.Text.Comment.CommentSec
instance Koshucode.Baala.Base.Text.Comment.Texts Koshucode.Baala.Base.Text.Comment.CommentDoc
instance Koshucode.Baala.Base.Text.Comment.Texts Koshucode.Baala.Base.Text.Comment.CommentSec

module Koshucode.Baala.Base.Prelude.Import

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: Traversable t => forall (m :: * -> *) a. Monad m => t (m a) -> m (t a)

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | <tt><a>guard</a> b</tt> is <tt><a>pure</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>empty</a> if <tt>b</tt> is <a>False</a>.
guard :: Alternative f => Bool -> f ()
concatMapM :: (Monad m) => (a -> m [b]) -> [a] -> m [b]

-- | Strict bytestring.
type Bs = ByteString

-- | Lazy bytestring.
type Bz = ByteString

-- | Convert string into lazy bytestring.
stringBz :: String -> Bz
class Default a
def :: Default a => a

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | Same as <a>lookup</a> in <tt>Data.Map</tt> module.
lookupMap :: (Ord k) => k -> Map k a -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | Defines the exit codes that a program can return.
data ExitCode :: *

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as it it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is not an <a>IOError</a>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <tt>catch</tt> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc
docEmpty :: Doc
docHang :: Doc -> Int -> Doc -> Doc
docZero :: String -> Doc


-- | Queue.
module Koshucode.Baala.Base.Prelude.Queue

-- | First-in first-out list.
data Queue a

-- | Create queue from list.
qFrom :: [a] -> Queue a

-- | Convert queue to list.
qTo :: Queue a -> [a]

-- | Test queue is empty.
qNull :: Queue a -> Bool

-- | Number of elements in queue.
qLength :: Queue a -> Int

-- | Enqueue element.
--   
--   <pre>
--   &gt;&gt;&gt; enq 2 $ enq 1 (B.def :: Queue Int)
--   Queue [1,2]
--   </pre>
enq :: a -> Queue a -> Queue a

-- | Enqueue multiple elements.
--   
--   <pre>
--   &gt;&gt;&gt; enqs [1,2,3] (B.def :: Queue Int)
--   Queue [1,2,3]
--   </pre>
enqs :: [a] -> Queue a -> Queue a

-- | Dequeue.
--   
--   <pre>
--   &gt;&gt;&gt; deq $ enq 2 $ enq 1 (B.def :: Queue Int)
--   (Just 1, Queue [2])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deq (B.def :: Queue Int)
--   (Nothing, Queue [])
--   </pre>
deq :: Queue a -> (Maybe a, Queue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance Data.Default.Class.Default (Koshucode.Baala.Base.Prelude.Queue.Queue a)


-- | General utilities
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)
named :: (Name a) => a -> Named a
type Map a = a -> a
type ManyMap a = a -> [a]
type Pred a = a -> Bool
data YesNo a
Yes :: a -> YesNo a
No :: a -> YesNo a
type Index = Int
type Collect a = [a] -> a
class Choose m
(<|>) :: Choose m => m a -> m a -> m a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Prelude.Class.YesNo a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Prelude.Class.YesNo a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Prelude.Class.YesNo a)
instance Koshucode.Baala.Base.Prelude.Class.Choose GHC.Base.Maybe
instance Koshucode.Baala.Base.Prelude.Class.Choose (Data.Either.Either a)

module Koshucode.Baala.Base.Prelude.Pair
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
consFst :: a -> Map ([a], b)
consSnd :: b -> Map (a, [b])
mapFstTo :: (Functor m) => (a -> c) -> m (a, b) -> m (c, b)
mapSndTo :: (Functor m) => (b -> c) -> m (a, b) -> m (a, c)
right2 :: (Either a b, Either a c) -> Either a (b, c)
right3 :: (Either a b, Either a c, Either a d) -> Either a (b, c, d)
right4 :: (Either a b, Either a c, Either a d, Either a e) -> Either a (b, c, d, e)
sequenceFst :: (Monad m) => [(m a, b)] -> m [(a, b)]
sequenceSnd :: (Monad m) => [(a, m b)] -> m [(a, b)]


-- | Case-error versions of functions.
module Koshucode.Baala.Base.Prelude.Case

-- | Apply function unless null list.
caseNull :: (Foldable t) => (t a -> b) -> b -> t a -> b

-- | Case-null version of <a>head</a>.
--   
--   <pre>
--   &gt;&gt;&gt; headNull 0 [20, 70, 80] :: Int
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headNull 0 [] :: Int
--   0
--   </pre>
headNull :: a -> [a] -> a

-- | Case-null version of <a>tail</a>.
tailNull :: [a] -> [a] -> [a]

-- | Case-null version of <a>minimum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; minimumNull 100 [20, 70, 80] :: Int
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumNull 100 [] :: Int
--   100
--   </pre>
minimumNull :: (Ord a) => a -> [a] -> a

-- | Case-null version of <a>maximum</a>.
maximumNull :: (Ord a) => a -> [a] -> a

-- | Apply function unless 0.
caseZero :: (Eq a, Num a) => (a -> b) -> b -> a -> b

-- | Case-zero version of <a>quot</a>.
quotZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>rem</a>.
remZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>div</a>.
--   
--   <pre>
--   &gt;&gt;&gt; divZero 0 10 2 :: Int
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divZero 0 10 0 :: Int
--   0
--   </pre>
divZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>mod</a>.
modZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>quotRem</a>.
--   
--   <pre>
--   &gt;&gt;&gt; quotRemZero (0,0) 20 6 :: (Int, Int)
--   (3,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemZero (0,0) 20 0 :: (Int, Int)
--   (0,0)
--   </pre>
quotRemZero :: (Integral a) => (a, a) -> a -> a -> (a, a)

-- | Case-zero version of <a>divMod</a>.
divModZero :: (Integral a) => (a, a) -> a -> a -> (a, a)


-- | Simple functions for parsing command-line options. This module is
--   based on <a>System.Console.GetOpt</a>.
module Koshucode.Baala.Base.IO.SimpleOption

-- | Single letter options, like <tt>h</tt> of <tt>-h</tt>.
type ShortOption = Char

-- | Long name options, like <tt>help</tt> of <tt>--help</tt>.
type LongOption = String

-- | Simple option.
type SimpleOption = SimpleOption' LongOption

-- | Option list of simple option descriptions.
type SimpleOptions = [SimpleOptionDescr]
type SimpleOptionDescr = OptDescr SimpleOption
data SimpleOption' a

-- | Describe option for flag (switch) type.
flag :: [ShortOption] -> [LongOption] -> String -> SimpleOptionDescr

-- | Describe option with optional one parameter.
opt :: [ShortOption] -> [LongOption] -> String -> String -> SimpleOptionDescr

-- | Describe option with required one parameter.
req :: [ShortOption] -> [LongOption] -> String -> String -> SimpleOptionDescr

-- | Get flag of flag-type option.
getFlag :: [SimpleOption] -> LongOption -> Bool

-- | Get parameter list of opt-type option.
getOpt :: [SimpleOption] -> LongOption -> [String]

-- | Get parameter list of req-type option.
getReq :: [SimpleOption] -> LongOption -> [String]

-- | Predefined <tt>-h</tt> or <tt>--help</tt> option.
help :: SimpleOptionDescr

-- | Predefined <tt>-V</tt> or <tt>--version</tt> option.
version :: SimpleOptionDescr

-- | Print help message.
printHelp :: [String] -> SimpleOptions -> IO ()
helpMessage :: [String] -> SimpleOptions -> String

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String

-- | Result of parsing command-line parameters, consist of (1) error
--   message or (2) options and non-option parameters.
type ParseResult' opt = Either [String] ([opt], [String])

-- | String-type parse result.
type ParseResult = ParseResult' SimpleOption

-- | Parse parameters.
parse :: SimpleOptions -> [String] -> ParseResult

-- | Parse command-line parameters.
parseCommand :: SimpleOptions -> IO ParseResult
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.IO.SimpleOption.SimpleOption' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.IO.SimpleOption.SimpleOption' a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.IO.SimpleOption.SimpleOption' a)


-- | Split lists.
module Koshucode.Baala.Base.List.Split

-- | Split elements into subelements.
type Split1 t a = t a -> Maybe (t a)

-- | Split list into sublist.
type SplitList1 a = Split1 [] a

-- | Split elements into two subelements.
type Split2 t a = t a -> Maybe (t a, t a)

-- | Split list into two sublists.
type SplitList2 a = Split2 [] a

-- | Split elements into before-elem-after parts.
type Split3e t a = t a -> Maybe (t a, a, t a)

-- | Split list into before-elem-after parts.
type SplitList3e a = Split3e [] a

-- | Split elements into three subelements.
type Split3 t a = t a -> Maybe (t a, t a, t a)

-- | Split list into three sublists.
type SplitList3 a = Split3 [] a

-- | Drop sublist.
dropSubBy :: SplitList2 a -> SplitList1 a

-- | Drop prefix part from a list. This function is similar to
--   <a>stripPrefix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "abc" "abcdefghi"
--   Just "defghi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "" "abcdefghi"
--   Just "abcdefghi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "xyz" "abcdefghi"
--   Nothing
--   </pre>
dropSub :: (Eq a) => [a] -> SplitList1 a

-- | Split list by given predicate.
splitSubBy :: SplitList2 a -> SplitList3 a

-- | Split list by given sublist.
--   
--   <pre>
--   &gt;&gt;&gt; splitSub "def" "abcdefghi"
--   Just ("abc","def","ghi")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitSub "" "abcdefghi"
--     Just ("","","abcdefghi")
--   </pre>
splitSub :: (Eq a) => [a] -> SplitList3 a

-- | Split list by predicate.
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "b c"
--   Left "b c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "a | b | c"
--   Right ("a ", '|', " b | c")
--   </pre>
splitBy :: (a -> Bool) -> SplitList3e a

-- | Divide list into sublists of given length.
--   
--   <pre>
--   &gt;&gt;&gt; chunks 2 "abcdefg"
--   ["ab","cd","ef","g"]
--   </pre>
chunks :: Int -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divide '|' "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divide :: (Eq a) => a -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divideBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divideBy :: (a -> Bool) -> [a] -> [[a]]

-- | Divide string into words.
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (== '|') "a|bb||ccc|"
--   ["a","bb","ccc"]
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]


-- | Set-like operation.
module Koshucode.Baala.Base.List.Set

-- | Keep duplicate elements.
--   
--   <pre>
--   &gt;&gt;&gt; duplicates "banana"
--   "ana"
--   </pre>
duplicates :: (Ord a) => [a] -> [a]

-- | Remove duplicate elements.
--   
--   <pre>
--   &gt;&gt;&gt; unique "banana"
--   "ban"
--   </pre>
unique :: (Ord a) => [a] -> [a]

-- | Union list to base list.
--   
--   <pre>
--   &gt;&gt;&gt; unionUp "cde" "abc"
--   "deabc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; List.union "cde" "abc"
--   "cdeab"
--   </pre>
unionUp :: (Eq a) => [a] -> [a] -> [a]

-- | Filter by set menbership.
--   
--   <pre>
--   &gt;&gt;&gt; intersectionFilter "abcd" "dxcy"
--   "dc"
--   </pre>
intersectionFilter :: (Ord a) => [a] -> [a] -> [a]

-- | Convert to set-like list, in other words, remove duplicate elements
--   and sort list.
--   
--   <pre>
--   &gt;&gt;&gt; setList "abracadabra"
--   "abcdr"
--   </pre>
setList :: (Ord a) => [a] -> [a]

-- | Set-like equality, in other words, duplication and ordering are
--   ignored.
--   
--   <pre>
--   &gt;&gt;&gt; setEq "abc" "bca"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setEq "abc" "ab"
--   False
--   </pre>
setEq :: (Ord a) => [a] -> [a] -> Bool

-- | Test two list has no elements in common.
--   
--   <pre>
--   &gt;&gt;&gt; disjoint "abc" "de"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disjoint "abc" "cde"
--   False
--   </pre>
disjoint :: (Eq a) => [a] -> [a] -> Bool

-- | Test two list has some common elements.
--   
--   <pre>
--   &gt;&gt;&gt; overlap "abc" "de"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; overlap "abc" "cde"
--   True
--   </pre>
overlap :: (Eq a) => [a] -> [a] -> Bool


-- | Dots pattern.
module Koshucode.Baala.Base.List.Dots

-- | Divide dots-pattern string.
--   
--   <pre>
--   &gt;&gt;&gt; dotsStrings "abc ... xyz"
--   ["abc","...","xyz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dotsStrings "a ... h ... ... v ..."
--   ["a","...","h","...","v","..."]
--   </pre>
dotsStrings :: String -> [String]

-- | Concatenate dots-pattern strings, inserting one space between dots and
--   word.
--   
--   <pre>
--   &gt;&gt;&gt; undotsStrings ["abc", "...", "xyz"]
--   "abc ... xyz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; undotsStrings ["a", "...", "h", "...", "...", "v", "..."]
--   "a ... h ... v ..."
--   </pre>
undotsStrings :: [String] -> String

-- | Take dots-parts from string.
--   
--   <pre>
--   &gt;&gt;&gt; takeDots ["a", "...", "h", "...", "v", "..."] "abcdefghijklmnopqrstuvwxyz"
--   Just ["bcdefg","ijklmnopqrstu","wxyz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeDots ["a", "...", "h", "...", "v", "..."] "abcdefg"
--   Nothing
--   </pre>
takeDots :: [String] -> String -> Maybe [String]

module Koshucode.Baala.Base.Prelude


-- | Utilities for association lists.
module Koshucode.Baala.Base.List.Assoc
type Lookup a = String -> Maybe a

-- | Construct assoc list by splitting base list.
assocBy :: (a -> Maybe k) -> [a] -> ([a], [(k, [a])])

-- | Check which given key is there in assoc list.
assocExist :: (Eq k) => k -> [(k, a)] -> Bool
namedMapM :: (Monad m) => (b -> m c) -> (a, b) -> m (a, c)
lookupBy :: (a -> Bool) -> [(a, b)] -> Maybe b

-- | Lookup assoc list that keys are truth-valued functions.
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b
assocFinder :: (Ord k) => [(k, v)] -> k -> Maybe v

-- | Pick up associations that have given keys.
--   
--   <pre>
--   &gt;&gt;&gt; assocPick ["a","c"] [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]
--   </pre>
assocPick :: (Eq k) => [k] -> Map [(k, a)]

-- | Cut off associations that have given keys.
--   
--   <pre>
--   &gt;&gt;&gt; assocCut ["a","c"] [("a",1), ("b",2), ("c",3)]
--   [("b",2)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; assocCut1 "b" [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]
--   </pre>
assocCut :: (Eq k) => [k] -> Map [(k, a)]
assocCut1 :: (Eq k) => k -> Map [(k, a)]

-- | Change key of assoc list.
--   
--   <pre>
--   &gt;&gt;&gt; assocRename1 "x" "a" [("a",1), ("b",2), ("c",3)]
--   [("x",1), ("b",2), ("c",3)]
--   </pre>
assocRename1 :: (Eq k) => k -> k -> Map [(k, a)]
assocRehead :: (Eq k) => [(k, k)] -> [(k, v)] -> [(k, v)]

-- | Compose two assocs.
--   
--   <pre>
--   &gt;&gt;&gt; assocCompose [("A","H"), ("B","J")] [("H","P"), ("H","Q"), ("I","R"), ("J","S")]
--   [("A","P"), ("A","Q"), ("B","S")]
--   </pre>
assocCompose :: (Eq b) => [(a, b)] -> [(b, c)] -> [(a, c)]

-- | Meet two assocs.
--   
--   <pre>
--   &gt;&gt;&gt; assocMeet [("A","H"), ("B","J")] [("H","P"), ("H","Q"), ("I","R"), ("J","S")]
--   [("A","H","P"), ("A","H","Q"), ("B","J","S")]
--   </pre>
assocMeet :: (Eq b) => [(a, b)] -> [(b, c)] -> [(a, b, c)]
data OnceMore a
Once :: a -> OnceMore a
More :: [a] -> OnceMore a

-- | Convert general assoc list into once/more assoc list.
assocGather :: (Eq k) => [(k, a)] -> [(k, OnceMore a)]

-- | Push key and value into once/more assoc list.
assocPush :: (Eq k) => k -> a -> Map [(k, OnceMore a)]

-- | Extract once part from once/more assoc list.
assocOnce :: [(k, OnceMore a)] -> [(k, a)]

-- | Extract more part from once/more assoc list.
assocMore :: [(k, OnceMore a)] -> [(k, [a])]
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]
gatherWith :: (c -> Gather [a] b) -> [c] -> [a] -> [b]

-- | Gather (<i>k</i>, <i>v</i>) to <a>Map</a> <i>k</i> [<i>v</i>].
gatherToMap :: (Ord k) => [(k, v)] -> Map k [v]

-- | Gather (<i>v</i>, <i>k</i>) to <a>Map</a> <i>k</i> [<i>v</i>].
gatherToMapSwap :: (Ord k) => [(v, k)] -> Map k [v]
gatherToAssoc :: (Ord k) => [(k, v)] -> [(k, [v])]
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.List.Assoc.OnceMore a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.List.Assoc.OnceMore a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.List.Assoc.OnceMore a)

module Koshucode.Baala.Base.List.List

-- | Tails of list.
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc", "bc", "c"]
--   </pre>
tails :: [a] -> [[a]]

-- | Test list has single element.
isSingleton :: [a] -> Bool

-- | Test list is not empty.
notNull :: [a] -> Bool
maybeEmpty :: Maybe a -> (a -> [b]) -> [b]
right :: b -> Map (Either a b)

-- | Take first element; if empty list is given, returns empty list.
--   
--   <pre>
--   &gt;&gt;&gt; takeFirst "abc"
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeFirst ""
--   ""
--   </pre>
takeFirst :: [a] -> [a]

-- | Take last element; if empty list is given, returns empty list.
--   
--   <pre>
--   &gt;&gt;&gt; takeLast "abc"
--   "c"
--   </pre>
takeLast :: [a] -> [a]

-- | Take elements at odd positions, i.e., first, third, ...
--   
--   <pre>
--   &gt;&gt;&gt; takeOdd "abcdeft"
--   "acet"
--   </pre>
takeOdd :: [a] -> [a]

-- | Take elements at even positions. i.e., second, fourth, ...
--   
--   <pre>
--   &gt;&gt;&gt; takeEven "abcdeft"
--   "bdf"
--   </pre>
takeEven :: [a] -> [a]

-- | Take <i>N</i> elements with filler.
--   
--   <pre>
--   &gt;&gt;&gt; takeFill 0 3 [0 .. 8]
--     [0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeFill 0 5 [6 .. 8]
--     [6,7,8,0,0]
--   </pre>
takeFill :: a -> Int -> [a] -> [a]

-- | Take tail-side <i>N</i> elements with filler.
--   
--   <pre>
--   &gt;&gt;&gt; takeTailFill 0 3 [0 .. 8]
--     [6,7,8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeTailFill 0 5 [6 .. 8]
--     [0,0,6,7,8]
--   </pre>
takeTailFill :: a -> Int -> [a] -> [a]

-- | Make singleton list.
li1 :: a -> [a]
li2 :: a -> a -> [a]
li3 :: a -> a -> a -> [a]
consIf :: Bool -> a -> [a] -> [a]
type RangeBy a = a -> a -> [a]
rangeBy :: (Ord a) => Map a -> RangeBy a
zipMaybe :: [Maybe a] -> [b] -> [(a, b)]
zipMaybe2 :: [Maybe a] -> [b] -> [b]
map2 :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
mapAt :: (Map a) -> Int -> Map [a]
mapWithLast :: (a -> b) -> (a -> b) -> [a] -> [b]
omit :: (a -> Bool) -> Map [a]
filterFst :: (a -> Bool) -> Map [(a, b)]
squeeze :: (a -> Bool) -> Map [a]
squeezeEmptyLines :: Map [String]
reverseMap :: Map [a] -> Map [a]


-- | Snipping elements.
module Koshucode.Baala.Base.List.Snip

-- | Snipping elements using indicies.
type Snip a = [Int] -> Map [a]

-- | Snip for differenct type values.
type Snip2 a b = (Snip a, Snip b)

-- | Type for binary operators.
type Bin a = a -> a -> a
snipFull :: (Eq a) => [a] -> [a] -> [Int]

-- | Indices of shared elements.
snipIndex :: (Eq a) => [a] -> [a] -> [Int]
snipPair :: (Ord a) => [a] -> [a] -> ([Int], [Int])

-- | Pair of picking-up and cutting-off elements.
snipBoth :: [Int] -> [a] -> ([a], [a])

-- | Pick up indexed elements.
snipFrom :: Snip a

-- | Cut off indexed elements.
snipOff :: Snip a

-- | Move indexed elements to the front.
snipForward :: Snip a

-- | Move indexed elements to the rear.
snipBackward :: Snip a
snipForward2 :: Snip2 a b
snipBackward2 :: Snip2 a b

-- | Take left-side elements.
snipLeft :: (Eq a) => Bin [a]

-- | Take shared elements.
snipShare :: (Eq a) => Bin [a]

-- | Take right-side elements.
snipRight :: (Eq a) => Bin [a]
snipOrder :: (Eq a) => [a] -> [a] -> Map [c]

-- | Check lengths of two lists are same.
sameLength :: [a] -> [b] -> Bool
notSameLength :: [a] -> [b] -> Bool

-- | Check elements in the first list are non-negative, and elements in the
--   second are negative.
(+-) :: [Int] -> [Int] -> Bool

module Koshucode.Baala.Base.List.Order
data OrderCap a

-- | Ascending order
Asc :: a -> OrderCap a

-- | Descending order
Desc :: a -> OrderCap a

-- | Select order cap for ordering value. <a>GT</a> and <a>EQ</a> mean
--   <a>Asc</a>, <a>LT</a> means <a>Desc</a>.
orderingCap :: (Ordering, a) -> OrderCap a

-- | Sort by capped name.
--   
--   <pre>
--   &gt;&gt;&gt; sortByName (words "a b c") [Asc "b"] [[1,3,3], [1,2,3], [1,1,3 :: Int]]
--   [[1,1,3], [1,2,3], [1,3,3]]
--   </pre>
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]
sortWith :: (Ord a, Ord b) => (a -> b) -> Map [a]
type Ranking n a = Int -> [OrderCap n] -> [n] -> [[a]] -> ([Int], [[a]])

-- | Sort and numbering like 1234.
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a

-- | Sort and rank like 1223.
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a

-- | Sort and rank like 1224.
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a

-- | 1223 ranking start with given number.
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]

-- | 1224 ranking start with given number.
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.List.Order.OrderCap a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.List.Order.OrderCap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.List.Order.OrderCap a)


-- | File path and content in lazy bytestring.
module Koshucode.Baala.Base.IO.BzFile

-- | File path and content in lazy bytestring. The function
--   <a>readBzFile</a> creates:
--   
--   <ul>
--   <li><a>BzFile</a> with content and <a>Nothing</a>-exception on
--   success,</li>
--   <li><a>BzFile</a> with empty content and <a>Just</a>-exception on
--   failure.</li>
--   </ul>
data BzFile
BzFile :: FilePath -> Bz -> Maybe SomeException -> BzFile

-- | Path of file.
[bzFilePath] :: BzFile -> FilePath

-- | File content as lazy bytestring.
[bzFileContent] :: BzFile -> Bz

-- | Exception when reading file.
[bzFileException] :: BzFile -> Maybe SomeException

-- | Read file from given path.
readBzFile :: FilePath -> IO BzFile

-- | Read file content as lazy bytestring.
tryReadFile :: (Exception e) => FilePath -> IO (Either e Bz)
instance GHC.Show.Show Koshucode.Baala.Base.IO.BzFile.BzFile


-- | Exit process.
module Koshucode.Baala.Base.IO.Exit

-- | Program name and command-line arguments. This function removes carrige
--   returns from the arguments.
progAndArgs :: IO (String, [String])

-- | Set I/O handle for Koshucode output.
hSetKoshuOutput :: Handle -> IO ()

-- | Encoding judgement string.
currentEncodings :: IO String

-- | Exit process.
exit :: Int -> IO a

-- | Map integer value to exit code.
exitCode :: Int -> ExitCode

-- | Print message and exit on 0.
putSuccess :: String -> IO a
putSuccessLn :: String -> IO a

-- | Print abort message and exit on 1.
--   
--   <pre>
--   &gt;&gt;&gt; putAbort
--   ABORT / &lt;interactive&gt; exits on 1
--   </pre>
putAbort :: IO a

-- | Print error and abort message and exit on 1.
putAbortWith :: String -> IO a

-- | Print error message and exit on 1.
putFailure :: String -> IO a
putFailureLn :: String -> IO a

module Koshucode.Baala.Base.Text.Utility
trimLeft :: Map String
trimRight :: Map String
trimBoth :: Map String

-- | Add spaces to right.
--   
--   <pre>
--   &gt;&gt;&gt; padRight 10 "abc"
--   "abc       "
--   </pre>
padRight :: Int -> Map String
padRightWith :: Char -> Int -> Map String

-- | Add spaces to left.
--   
--   <pre>
--   &gt;&gt;&gt; padLeft 10 "abc"
--   "       abc"
--   </pre>
padLeft :: Int -> Map String
padLeftWith :: Char -> Int -> Map String
stringWidth :: String -> Int
putShow :: (Show a) => a -> IO ()
putShowLn :: (Show a) => a -> IO ()
putLines :: [String] -> IO ()
hPutLines :: Handle -> [String] -> IO ()
hPutEmptyLine :: Handle -> IO ()
readInt :: String -> Maybe Int
readInteger :: String -> Maybe Integer


-- | Retrieve via HTTP.
module Koshucode.Baala.Base.IO.Http

-- | URI.
type UriText = String

-- | Pair of protocol name and proxy URI.
type HttpProxy = (String, Maybe UriText)

-- | Get HTTP content as lazy bytestring.
uriContent :: [HttpProxy] -> UriText -> IO (Either (Int, String) Bz)

-- | Text message of HTTP exception.
httpExceptionSummary :: HttpException -> String


-- | Mix text.
module Koshucode.Baala.Base.Text.MixText

-- | Text mixable string, text, and bytestring.
data MixText

-- | Create mix text from strict bytestring.
mixBs :: ByteString -> MixText

-- | Create mix text from lazy bytestring.
mixBz :: ByteString -> MixText

-- | Create mix text from strict text.
mixTx :: Text -> MixText

-- | Create mix text from lazy text.
mixTz :: Text -> MixText

-- | Create mix text from string.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "abc" &lt;&gt; mixString "def"
--   MixText "abcdef"
--   </pre>
mixString :: String -> MixText

-- | Create mix text from char.
mixChar :: Char -> MixText

-- | Put mix text to left edge in given-length char sequence.
--   
--   <pre>
--   &gt;&gt;&gt; mixLeft '.' 10 $ mixString "abc"
--   MixText "abc......."
--   </pre>
mixLeft :: Char -> Int -> MixText -> MixText

-- | Put mix text to right edge in given-length char sequence.
--   
--   <pre>
--   &gt;&gt;&gt; mixRight '.' 10 $ mixString "abc"
--   MixText ".......abc"
--   </pre>
mixRight :: Char -> Int -> MixText -> MixText

-- | Create mix text of given-length spaces.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "|" &lt;&gt; mixSpace 4 &lt;&gt; mixString "|"
--   MixText "|    |"
--   </pre>
mixSpace :: Int -> MixText

-- | Infix mix space.
mixSep :: MixText -> MixText -> MixText
mixSep2 :: MixText -> MixText -> MixText

-- | Empty space.
mix0 :: MixText

-- | One space.
mix1 :: MixText

-- | Two-length spaces.
mix2 :: MixText

-- | Three-length spaces.
mix3 :: MixText

-- | Four-length spaces.
mix4 :: MixText

-- | Mix text of octal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixOct (12 :: Int)
--   MixText "14"
--   </pre>
mixOct :: (Integral n, Show n) => n -> MixText

-- | Mix text of decimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixDec (12 :: Int)
--   MixText "12"
--   </pre>
mixDec :: (Integral n, Show n) => n -> MixText

-- | Mix text of hexadecimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixHex (12 :: Int)
--   MixText "c"
--   </pre>
mixHex :: (Integral n, Show n) => n -> MixText
mixSign :: (Num n, Ord n) => n -> MixText

-- | Zero-padding decimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixDecZero 6 (123 :: Int)
--   MixText "000123"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixDecZero 6 (-123 :: Int)
--   MixText "-00123"
--   </pre>
mixDecZero :: (Integral n, Show n) => Int -> n -> MixText
mixNumZero :: (Integral n, Show n) => (n -> MixText) -> Int -> n -> MixText

-- | Append line break.
mixLine :: MixText -> MixText

-- | Append line break to each mix texts.
mixLines :: [MixText] -> MixText

-- | Soft line break, i.e., suppress at the beginning of line.
mixSoft :: MixText

-- | Hard line break, i.e., suppress only after auto line break.
mixHard :: MixText

-- | Mix text with local line break setting.
mixBreak :: LineBreak -> MixText -> MixText

-- | Block of multiple mix texts.
mixBlock :: [MixText] -> MixText

-- | Map function to mix texts directly in mix block.
--   
--   <pre>
--   &gt;&gt;&gt; let m1 = mixBlock [mixString "cd", mixString "ef" &lt;&gt; mixBlock [mixString "g"]]
--   
--   &gt;&gt;&gt; let m2 = mixBlock [mixString "ab", m1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m2
--   MixText "abcdegh"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixBlockMap mixLine m2
--   MixText "ab\r\ncd\r\nefg\r\n"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixBlockMap (\x -&gt; mixString "[" &lt;&gt; x &lt;&gt; mixString "]") m2
--   MixText "[ab][cd][efg]"
--   </pre>
mixBlockMap :: (MixText -> MixText) -> MixText -> MixText
mixShow :: (Show a) => a -> MixText

-- | Empty mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixEmpty
--   MixText ""
--   </pre>
mixEmpty :: MixText

-- | Convert mix text to lazy bytestring builder.
mixToBuilder :: LineBreak -> MixText -> Builder

-- | Convert mix text to lazy bytestring.
mixToBz :: LineBreak -> MixText -> ByteString

-- | Convert mix text to string.
mixToString :: LineBreak -> MixText -> String

-- | Convert mix text to string without line breaks.
mixToFlatString :: MixText -> String

-- | Print mix text to the standard output.
putMix :: LineBreak -> MixText -> IO ()

-- | Print mix text and newline to the standard output.
putMixLn :: LineBreak -> MixText -> IO ()

-- | Print mix text to the given output handler.
hPutMix :: LineBreak -> Handle -> MixText -> IO ()

-- | Print mix text and newline to the given output handler.
hPutMixLn :: LineBreak -> Handle -> MixText -> IO ()

-- | Print mix text lines to the standard output.
putMixLines :: LineBreak -> [MixText] -> IO ()

-- | Print mix text lines to the given output handler.
hPutMixLines :: LineBreak -> Handle -> [MixText] -> IO ()

-- | Write mix text to a file.
writeMix :: LineBreak -> FilePath -> MixText -> IO ()
instance GHC.Show.Show Koshucode.Baala.Base.Text.MixText.MixText
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.MixText.MixText
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.MixText.MixText
instance Data.Default.Class.Default Koshucode.Baala.Base.Text.MixText.MixText
instance GHC.Base.Monoid Koshucode.Baala.Base.Text.MixText.MixText


-- | Class for constructing mix text.
module Koshucode.Baala.Base.Text.MixClass

-- | Construct mix text.
class Mix a
mix :: Mix a => a -> MixText

-- | Enclose mix text with open and close bracket.
mixBracket :: (Mix m) => m -> m -> MixText -> MixText

-- | Enclose mix text with bracket and space.
mixBracketS :: (Mix m) => m -> m -> MixText -> MixText

-- | Concatenate mix texts with delimiter.
mixJoin :: (Mix m) => m -> [MixText] -> MixText

-- | Concatenate mix texts with delimiter and space.
mixJoinS :: (Mix m) => m -> [MixText] -> MixText

-- | Join with one space.
mixJoin1 :: [MixText] -> MixText

-- | Join with vertical bar.
mixJoinBar :: [MixText] -> MixText
mixInfix :: (Mix m) => m -> MixText -> MixText -> MixText
instance Koshucode.Baala.Base.Text.MixClass.Mix Koshucode.Baala.Base.Text.MixText.MixText
instance Koshucode.Baala.Base.Text.MixClass.Mix ()
instance Koshucode.Baala.Base.Text.MixClass.Mix Data.ByteString.Internal.ByteString
instance Koshucode.Baala.Base.Text.MixClass.Mix Data.ByteString.Lazy.Internal.ByteString
instance Koshucode.Baala.Base.Text.MixClass.Mix Data.Text.Internal.Text
instance Koshucode.Baala.Base.Text.MixClass.Mix Data.Text.Internal.Lazy.Text
instance Koshucode.Baala.Base.Text.MixClass.Mix GHC.Base.String
instance Koshucode.Baala.Base.Text.MixClass.Mix GHC.Types.Char
instance Koshucode.Baala.Base.Text.MixClass.Mix GHC.Types.Int
instance Koshucode.Baala.Base.Text.MixClass.Mix [Koshucode.Baala.Base.Text.MixText.MixText]
instance Koshucode.Baala.Base.Text.MixClass.Mix (GHC.Base.Maybe Koshucode.Baala.Base.Text.MixText.MixText)


-- | Encode using mix text.
module Koshucode.Baala.Base.Text.MixEncode

-- | Encode via mix text.
class MixEncode a
mixEncode :: MixEncode a => a -> MixText

-- | Encode with shortener.
class MixShortEncode a
mixShortEncode :: MixShortEncode a => Shorten -> a -> MixText

-- | <a>mixShortEncode</a> with no shortener.
mixIdEncode :: (MixShortEncode a) => a -> MixText

-- | Convert string to short sign.
type Shorten = String -> Maybe String

-- | Shorten which does not shorten strings.
noShorten :: Shorten
instance Koshucode.Baala.Base.Text.MixEncode.MixEncode GHC.Types.Bool

module Koshucode.Baala.Base.List


-- | I/O point: file, standard input, direct text, etc.
module Koshucode.Baala.Base.IO.IOPoint

-- | Named I/O handle.
data NamedHandle
NamedHandle :: String -> Handle -> NamedHandle

-- | Name of handle
[handleName] :: NamedHandle -> String

-- | I/O handle
[handle] :: NamedHandle -> Handle
data IOPoint

-- | Context directory and target path
IOPointFile :: FilePath -> FilePath -> IOPoint

-- | Universal resource identifier
IOPointUri :: String -> IOPoint

-- | Code itself
IOPointText :: (Maybe String) -> Bz -> IOPoint

-- | Custom I/O
IOPointCustom :: String -> Bz -> IOPoint

-- | Sandard input
IOPointStdin :: IOPoint

-- | Sandard output
IOPointStdout :: IOPoint

-- | Output handler
IOPointOutput :: NamedHandle -> IOPoint

-- | Name of I/O point, i.e., <tt>"file"</tt>, <tt>"url"</tt>,
--   <tt>"text"</tt>, <tt>"stdin"</tt>, or <tt>"stdout"</tt>.
ioPointType :: IOPoint -> String

-- | Name of I/O point.
ioPointText :: IOPoint -> String

-- | Create I/O point.
ioPointFrom :: FilePath -> FilePath -> IOPoint

-- | Create I/O points from using stdin, texts itself, filenames, and urls.
ioPointList :: Bool -> [Bz] -> FilePath -> [FilePath] -> [IOPoint]

-- | Numbered I/O point.
data NIOPoint
NIOPoint :: Int -> IOPoint -> NIOPoint

-- | Sequential number (0 for unnumbered, &gt; 0 for numbered)
[nioNumber] :: NIOPoint -> Int

-- | I/O point
[nioPoint] :: NIOPoint -> IOPoint

-- | Create input point for given lazy bytestring.
nioFrom :: Bz -> NIOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance Data.Default.Class.Default Koshucode.Baala.Base.IO.IOPoint.NIOPoint

module Koshucode.Baala.Base.IO.CodePt

-- | Point of input code.
data CodePt
CodePt :: NIOPoint -> Int -> String -> String -> CodePt

-- | Source of code
[codePtSource] :: CodePt -> NIOPoint

-- | Line number
[codePtLineNo] :: CodePt -> Int

-- | Line content
[codePtLineText] :: CodePt -> String

-- | Text at which begins token
[codePtText] :: CodePt -> String

-- | Column number at which code starts.
codePtColumnNo :: CodePt -> Int
codePtDisplay :: (String, CodePt) -> [(String, String)]
class CodePtr a where codePt p = headNull def $ codePtList p
codePtList :: CodePtr a => a -> [CodePt]
codePt :: CodePtr a => a -> CodePt
data Sourced a
Sourced :: [CodePt] -> a -> Sourced a
[source] :: Sourced a -> [CodePt]
[unsourced] :: Sourced a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.IO.CodePt.Sourced a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.IO.CodePt.Sourced a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.IO.CodePt.Sourced a)
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.CodePt.CodePt
instance GHC.Show.Show Koshucode.Baala.Base.IO.CodePt.CodePt
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.CodePt.CodePt
instance Data.Default.Class.Default Koshucode.Baala.Base.IO.CodePt.CodePt
instance Koshucode.Baala.Base.IO.CodePt.CodePtr Koshucode.Baala.Base.IO.CodePt.CodePt
instance GHC.Base.Functor Koshucode.Baala.Base.IO.CodePt.Sourced
instance Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Base.IO.CodePt.Sourced a)


-- | Convert to <a>Doc</a> pretty printer.
module Koshucode.Baala.Base.Text.PPrint

-- | Convert to <a>Doc</a> pretty printer.
class PPrint a
pprint :: PPrint a => a -> Doc

-- | Concatenate docs horizontally with space, same as <a>hsep</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pprintH ["abc", "def"]
--   abc def
--   </pre>
pprintH :: (PPrint a) => [a] -> Doc

-- | Concatenate docs vertically, same as <a>vcat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pprintV ["abc", "def"]
--   abc
--   def
--   </pre>
pprintV :: (PPrint a) => [a] -> Doc

-- | Wrap doc with open and close docs.
--   
--   <pre>
--   &gt;&gt;&gt; pprintWraps "(" ")" "abc"
--   ( abc )
--   </pre>
pprintWraps :: (PPrint a, PPrint b) => a -> a -> b -> Doc
instance Koshucode.Baala.Base.Text.PPrint.PPrint Text.PrettyPrint.HughesPJ.Doc
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Types.Int
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Integer.Type.Integer
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Base.String


-- | Text table
module Koshucode.Baala.Base.Text.TextTable
data Position
Front :: Position
Middle :: Position
Rear :: Position
textPos :: String -> [Position]
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
[cellText] :: Cell -> [String]
[cellWidth] :: Cell -> Int
[cellHeight] :: Cell -> Int
[cellPos] :: Cell -> Position
[cellPad] :: Cell -> Char
textTable :: [Position] -> [[String]] -> [[Cell]]
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]
textCell :: Position -> String -> Cell
textRuleCell :: Char -> Cell
textBlockCell :: Position -> [String] -> Cell
textBlockCellPlus :: Int -> Position -> [String] -> Cell
alignTable :: [[Cell]] -> [[Cell]]
renderTable :: String -> [[Cell]] -> [String]
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Show.Show Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.TextTable.Position
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.TextTable.Position
instance GHC.Show.Show Koshucode.Baala.Base.Text.TextTable.Position

module Koshucode.Baala.Base.Text

module Koshucode.Baala.Base.IO


-- | Abort reasons.
module Koshucode.Baala.Base.Abort.Reason
data AbortReason
AbortReason :: String -> [String] -> [String] -> [(String, CodePt)] -> AbortReason

-- | Reason in one line
[abortReason] :: AbortReason -> String

-- | Detailed description
[abortDetail] :: AbortReason -> [String]

-- | Additional notes for long description
[abortNote] :: AbortReason -> [String]

-- | Tag and aborting point
[abortPoint] :: AbortReason -> [(String, CodePt)]

-- | Abortable result, i.e., either of right result or abort reason.
type Ab a = Either AbortReason a

-- | Abortable mapping.
type AbMap a = a -> Ab a
type AbManyMap a = a -> Ab [a]
type AbPred a = a -> Ab Bool
type IOAb a = IO (Ab a)

-- | Type for abortable binary operators.
type BinAb a = a -> a -> Ab a

-- | Construct abort reason with reason text.
abortBecause :: String -> AbortReason

-- | Construct abort reason with reason and detailed text.
abortLine :: String -> String -> AbortReason

-- | Construct abort reason with reason and multilined detailed text.
abortLines :: String -> [String] -> AbortReason

-- | Construct abort reason with reason and note.
abortPage :: String -> [String] -> AbortReason
instance GHC.Classes.Ord Koshucode.Baala.Base.Abort.Reason.AbortReason
instance GHC.Classes.Eq Koshucode.Baala.Base.Abort.Reason.AbortReason
instance GHC.Show.Show Koshucode.Baala.Base.Abort.Reason.AbortReason


-- | Abortable process
module Koshucode.Baala.Base.Abort.Abortable

-- | Push source information when process is aborted.
abortable :: (CodePtr p) => String -> [p] -> Map (Ab b)
abortableSourced :: String -> (a -> Ab b) -> Sourced a -> Ab (Sourced b)


-- | Reporting abort reasons.
module Koshucode.Baala.Base.Abort.Report

-- | Command name and its arguments.
type CommandLine = [String]

-- | Stop program execution abnormally.
abort :: CommandLine -> AbortReason -> IO x

-- | Print abort message.
abortPrint :: CommandLine -> AbortReason -> IO ()

-- | Convert abort reason to message lines.
abortMessage :: CommandLine -> AbortReason -> [String]

-- | Stop on error <tt>'BUG DISCOVERED'</tt>
bug :: String -> a


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Syntax.Line

-- | Line number.
type LineNumber = Int

-- | Line with number.
type NumberedLine = (LineNumber, String)

-- | Line number and its content.
linesCrlfNumbered :: String -> [NumberedLine]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; linesCrlf "aaa\nbbb\r\nccc\n\nddd\n"
--   ["aaa","bbb","ccc","","ddd"]
--   </pre>
linesCrlf :: String -> [String]
linesFrom :: (Show a) => a -> [String]
linesCrlfBzNumbered :: Bz -> [NumberedLine]
linesCrlfBz :: Bz -> [Bz]
linesCrlfBzString :: Bz -> [String]

-- | Remove UTF-8 BOM (EF BB BF) from lazy ByteString.
dropBom :: Bz -> Bz

-- | Tokens in line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
[lineNumber] :: CodeLine a -> LineNumber

-- | Line content without newline.
[lineContent] :: CodeLine a -> String

-- | Tokens in the line.
[lineTokens] :: CodeLine a -> [a]
type IndentSize = Int
lineIndentPair :: (a -> IndentSize) -> CodeLine a -> (IndentSize, CodeLine a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Syntax.Line.CodeLine a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Syntax.Line.CodeLine a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Syntax.Line.CodeLine a)
instance Koshucode.Baala.Base.IO.CodePt.CodePtr a => Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Base.Syntax.Line.CodeLine a)


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <tt>CodeLine</tt> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <tt>CodeLine</tt>.
module Koshucode.Baala.Base.Syntax.Clause

-- | Tokens in clause.
data CodeClause a
CodeClause :: [CodeLine a] -> [a] -> CodeClause a

-- | Source lines of clause
[clauseLines] :: CodeClause a -> [CodeLine a]

-- | Source tokens of clause
[clauseTokens] :: CodeClause a -> [a]

-- | Clause with no tokens.
codeClauseEmpty :: CodeClause a
splitClause :: Gather [(IndentSize, a)] [a]
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Syntax.Clause.CodeClause a)
instance Koshucode.Baala.Base.IO.CodePt.CodePtr a => Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Base.Syntax.Clause.CodeClause a)


-- | Code scanner.
module Koshucode.Baala.Base.Syntax.Scan

-- | Code scanner divides input text into output tokens.
data CodeScan i o
CodeScan :: [CodeScanMap i o] -> CodeScanMap i o -> CodePt -> i -> [o] -> WordTable -> CodeScan i o

-- | Saved updater
[codeMapSaved] :: CodeScan i o -> [CodeScanMap i o]

-- | Updater
[codeMap] :: CodeScan i o -> CodeScanMap i o

-- | Code point
[codeInputPt] :: CodeScan i o -> CodePt

-- | Input text
[codeInput] :: CodeScan i o -> i

-- | Output tokens
[codeOutput] :: CodeScan i o -> [o]

-- | Collected words
[codeWords] :: CodeScan i o -> WordTable

-- | Update code scanner.
type CodeScanMap i o = Map (CodeScan i o)

-- | Collected words.
type WordTable = Map String String

-- | Test scanner at the beginning of line, i.e., no output collected.
isBol :: CodeScan i o -> Bool

-- | Save current updater.
codeScanSave :: CodeScanMap i o

-- | Restore saved updater.
codeScanRestore :: CodeScanMap i o

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><a>LineNumber</a><tt>,
--   </tt><a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeScanUp :: CodeScanMap String o -> NIOPoint -> String -> [CodeLine o]

-- | Lazy bytestring version of <a>codeScanUp</a>.
codeScanUpBz :: CodeScanMap String o -> NIOPoint -> Bz -> [CodeLine o]

-- | Update <a>codeInput</a> and push result element to <a>codeOutput</a>.
codeUpdate :: i -> o -> CodeScanMap i o

-- | Update code scanner with word table.
codeUpdateWords :: WordTable -> i -> o -> CodeScanMap i o

-- | Change mapper of code sc.
codeChange :: CodeScanMap i o -> CodeScanMap i o
instance Koshucode.Baala.Base.IO.CodePt.CodePtr (Koshucode.Baala.Base.Syntax.Scan.CodeScan i o)


-- | Abort symbols
module Koshucode.Baala.Base.Abort

module Koshucode.Baala.Base.Abort.Message

-- | AD-LIB: reason
adlib :: String -> Ab a

-- | BUG: reason
bug :: String -> Ab a

-- | Unsupported feature
unsupported :: String -> Ab a

module Koshucode.Baala.Base.Syntax.Message
abCode :: (CodePtr cp) => [cp] -> Map (Ab b)

-- | Extra close bracket
extraCloseBracket :: Ab a

-- | Unclosed open bracket
extraOpenBracket :: Ab a

module Koshucode.Baala.Base.Message

module Koshucode.Baala.Base.Syntax.Tree

-- | Tree of leaf and branch.
data CodeTree p a

-- | Terminal of tree.
TreeL :: a -> CodeTree p a

-- | Bracket-type and subtrees.
TreeB :: p -> (Maybe (a, a)) -> [CodeTree p a] -> CodeTree p a

-- | Convert a list of elements to a single tree.
tree :: (Ord p, CodePtr a) => GetBracketType p a -> Bracket p -> p -> [a] -> Ab (CodeTree p a)

-- | Convert a list of elements to trees.
trees :: (Ord p, CodePtr a) => GetBracketType p a -> Bracket p -> [a] -> Ab [CodeTree p a]
treeWrap :: p -> [CodeTree p a] -> CodeTree p a

-- | Convert tree to list of tokens.
untree :: CodeTree p a -> [a]

-- | Convert tree to list of tokens.
untrees :: [CodeTree p a] -> [a]
leaves :: CodeTree p a -> [a]

-- | Simplify tree by removing double brackets, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Pred p -> Map (CodeTree p a)
mapToLeaf :: (a -> a) -> Map (CodeTree p a)

-- | Bracket type.
data Bracket p

-- | None bracket
BracketNone :: Bracket p

-- | Open bracket
BracketOpen :: p -> Bracket p

-- | Close bracket
BracketClose :: p -> Bracket p

-- | Get a bracket type.
type GetBracketType p a = a -> Bracket p

-- | Make <a>GetBracketType</a> functions from a type-open-close table.
--   
--   Make bracket/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let bracket n [a, b] = (n, (== a), (== b))
--   
--   &gt;&gt;&gt; let pt = bracketTable [ bracket 1 "()", bracket 2 "[]" ]
--   </pre>
--   
--   Get bracket types for each chars. Types of open brackets are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0, 0, 1, 0, 0, 2, 0, 0, -2, -1, 0]
--   </pre>
bracketTable :: (Eq a) => [(p, Pred a, Pred a)] -> GetBracketType p a
instance GHC.Classes.Ord p => GHC.Classes.Ord (Koshucode.Baala.Base.Syntax.Tree.Bracket p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (Koshucode.Baala.Base.Syntax.Tree.Bracket p)
instance GHC.Show.Show p => GHC.Show.Show (Koshucode.Baala.Base.Syntax.Tree.Bracket p)
instance (GHC.Classes.Ord p, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Base.Syntax.Tree.CodeTree p a)
instance (GHC.Classes.Eq p, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Base.Syntax.Tree.CodeTree p a)
instance (GHC.Show.Show p, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Base.Syntax.Tree.CodeTree p a)
instance GHC.Base.Functor (Koshucode.Baala.Base.Syntax.Tree.CodeTree p)


-- | Convert infixed-operator trees into prefixed-operator trees.
module Koshucode.Baala.Base.Syntax.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
infixHeight :: (Ord b) => (a -> Maybe b) -> [(b, InfixHeight)] -> a -> InfixHeight

-- | Split branches in a given tree at infixed binary operators.
infixToPrefix :: (Map a, Map a, Map a) -> (a -> InfixHeight) -> Collect (InfixTree p a) -> InfixMapper p a -> InfixAbMap a (CodeTree p a)
type InfixAb a x = Either [(InfixHeight, a)] x
type InfixAbMap a x = x -> InfixAb a x
type InfixTree p a = CodeTree p (InfixHeight, a)
type InfixMapper p a = InfixAbMap a [InfixTree p a] -> InfixAbMap a (InfixTree p a)


-- | Syntactic functions.
module Koshucode.Baala.Base.Syntax

module Koshucode.Baala.Base
