-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.178.0.0


-- | Text table
module Koshucode.Baala.Base.Text.TextTable

-- | Position in text table.
data Position
Front :: Position
Middle :: Position
Rear :: Position

-- | Convert position symbols to <a>Position</a>.
--   
--   <pre>
--   &gt;&gt;&gt; textPos "&lt;-&gt;-"
--   [Front,Middle,Rear,Middle]
--   </pre>
textPos :: String -> [Position]

-- | Cell in text table.
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
[cellText] :: Cell -> [String]
[cellWidth] :: Cell -> Int
[cellHeight] :: Cell -> Int
[cellPos] :: Cell -> Position
[cellPad] :: Cell -> Char

-- | Create text table from cell strings.
textTable :: [Position] -> [[String]] -> [[Cell]]

-- | Create text table with table heading.
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]

-- | Convert string to cell.
textCell :: Position -> String -> Cell

-- | Create rule cell.
textRuleCell :: Char -> Cell

-- | Create multi-line cell.
textBlockCell :: Position -> [String] -> Cell

-- | Create multi-line cell with padding line.
textBlockCellPlus :: Int -> Position -> [String] -> Cell

-- | Align cells.
alignTable :: [[Cell]] -> [[Cell]]

-- | Render text table.
renderTable :: String -> [[Cell]] -> [String]
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Show.Show Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.TextTable.Position
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.TextTable.Position
instance GHC.Show.Show Koshucode.Baala.Base.Text.TextTable.Position


-- | Simple document used in comments.
module Koshucode.Baala.Base.Text.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec

-- | Comment string <tt>-*- koshu -*-</tt> for The Emacs editor.
emacsModeComment :: String

-- | Wrap string in comment.
--   
--   <pre>
--   &gt;&gt;&gt; commentLine "Hello Koshu"
--   "**  Hello Koshu"
--   </pre>
commentLine :: StringMap

-- | Print strings as comment lines.
--   
--   <pre>
--   &gt;&gt;&gt; putCommentLines ["Hello", "Koshu"]
--   **  Hello
--   **  Koshu
--   </pre>
putCommentLines :: [String] -> IO ()

-- | Print strings as comment lines.
hPutCommentLines :: Handle -> [String] -> IO ()
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Show.Show Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Comment.CommentSec
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Comment.CommentSec
instance GHC.Show.Show Koshucode.Baala.Base.Text.Comment.CommentSec
instance Koshucode.Baala.Base.Text.Comment.Texts Koshucode.Baala.Base.Text.Comment.CommentDoc
instance Koshucode.Baala.Base.Text.Comment.Texts Koshucode.Baala.Base.Text.Comment.CommentSec


-- | Additional functions for pairs.
module Koshucode.Baala.Base.Prelude.Pair

-- | Apply function to <a>fst</a> element.
mapFst :: (a -> c) -> (a, b) -> (c, b)

-- | Apply function to <a>snd</a> element.
mapSnd :: (b -> c) -> (a, b) -> (a, c)

-- | Cons up an element to <a>fst</a> list.
consFst :: a -> Map ([a], b)

-- | Cons up an element to <a>snd</a> list.
consSnd :: b -> Map (a, [b])

-- | Apply function to <a>fst</a> element in functor data.
--   
--   <pre>
--   &gt;&gt;&gt; mapFstTo length $ Just ("aa", "bbbb")
--   Just (2, "bbbb")
--   </pre>
mapFstTo :: (Functor m) => (a -> c) -> m (a, b) -> m (c, b)

-- | Apply function to <a>snd</a> element in functor data.
--   
--   <pre>
--   &gt;&gt;&gt; mapSndTo length $ Just ("aa", "bbbb")
--   Just ("aa", 4)
--   </pre>
mapSndTo :: (Functor m) => (b -> c) -> m (a, b) -> m (a, c)

-- | Create right pair from either pair.
--   
--   <pre>
--   &gt;&gt;&gt; right2 (Right 'a', Right 'b') :: Either Char (Char, Char)
--   Right ('a','b')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; right2 (Left 'a', Right 'b') :: Either Char (Char, Char)
--   Left 'a'
--   </pre>
right2 :: (Either a b, Either a c) -> Either a (b, c)

-- | Create right triple from either triple.
right3 :: (Either a b, Either a c, Either a d) -> Either a (b, c, d)

-- | Create right quadruple from either quadruple.
right4 :: (Either a b, Either a c, Either a d, Either a e) -> Either a (b, c, d, e)

-- | Monadic sequencing of <a>fst</a> elements.
sequenceFst :: (Monad m) => [(m a, b)] -> m [(a, b)]

-- | Monadic sequencing of <a>snd</a> elements.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceSnd [("a", Just "x"), ("b", Just "y")]
--   Just [("a","x"), ("b","y")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceSnd [("a", Just "x"), ("b", Nothing)]
--   Nothing
--   </pre>
sequenceSnd :: (Monad m) => [(a, m b)] -> m [(a, b)]


-- | Reexport list.
module Koshucode.Baala.Base.Prelude.Import

-- | Composition of monadic functions.
(<.>) :: (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: Traversable t => forall (m :: * -> *) a. Monad m => t (m a) -> m (t a)

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | <tt><a>guard</a> b</tt> is <tt><a>pure</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>empty</a> if <tt>b</tt> is <a>False</a>.
guard :: Alternative f => Bool -> f ()

-- | Strict bytestring.
type Bs = ByteString

-- | Lazy bytestring.
type Bz = ByteString

-- | Convert string into lazy bytestring.
stringBz :: String -> Bz
class Default a
def :: Default a => a

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | Same as <a>lookup</a> in <tt>Data.Map</tt> module.
lookupMap :: (Ord k) => k -> Map k a -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | Defines the exit codes that a program can return.
data ExitCode :: *

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as it it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is not an <a>IOError</a>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <tt>catch</tt> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | Same as <a>empty</a>.
docEmpty :: Doc

-- | Same as <a>hang</a>.
docHang :: Doc -> Int -> Doc -> Doc

-- | Same as <a>zeroWidthText</a>.
docZero :: String -> Doc


-- | Queue.
module Koshucode.Baala.Base.Prelude.Queue

-- | First-in first-out list.
data Queue a

-- | Create queue from list.
qFrom :: [a] -> Queue a

-- | Convert queue to list.
qTo :: Queue a -> [a]

-- | Test queue is empty.
qNull :: Queue a -> Bool

-- | Number of elements in queue.
qLength :: Queue a -> Int

-- | Enqueue element.
--   
--   <pre>
--   &gt;&gt;&gt; enq 2 $ enq 1 (B.def :: Queue Int)
--   Queue [1,2]
--   </pre>
enq :: a -> Queue a -> Queue a

-- | Enqueue multiple elements.
--   
--   <pre>
--   &gt;&gt;&gt; enqs [1,2,3] (B.def :: Queue Int)
--   Queue [1,2,3]
--   </pre>
enqs :: [a] -> Queue a -> Queue a

-- | Dequeue.
--   
--   <pre>
--   &gt;&gt;&gt; deq $ enq 2 $ enq 1 (B.def :: Queue Int)
--   (Just 1, Queue [2])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deq (B.def :: Queue Int)
--   (Nothing, Queue [])
--   </pre>
deq :: Queue a -> (Maybe a, Queue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance Data.Default.Class.Default (Koshucode.Baala.Base.Prelude.Queue.Queue a)


-- | General utilities.
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name.
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)

-- | Create named pair.
named :: (Name a) => a -> Named a

-- | Numerical index.
type Index = Int

-- | Wrap list.
type Collect a = [a] -> a

-- | Choose one of two.
class Choose m
(<|>) :: Choose m => m a -> m a -> m a
instance Koshucode.Baala.Base.Prelude.Class.Choose GHC.Base.Maybe
instance Koshucode.Baala.Base.Prelude.Class.Choose (Data.Either.Either a)


-- | Case-error versions of functions.
module Koshucode.Baala.Base.Prelude.Case

-- | Apply function unless null list.
caseNull :: (Foldable t) => (t a -> b) -> b -> t a -> b

-- | Case-null version of <a>head</a>.
--   
--   <pre>
--   &gt;&gt;&gt; headNull 0 [20, 70, 80] :: Int
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headNull 0 [] :: Int
--   0
--   </pre>
headNull :: a -> [a] -> a

-- | Case-null version of <a>tail</a>.
tailNull :: [a] -> [a] -> [a]

-- | Case-null version of <a>minimum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; minimumNull 100 [20, 70, 80] :: Int
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumNull 100 [] :: Int
--   100
--   </pre>
minimumNull :: (Ord a) => a -> [a] -> a

-- | Case-null version of <a>maximum</a>.
maximumNull :: (Ord a) => a -> [a] -> a

-- | Apply function unless 0.
caseZero :: (Eq a, Num a) => (a -> b) -> b -> a -> b

-- | Case-zero version of <a>quot</a>.
quotZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>rem</a>.
remZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>div</a>.
--   
--   <pre>
--   &gt;&gt;&gt; divZero 0 10 2 :: Int
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divZero 0 10 0 :: Int
--   0
--   </pre>
divZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>mod</a>.
modZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>quotRem</a>.
--   
--   <pre>
--   &gt;&gt;&gt; quotRemZero (0,0) 20 6 :: (Int, Int)
--   (3,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemZero (0,0) 20 0 :: (Int, Int)
--   (0,0)
--   </pre>
quotRemZero :: (Integral a) => (a, a) -> a -> a -> (a, a)

-- | Case-zero version of <a>divMod</a>.
divModZero :: (Integral a) => (a, a) -> a -> a -> (a, a)


-- | Line break setting for mix text.
module Koshucode.Baala.Base.MixText.LineBreak

-- | Line break setting.
data LineBreak
LineBreak :: Maybe Int -> String -> String -> String -> LineBreak

-- | Max width of line.
[breakWidth] :: LineBreak -> Maybe Int

-- | Newline string.
[breakNewline] :: LineBreak -> String

-- | Newline string for breaking long line.
[breakContinue] :: LineBreak -> String

-- | Indent string for breaking long line.
[breakIndent] :: LineBreak -> String

-- | LF: <tt>"\n"</tt>
lfString :: String

-- | CRLF: <tt>"\r\n"</tt>
crlfString :: String

-- | Line break by single space.
noBreak :: LineBreak

-- | Line break by LF.
lfBreak :: LineBreak

-- | Line break by CRLF.
crlfBreak :: LineBreak

-- | Line break by LF with 2 spaces indent and given-length column.
lf2 :: Int -> LineBreak

-- | Line break by LF with 4 spaces indent and given-length column.
lf4 :: Int -> LineBreak

-- | Line break by LF with 8 spaces indent and given-length column.
lf8 :: Int -> LineBreak

-- | Line break by CRLF with 2 spaces indent and given-length column.
crlf2 :: Int -> LineBreak

-- | Line break by CRLF with 4 spaces indent and given-length column.
crlf4 :: Int -> LineBreak

-- | Line break by CRLF with 8 spaces indent and given-length column.
crlf8 :: Int -> LineBreak
instance GHC.Classes.Ord Koshucode.Baala.Base.MixText.LineBreak.LineBreak
instance GHC.Classes.Eq Koshucode.Baala.Base.MixText.LineBreak.LineBreak
instance GHC.Show.Show Koshucode.Baala.Base.MixText.LineBreak.LineBreak
instance Data.Default.Class.Default Koshucode.Baala.Base.MixText.LineBreak.LineBreak


-- | Mix text.
module Koshucode.Baala.Base.MixText.MixText

-- | Text mixable string, text, and bytestring.
data MixText

-- | Create mix text from strict bytestring.
mixBs :: ByteString -> MixText

-- | Create mix text from lazy bytestring.
mixBz :: ByteString -> MixText

-- | Create mix text from strict text.
mixTx :: Text -> MixText

-- | Create mix text from lazy text.
mixTz :: Text -> MixText

-- | Create mix text from string.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "abc" &lt;&gt; mixString "def"
--   MixText "abcdef"
--   </pre>
mixString :: String -> MixText

-- | Create mix text from char.
mixChar :: Char -> MixText

-- | Put mix text to left edge in given-length char sequence.
--   
--   <pre>
--   &gt;&gt;&gt; mixLeft '.' 10 $ mixString "abc"
--   MixText "abc......."
--   </pre>
mixLeft :: Char -> Int -> MixText -> MixText

-- | Put mix text to right edge in given-length char sequence.
--   
--   <pre>
--   &gt;&gt;&gt; mixRight '.' 10 $ mixString "abc"
--   MixText ".......abc"
--   </pre>
mixRight :: Char -> Int -> MixText -> MixText

-- | Create mix text of given-length spaces.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "|" &lt;&gt; mixSpace 4 &lt;&gt; mixString "|"
--   MixText "|    |"
--   </pre>
mixSpace :: Int -> MixText

-- | Infix mix space.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "a" `mixSep` mixString "b"
--   MixText "a b"
--   </pre>
mixSep :: MixText -> MixText -> MixText

-- | Infix mix space.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "a" `mixSep2` mixString "b"
--   MixText "a  b"
--   </pre>
mixSep2 :: MixText -> MixText -> MixText

-- | Empty space.
mix0 :: MixText

-- | One space.
mix1 :: MixText

-- | Two-length spaces.
mix2 :: MixText

-- | Three-length spaces.
mix3 :: MixText

-- | Four-length spaces.
mix4 :: MixText

-- | Mix text of octal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixOct (12 :: Int)
--   MixText "14"
--   </pre>
mixOct :: (Integral n, Show n) => n -> MixText

-- | Mix text of decimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixDec (12 :: Int)
--   MixText "12"
--   </pre>
mixDec :: (Integral n, Show n) => n -> MixText

-- | Mix text of hexadecimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixHex (12 :: Int)
--   MixText "c"
--   </pre>
mixHex :: (Integral n, Show n) => n -> MixText

-- | Sign of number or space.
--   
--   <pre>
--   &gt;&gt;&gt; mixSign $ O.int 3
--   MixText "+"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixSign $ O.int (-3)
--   MixText "-"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixSign $ O.int 0
--   MixText " "
--   </pre>
mixSign :: (Num n, Ord n) => n -> MixText

-- | Zero-padding decimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixDecZero 6 $ O.int 123
--   MixText "000123"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixDecZero 6 $ O.int (-123)
--   MixText "-00123"
--   </pre>
mixDecZero :: (Integral n, Show n) => Int -> n -> MixText

-- | Generalized version of <a>mixDecZero</a>.
--   
--   <pre>
--   &gt;&gt;&gt; mixNumZero mixHex 6 $ O.int 123
--   MixText "00007b"
--   </pre>
mixNumZero :: (Integral n, Show n) => (n -> MixText) -> Int -> n -> MixText

-- | Append line break.
mixLine :: MixText -> MixText

-- | Append line break to each mix texts.
mixLines :: [MixText] -> MixText

-- | Soft line break, i.e., suppress at the beginning of line.
mixSoft :: MixText

-- | Hard line break, i.e., suppress only after auto line break.
mixHard :: MixText

-- | Mix text with local line break setting.
mixBreak :: LineBreak -> MixText -> MixText

-- | Block of multiple mix texts.
mixBlock :: [MixText] -> MixText

-- | Map function to mix texts directly in mix block.
--   
--   <pre>
--   &gt;&gt;&gt; let m1 = mixBlock [mixString "cd", mixString "ef" &lt;&gt; mixBlock [mixString "g"]]
--   
--   &gt;&gt;&gt; let m2 = mixBlock [mixString "ab", m1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m2
--   MixText "abcdegh"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixBlockMap mixLine m2
--   MixText "ab\r\ncd\r\nefg\r\n"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixBlockMap (\x -&gt; mixString "[" &lt;&gt; x &lt;&gt; mixString "]") m2
--   MixText "[ab][cd][efg]"
--   </pre>
mixBlockMap :: (MixText -> MixText) -> MixText -> MixText

-- | Showed mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixShow (Just 'a')
--   MixText "Just 'a'"
--   </pre>
mixShow :: (Show a) => a -> MixText

-- | Empty mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixEmpty
--   MixText ""
--   </pre>
mixEmpty :: MixText

-- | Convert mix text to lazy bytestring builder.
mixToBuilder :: LineBreak -> MixText -> Builder

-- | Convert mix text to lazy bytestring.
mixToBz :: LineBreak -> MixText -> ByteString

-- | Convert mix text to string.
mixToString :: LineBreak -> MixText -> String

-- | Convert mix text to string without line breaks.
mixToFlatString :: MixText -> String

-- | Print mix text to the standard output.
putMix :: LineBreak -> MixText -> IO ()

-- | Print mix text and newline to the standard output.
putMixLn :: LineBreak -> MixText -> IO ()

-- | Print mix text to the given output handler.
hPutMix :: LineBreak -> Handle -> MixText -> IO ()

-- | Print mix text and newline to the given output handler.
hPutMixLn :: LineBreak -> Handle -> MixText -> IO ()

-- | Print mix text lines to the standard output.
putMixLines :: LineBreak -> [MixText] -> IO ()

-- | Print mix text lines to the given output handler.
hPutMixLines :: LineBreak -> Handle -> [MixText] -> IO ()

-- | Write mix text to a file.
writeMix :: LineBreak -> FilePath -> MixText -> IO ()

-- | Output mix text to a file when the file path is given, or to the
--   standard output.
outputMix :: LineBreak -> Maybe FilePath -> MixText -> IO ()
instance GHC.Show.Show Koshucode.Baala.Base.MixText.MixText.MixText
instance GHC.Classes.Eq Koshucode.Baala.Base.MixText.MixText.MixText
instance GHC.Classes.Ord Koshucode.Baala.Base.MixText.MixText.MixText
instance Data.Default.Class.Default Koshucode.Baala.Base.MixText.MixText.MixText
instance GHC.Base.Monoid Koshucode.Baala.Base.MixText.MixText.MixText


-- | Class for constructing mix text.
module Koshucode.Baala.Base.MixText.MixClass

-- | Construct mix text.
class Mix a
mix :: Mix a => a -> MixText

-- | Enclose mix text with open and close bracket.
mixBracket :: (Mix m) => (m, m) -> MixText -> MixText

-- | Enclose mix text with bracket and space.
mixBracketS :: (Mix m) => (m, m) -> MixText -> MixText

-- | Concatenate mix texts with delimiter.
mixJoin :: (Mix m) => m -> [MixText] -> MixText

-- | Concatenate mix texts with delimiter and space.
mixJoinS :: (Mix m) => m -> [MixText] -> MixText

-- | Join with one space.
mixJoin1 :: [MixText] -> MixText

-- | Join with vertical bar.
mixJoinBar :: [MixText] -> MixText

-- | Insert infix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixInfix "-" (mix "12") (mix "34")
--   MixText "12-34"
--   </pre>
mixInfix :: (Mix m) => m -> MixText -> MixText -> MixText
instance Koshucode.Baala.Base.MixText.MixClass.Mix Koshucode.Baala.Base.MixText.MixText.MixText
instance Koshucode.Baala.Base.MixText.MixClass.Mix ()
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.ByteString.Internal.ByteString
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.ByteString.Lazy.Internal.ByteString
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.Text.Internal.Text
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.Text.Internal.Lazy.Text
instance Koshucode.Baala.Base.MixText.MixClass.Mix GHC.Base.String
instance Koshucode.Baala.Base.MixText.MixClass.Mix GHC.Types.Char
instance Koshucode.Baala.Base.MixText.MixClass.Mix GHC.Types.Int
instance Koshucode.Baala.Base.MixText.MixClass.Mix [Koshucode.Baala.Base.MixText.MixText.MixText]
instance Koshucode.Baala.Base.MixText.MixClass.Mix (GHC.Base.Maybe Koshucode.Baala.Base.MixText.MixText.MixText)


-- | Derived mix text.
module Koshucode.Baala.Base.MixText.Deriv

-- | Mix text tab character.
--   
--   <pre>
--   &gt;&gt;&gt; B.mixString "a" `mixTab` B.mixString "b"
--   MixText "a\tb"
--   </pre>
mixTab :: MixText

-- | Concatenate terms of content.
--   
--   <pre>
--   &gt;&gt;&gt; mixTerms B.mix2 [("a", "foo"), ("b", "bar")]
--   MixText "/a foo  /b bar"
--   </pre>
mixTerms :: (Mix sep, Mix c) => sep -> [(String, c)] -> MixText

-- | Create judgement using mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixJudge B.mix2 "AB" [("a", "foo"), ("b", "bar")]
--   MixText "|-- AB  /a foo  /b bar"
--   </pre>
mixJudge :: (Mix sep, Mix cl, Mix c) => sep -> cl -> [(String, c)] -> MixText


-- | Encode using mix text.
module Koshucode.Baala.Base.MixText.MixEncode

-- | Encode via mix text.
class MixEncode a
mixEncode :: MixEncode a => a -> MixText

-- | Encode with shortener.
class MixShortEncode a
mixShortEncode :: MixShortEncode a => Shorten -> a -> MixText

-- | <a>mixShortEncode</a> with no shortener.
mixIdEncode :: (MixShortEncode a) => a -> MixText

-- | Convert string to short sign.
type Shorten = String -> Maybe String

-- | Shorten which does not shorten strings.
noShorten :: Shorten
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode GHC.Types.Bool


-- | Simple functions for parsing command-line options. This module is
--   based on <a>System.Console.GetOpt</a>.

-- | <i>Deprecated: Use Koshucode.Baala.System.CliParser instead</i>
module Koshucode.Baala.Base.IO.SimpleOption

-- | Single letter options, like <tt>h</tt> of <tt>-h</tt>.
type ShortOption = Char

-- | Long name options, like <tt>help</tt> of <tt>--help</tt>.
type LongOption = String

-- | Simple option.
type SimpleOption = SimpleOption' LongOption

-- | Simple option.
data SimpleOption' a

-- | Option definition.
type SimpleOptionDescr = OptDescr SimpleOption

-- | Set of option definitions.
type SimpleOptions = [SimpleOptionDescr]

-- | Option definition for flag (switch) type.
--   
--   <pre>
--   flag ['f'] ["foo"] "Echo foo"
--   </pre>
flag :: [ShortOption] -> [LongOption] -> String -> SimpleOptionDescr

-- | Option definition with optional one parameter.
--   
--   <pre>
--   opt [] ["bar"] "text" "Echo bar or text"
--   </pre>
opt :: [ShortOption] -> [LongOption] -> String -> String -> SimpleOptionDescr

-- | Option definition with required one parameter.
--   
--   <pre>
--   req [] ["baz"] "text" "Echo baz and text"
--   </pre>
req :: [ShortOption] -> [LongOption] -> String -> String -> SimpleOptionDescr

-- | Get flag of <a>flag</a>-type option.
getFlag :: [SimpleOption] -> LongOption -> Bool

-- | Get parameter list of <a>opt</a>-type option.
getOpt :: [SimpleOption] -> LongOption -> [String]

-- | Get parameter list of <a>req</a>-type option.
getReq :: [SimpleOption] -> LongOption -> [String]

-- | Result of parsing command-line parameters, consist of (1) error
--   message or (2) options and non-option parameters.
type ParseResult' opt = Either [String] ([opt], [String])

-- | String-type parse result.
type ParseResult = ParseResult' SimpleOption

-- | Parse parameters.
--   
--   <pre>
--   &gt;&gt;&gt; parse [help, version] ["-h", "foo", "bar"]
--   Right ([SimpleFlag "help"],["foo","bar"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parse [opt [] ["a"] "text" "optional text"] ["--a", "--a=foo", "bar"]
--   Right ([SimpleOpt "a" Nothing, SimpleOpt "a" (Just "foo")], ["bar"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parse [req [] ["a"] "text" "required text"] ["--a=foo", "bar"]
--   Right ([SimpleReq "a" "foo"], ["bar"])
--   </pre>
parse :: SimpleOptions -> [String] -> ParseResult

-- | Parse command-line parameters.
parseCommand :: SimpleOptions -> IO ParseResult

-- | Predefined <tt>-h</tt> or <tt>--help</tt> option.
--   
--   <pre>
--   flag "h" ["help"] "Show help message"
--   </pre>
help :: SimpleOptionDescr

-- | Create help message.
helpMessage :: [String] -> SimpleOptions -> String

-- | Print help message.
printHelp :: [String] -> SimpleOptions -> IO ()

-- | Predefined <tt>-V</tt> or <tt>--version</tt> option.
--   
--   <pre>
--   flag "V" ["version"] "Show version number"
--   </pre>
version :: SimpleOptionDescr

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.IO.SimpleOption.SimpleOption' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.IO.SimpleOption.SimpleOption' a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.IO.SimpleOption.SimpleOption' a)


-- | Split lists.
module Koshucode.Baala.Base.List.Split

-- | Split elements into subelements.
type Split1 t a = t a -> Maybe (t a)

-- | Split list into sublist.
type SplitList1 a = Split1 [] a

-- | Split elements into two subelements.
type Split2 t a = t a -> Maybe (t a, t a)

-- | Split list into two sublists.
type SplitList2 a = Split2 [] a

-- | Split elements into before-elem-after parts.
type Split3e t a = t a -> Maybe (t a, a, t a)

-- | Split list into before-elem-after parts.
type SplitList3e a = Split3e [] a

-- | Split elements into three subelements.
type Split3 t a = t a -> Maybe (t a, t a, t a)

-- | Split list into three sublists.
type SplitList3 a = Split3 [] a

-- | Drop sublist.
dropSubBy :: SplitList2 a -> SplitList1 a

-- | Drop prefix part from a list. This function is similar to
--   <a>stripPrefix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "abc" "abcdefghi"
--   Just "defghi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "" "abcdefghi"
--   Just "abcdefghi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "xyz" "abcdefghi"
--   Nothing
--   </pre>
dropSub :: (Eq a) => [a] -> SplitList1 a

-- | Split list by given predicate.
splitSubBy :: SplitList2 a -> SplitList3 a

-- | Split list by given sublist.
--   
--   <pre>
--   &gt;&gt;&gt; splitSub "def" "abcdefghi"
--   Just ("abc","def","ghi")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitSub "" "abcdefghi"
--     Just ("","","abcdefghi")
--   </pre>
splitSub :: (Eq a) => [a] -> SplitList3 a

-- | Split list by predicate.
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "b c"
--   Left "b c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "a | b | c"
--   Right ("a ", '|', " b | c")
--   </pre>
splitBy :: (a -> Bool) -> SplitList3e a

-- | Divide list into sublists of given length.
--   
--   <pre>
--   &gt;&gt;&gt; chunks 2 "abcdefg"
--   ["ab","cd","ef","g"]
--   </pre>
chunks :: Int -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divide '|' "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divide :: (Eq a) => a -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divideBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divideBy :: (a -> Bool) -> [a] -> [[a]]

-- | Divide string into words.
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (== '|') "a|bb||ccc|"
--   ["a","bb","ccc"]
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]


-- | Set-like operation.
module Koshucode.Baala.Base.List.Set

-- | Extract duplicate elements.
--   
--   <pre>
--   &gt;&gt;&gt; duplicates "banana"
--   "ana"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duplicates "grape"
--   ""
--   </pre>
duplicates :: (Ord a) => [a] -> [a]

-- | Test list has duplicated elements.
--   
--   <pre>
--   &gt;&gt;&gt; duplicated "banana"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duplicated "grape"
--   False
--   </pre>
duplicated :: (Ord a) => Test [a]

-- | Remove duplicate elements.
--   
--   <pre>
--   &gt;&gt;&gt; unique "banana"
--   "ban"
--   </pre>
unique :: (Ord a) => [a] -> [a]

-- | Union list to base list.
--   
--   <pre>
--   &gt;&gt;&gt; unionUp "cde" "abc"
--   "deabc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; List.union "cde" "abc"
--   "cdeab"
--   </pre>
unionUp :: (Eq a) => [a] -> [a] -> [a]

-- | Filter by set membership. <tt>keepMember</tt> <i>A</i> <i>B</i> is
--   same to the intersection of <i>A</i> and <i>B</i>, except for the
--   ordering of <i>B</i> is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; keepMember "cba" "abcdefg"
--   "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; keepMember "abcdefg" "cba"
--   "cba"
--   </pre>
keepMember :: (Ord a) => [a] -> [a] -> [a]

-- | Anti-filter by set membership. <tt>omitMember</tt> <i>A</i> <i>B</i>
--   is same to <i>B</i> minus <i>f</i>A, except for the ordering of
--   <i>B</i> is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; omitMember "cba" "abcdefg"
--   "defg"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; omitMember "abcdefg" "cba"
--   ""
--   </pre>
omitMember :: (Ord a) => [a] -> [a] -> [a]

-- | Test sublist.
--   
--   <pre>
--   &gt;&gt;&gt; sublist "cab" "abcdefg"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sublist "cab" "dec"
--   False
--   </pre>
sublist :: (Ord a) => [a] -> [a] -> Bool

-- | Convert to set-like list, in other words, remove duplicate elements
--   and sort list.
--   
--   <pre>
--   &gt;&gt;&gt; setList "abracadabra"
--   "abcdr"
--   </pre>
setList :: (Ord a) => [a] -> [a]

-- | Set-like equality, in other words, duplication and ordering are
--   ignored.
--   
--   <pre>
--   &gt;&gt;&gt; setEq "abc" "bca"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setEq "abc" "ab"
--   False
--   </pre>
setEq :: (Ord a) => [a] -> [a] -> Bool

-- | Test two list has no elements in common.
--   
--   <pre>
--   &gt;&gt;&gt; disjoint "abc" "de"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disjoint "abc" "cde"
--   False
--   </pre>
disjoint :: (Eq a) => [a] -> [a] -> Bool

-- | Test two list has some common elements.
--   
--   <pre>
--   &gt;&gt;&gt; overlap "abc" "de"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; overlap "abc" "cde"
--   True
--   </pre>
overlap :: (Eq a) => [a] -> [a] -> Bool


-- | List utilities.
module Koshucode.Baala.Base.List.List

-- | Test list is not empty.
notNull :: Test [a]

-- | Test list has single element.
isSingleton :: Test [a]

-- | Test lengths of two lists are same.
--   
--   <pre>
--   &gt;&gt;&gt; sameLength "abc" "ABC"
--   True
--   </pre>
sameLength :: Test2 [a] [b]

-- | Test lengths of two lists are not same.
--   
--   <pre>
--   &gt;&gt;&gt; notSameLength "abc" "ABC"
--   False
--   </pre>
notSameLength :: Test2 [a] [b]

-- | Take first element; if empty list is given, returns empty list.
--   
--   <pre>
--   &gt;&gt;&gt; takeFirst "abc"
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeFirst ""
--   ""
--   </pre>
takeFirst :: [a] -> [a]

-- | Take last element; if empty list is given, returns empty list.
--   
--   <pre>
--   &gt;&gt;&gt; takeLast "abc"
--   "c"
--   </pre>
takeLast :: [a] -> [a]

-- | Take elements at odd positions, i.e., first, third, ...
--   
--   <pre>
--   &gt;&gt;&gt; takeOdd "abcdeft"
--   "acet"
--   </pre>
takeOdd :: [a] -> [a]

-- | Take elements at even positions. i.e., second, fourth, ...
--   
--   <pre>
--   &gt;&gt;&gt; takeEven "abcdeft"
--   "bdf"
--   </pre>
takeEven :: [a] -> [a]

-- | Take <i>N</i> elements with filler.
--   
--   <pre>
--   &gt;&gt;&gt; takeFill 0 3 [0 .. 8]
--     [0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeFill 0 5 [6 .. 8]
--     [6,7,8,0,0]
--   </pre>
takeFill :: a -> Int -> [a] -> [a]

-- | Take tail-side <i>N</i> elements with filler.
--   
--   <pre>
--   &gt;&gt;&gt; takeTailFill 0 3 [0 .. 8]
--     [6,7,8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeTailFill 0 5 [6 .. 8]
--     [0,0,6,7,8]
--   </pre>
takeTailFill :: a -> Int -> [a] -> [a]

-- | Make singleton list.
--   
--   <pre>
--   &gt;&gt;&gt; li1 'a'
--   "a"
--   </pre>
li1 :: a -> [a]

-- | Make two-element list.
--   
--   <pre>
--   &gt;&gt;&gt; li2 'a' 'b'
--   "ab"
--   </pre>
li2 :: a -> a -> [a]

-- | Make three-element list.
--   
--   <pre>
--   &gt;&gt;&gt; li3 'a' 'b' 'c'
--   "abc"
--   </pre>
li3 :: a -> a -> a -> [a]

-- | Conditional cons up.
consIf :: Bool -> a -> [a] -> [a]

-- | Range generation
type RangeBy a = a -> a -> [a]

-- | Generate range of something.
--   
--   <pre>
--   &gt;&gt;&gt; rangeBy (+ 3) 0 10
--   [0,3,6,9]
--   </pre>
rangeBy :: (Ord a) => Map a -> RangeBy a

-- | Zip optoinal elements.
--   
--   <pre>
--   &gt;&gt;&gt; zipMaybe [Just 'a', Nothing] "AB"
--   [('a','A')]
--   </pre>
zipMaybe :: [Maybe a] -> [b] -> [(a, b)]

-- | Zip filter.
--   
--   <pre>
--   &gt;&gt;&gt; zipMaybe2 [Just 'a', Nothing] "AB"
--   [('a','A')]
--   </pre>
zipMaybe2 :: [Maybe a] -> [b] -> [b]

-- | Double <a>fmap</a>.
map2 :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | Apply function to specific element.
--   
--   <pre>
--   &gt;&gt;&gt; mapAt (const '-') 3 "abcdefg"
--   "abc-efg"
--   </pre>
mapAt :: Map a -> Int -> Map [a]

-- | Apply function to reversed list.
--   
--   <pre>
--   &gt;&gt;&gt; reverseMap (take 3) "abcdefg"
--   "efg"
--   </pre>
reverseMap :: Map [a] -> Map [a]

-- | Omit elements, i.e., anti-<a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; omit (`elem` "ae") "abcdefg"
--   "bcdfg"
--   </pre>
omit :: (a -> Bool) -> Map [a]

-- | Compress continued multile elements into single elements.
--   
--   <pre>
--   &gt;&gt;&gt; squeeze (== '?') "Koshu???"
--   "Koshu?"
--   </pre>
squeeze :: (a -> Bool) -> Map [a]

-- | Compress continued white lines.
--   
--   <pre>
--   &gt;&gt;&gt; squeezeEmptyLines ["a", "b", " ", "c", "", " ", "  ", "d"]
--   ["a", "b", " ", "c", "  ", "d"]
--   </pre>
squeezeEmptyLines :: Map [String]


-- | Dots pattern.
module Koshucode.Baala.Base.List.Dots

-- | Divide dots-pattern string.
--   
--   <pre>
--   &gt;&gt;&gt; dotsStrings "abc ... xyz"
--   ["abc","...","xyz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dotsStrings "a ... h ... ... v ..."
--   ["a","...","h","...","v","..."]
--   </pre>
dotsStrings :: String -> [String]

-- | Concatenate dots-pattern strings, inserting one space between dots and
--   word.
--   
--   <pre>
--   &gt;&gt;&gt; undotsStrings ["abc", "...", "xyz"]
--   "abc ... xyz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; undotsStrings ["a", "...", "h", "...", "...", "v", "..."]
--   "a ... h ... v ..."
--   </pre>
undotsStrings :: [String] -> String

-- | Take dots-parts from string.
--   
--   <pre>
--   &gt;&gt;&gt; takeDots ["a", "...", "h", "...", "v", "..."] "abcdefghijklmnopqrstuvwxyz"
--   Just ["bcdefg","ijklmnopqrstu","wxyz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeDots ["a", "...", "h", "...", "v", "..."] "abcdefg"
--   Nothing
--   </pre>
takeDots :: [String] -> String -> Maybe [String]


-- | Utilities for association lists.
module Koshucode.Baala.Base.List.Assoc

-- | Construct assoc list by splitting base list.
assocBy :: (a -> Maybe k) -> [a] -> ([a], [(k, [a])])

-- | Check which given key is there in assoc list.
assocExist :: (Eq k) => k -> [(k, a)] -> Bool

-- | Apply monadic function to <a>snd</a> of pair.
--   
--   <pre>
--   &gt;&gt;&gt; sndM Just ("a", "b")
--   Just ("a","b")
--   </pre>
sndM :: (Monad m) => (v -> m v') -> (k, v) -> m (k, v')

-- | Lookup association list using Boolean function.
--   
--   <pre>
--   &gt;&gt;&gt; lookupBy (&gt; (4 :: Int)) [(1, "one"), (3, "three"), (5, "five")]
--   Just "five"
--   </pre>
lookupBy :: Test a -> [(a, b)] -> Maybe b

-- | Lookup assoc list that keys are truth-valued functions.
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b

-- | Create lookup function for fixed association list.
--   
--   <pre>
--   &gt;&gt;&gt; let f = assocFinder [('a', "apple"), ('b', "banana")]
--   
--   &gt;&gt;&gt; f 'a'
--   Just "apple"
--   </pre>
assocFinder :: (Ord k) => [(k, v)] -> k -> Maybe v

-- | Pick up associations that have given keys.
--   
--   <pre>
--   &gt;&gt;&gt; assocPick ["a","c"] [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]
--   </pre>
assocPick :: (Eq k) => [k] -> Map [(k, a)]

-- | Cut off associations that have given keys.
--   
--   <pre>
--   &gt;&gt;&gt; assocCut ["a","c"] [("a",1), ("b",2), ("c",3)]
--   [("b",2)]
--   </pre>
assocCut :: (Eq k) => [k] -> Map [(k, a)]

-- | Single key version of <a>assocCut</a>.
--   
--   <pre>
--   &gt;&gt;&gt; assocCut1 "b" [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]
--   </pre>
assocCut1 :: (Eq k) => k -> Map [(k, a)]

-- | Change key of assoc list.
--   
--   <pre>
--   &gt;&gt;&gt; assocRename1 "x" "a" [("a",1), ("b",2), ("c",3)]
--   [("x",1), ("b",2), ("c",3)]
--   </pre>
assocRename1 :: (Eq k) => k -> k -> Map [(k, a)]

-- | Compose two assocs.
--   
--   <pre>
--   &gt;&gt;&gt; assocCompose [("A","H"), ("B","J")] [("H","P"), ("H","Q"), ("I","R"), ("J","S")]
--   [("A","P"), ("A","Q"), ("B","S")]
--   </pre>
assocCompose :: (Eq b) => [(a, b)] -> [(b, c)] -> [(a, c)]

-- | Meet two assocs.
--   
--   <pre>
--   &gt;&gt;&gt; assocMeet [("A","H"), ("B","J")] [("H","P"), ("H","Q"), ("I","R"), ("J","S")]
--   [("A","H","P"), ("A","H","Q"), ("B","J","S")]
--   </pre>
assocMeet :: (Eq b) => [(a, b)] -> [(b, c)] -> [(a, b, c)]

-- | Snip <i>b</i> from sequence <i>a</i>.
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]

-- | Gather (<i>k</i>, <i>v</i>) to <a>Map</a> <i>k</i> [<i>v</i>].
--   
--   <pre>
--   &gt;&gt;&gt; gatherToMap [(1 :: Int, 'a'), (2, 'b'), (1, 'c')]
--   fromList [(1,"ca"),(2,"b")]
--   </pre>
gatherToMap :: (Ord k) => [(k, v)] -> Map k [v]

-- | Gather (<i>v</i>, <i>k</i>) to <a>Map</a> <i>k</i> [<i>v</i>].
gatherToMapSwap :: (Ord k) => [(v, k)] -> Map k [v]

-- | Gather values of duplicable associations.
--   
--   <pre>
--   &gt;&gt;&gt; gatherToAssoc [(1 :: Int, 'a'), (2, 'b'), (1, 'c')]
--   [(1,"ca"), (2,"b")]
--   </pre>
gatherToAssoc :: (Ord k) => [(k, v)] -> [(k, [v])]


-- | Additional prelude.
module Koshucode.Baala.Base.Prelude


-- | Snipping elements.
module Koshucode.Baala.Base.List.Snip

-- | Snipping elements using indicies.
type Snip a = [Int] -> Map [a]

-- | Snip for differenct type values.
type Snip2 a b = (Snip a, Snip b)

-- | Indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; snipIndex "bdk" "abcdefg"
--   [1,3]
--   </pre>
snipIndex :: (Eq a) => [a] -> [a] -> [Int]

-- | Indicies of shared-and-unknown elements.
--   
--   <pre>
--   &gt;&gt;&gt; snipIndexFull "bcx" "abcdefg"
--   [1,2,-1]
--   </pre>
snipIndexFull :: (Eq a) => [a] -> [a] -> [Int]

-- | Left-and-right indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; snipIndexBoth "abc" "bcd"
--   ([1,2], [0,1])
--   </pre>
snipIndexBoth :: (Ord a) => [a] -> [a] -> ([Int], [Int])

-- | Pick up indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; [1,3] `snipFrom` "abcdefg"
--   "bd"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,3] `snipFrom` "ABCDEFG"
--   "BD"
--   </pre>
snipFrom :: Snip a

-- | Cut off indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; (snipIndex "ce" "abcdefg") `snipOff` "ABCDEFG"
--   "ABDFG"
--   </pre>
snipOff :: Snip a

-- | Pair of picking-up and cutting-off elements.
--   
--   <pre>
--   &gt;&gt;&gt; (snipIndex "ce" "abcdefg") `snipBoth` "ABCDEFG"
--   ("CE", "ABDFG")
--   </pre>
snipBoth :: [Int] -> [a] -> ([a], [a])

-- | Take shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" `snipShare` "bcefg"
--   "bc"
--   </pre>
snipShare :: (Eq a) => Bin [a]

-- | Take left-side elements.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" `snipLeft` "bcefg"
--   "ad"
--   </pre>
snipLeft :: (Eq a) => Bin [a]

-- | Take right-side elements.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" `snipRight` "bcefg"
--   "efg"
--   </pre>
snipRight :: (Eq a) => Bin [a]

-- | Move indexed elements to the front.
--   
--   <pre>
--   &gt;&gt;&gt; (snipIndex "cd" "abcdefg") `snipForward` "ABCDEFG"
--   "CDABEFG"
--   </pre>
snipForward :: Snip a

-- | Move indexed elements to the rear.
--   
--   <pre>
--   &gt;&gt;&gt; (snipIndex "cd" "abcdefg") `snipBackward` "ABCDEFG"
--   "ABEFGCD"
--   </pre>
snipBackward :: Snip a

-- | Double forward.
snipForward2 :: Snip2 a b

-- | Double backward.
snipBackward2 :: Snip2 a b

-- | Reorder elements.
--   
--   <pre>
--   &gt;&gt;&gt; snipOrder "bca" "abc" "ABC"
--   "BCA"
--   </pre>
snipOrder :: (Eq a) => [a] -> [a] -> Map [c]


-- | Sort by ascending order or descending order.
module Koshucode.Baala.Base.List.Order

-- | Data for indicating order.
data OrderCap a

-- | Ascending order
Asc :: a -> OrderCap a

-- | Descending order
Desc :: a -> OrderCap a

-- | Select order cap for ordering value. <a>GT</a> and <a>EQ</a> mean
--   <a>Asc</a>, <a>LT</a> means <a>Desc</a>.
orderingCap :: (Ordering, a) -> OrderCap a

-- | Sort by capped name.
--   
--   <pre>
--   &gt;&gt;&gt; sortByName (words "a b c") [Asc "b"] [[1,3,3], [1,2,3], [1,1,3 :: Int]]
--   [[1,1,3], [1,2,3], [1,3,3]]
--   </pre>
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]

-- | Sort elements by function result.
--   
--   <pre>
--   &gt;&gt;&gt; sortWith length $ words "aaa b ccc dd"
--   ["b", "dd", "aaa", "ccc"]
--   </pre>
sortWith :: (Ord a, Ord b) => (a -> b) -> Map [a]

-- | Ranking function.
type Ranking n a = Int  Number of the top rank. -> [OrderCap n]  Ranking specification. -> [n]  Term names. -> [[a]]  List of tuples. -> ([Int], [[a]])  Ranks and sorted data.

-- | Sort and numbering like 1234.
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a

-- | Sort and rank like 1223.
--   
--   <pre>
--   &gt;&gt;&gt; sortByNameDenseRank 1 [Asc "a"] ["a", "b"] [["b", "y"], ["a", "x"], ["a", "y"]]
--   ([1,1,2], [["a","x"], ["a","y"], ["b","y"]])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortByNameDenseRank 0 [Asc "b"] ["a", "b"] [["b", "y"], ["a", "x"], ["a", "y"]]
--   ([0,1,1], [["a","x"], ["a","y"], ["b","y"]])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortByNameDenseRank 0 [Desc "a"] ["a", "b"] [["b", "y"], ["a", "x"], ["a", "y"]]
--   ([0,1,1], [["b","y"], ["a","x"], ["a","y"]])
--   </pre>
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a

-- | Sort and rank like 1224.
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a

-- | 1223 ranking start with given number.
--   
--   <pre>
--   &gt;&gt;&gt; denseRankFrom (1 :: Int) "abbc"
--   [1,2,2,3]
--   </pre>
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]

-- | 1224 ranking start with given number.
--   
--   <pre>
--   &gt;&gt;&gt; gapRankFrom (1 :: Int) "abbc"
--   [1,2,2,4]
--   </pre>
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.List.Order.OrderCap a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.List.Order.OrderCap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.List.Order.OrderCap a)


-- | File path and content in lazy bytestring.
module Koshucode.Baala.Base.IO.BzFile

-- | File path and content in lazy bytestring. The function
--   <a>readBzFile</a> creates:
--   
--   <ul>
--   <li><a>BzFile</a> with content and <a>Nothing</a>-exception on
--   success,</li>
--   <li><a>BzFile</a> with empty content and <a>Just</a>-exception on
--   failure.</li>
--   </ul>
data BzFile
BzFile :: FilePath -> Bz -> Maybe SomeException -> BzFile

-- | Path of file.
[bzFilePath] :: BzFile -> FilePath

-- | File content as lazy bytestring.
[bzFileContent] :: BzFile -> Bz

-- | Exception when reading file.
[bzFileException] :: BzFile -> Maybe SomeException

-- | Read file from given path.
readBzFile :: FilePath -> IO BzFile

-- | Read file content as lazy bytestring.
tryReadFile :: (Exception e) => FilePath -> IO (Either e Bz)
instance GHC.Show.Show Koshucode.Baala.Base.IO.BzFile.BzFile


-- | Encoding.
module Koshucode.Baala.Base.IO.Encoding

-- | Set I/O handle for Koshucode output.
hSetKoshuOutput :: Handle -> IO ()

-- | Encoding judgement string.
--   
--   <pre>
--   &gt;&gt;&gt; currentEncodings
--   "|-- ENCODING  /content 'UTF-8  /file 'UTF-8"
--   </pre>
currentEncodings :: IO String

-- | Program name and command-line arguments. This function removes carrige
--   returns from the arguments.
progAndArgs :: IO (String, [String])


-- | Retrieve via HTTP.
module Koshucode.Baala.Base.IO.Http

-- | URI.
type UriText = String

-- | Pair of protocol name and proxy URI.
type HttpProxy = (String, Maybe UriText)

-- | Get HTTP content as lazy bytestring.
uriContent :: [HttpProxy] -> UriText -> IO (Either (Int, String) Bz)

-- | Text message of HTTP exception.
httpExceptionSummary :: HttpException -> String


-- | Convert to <a>Doc</a> pretty printer.
module Koshucode.Baala.Base.Text.PPrint

-- | Convert to <a>Doc</a> pretty printer.
class PPrint a
pprint :: PPrint a => a -> Doc

-- | Concatenate docs horizontally with space, same as <a>hsep</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pprintH ["abc", "def"]
--   abc def
--   </pre>
pprintH :: (PPrint a) => [a] -> Doc

-- | Concatenate docs vertically, same as <a>vcat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pprintV ["abc", "def"]
--   abc
--   def
--   </pre>
pprintV :: (PPrint a) => [a] -> Doc

-- | Wrap doc with open and close docs.
--   
--   <pre>
--   &gt;&gt;&gt; pprintWraps "(" ")" "abc"
--   ( abc )
--   </pre>
pprintWraps :: (PPrint a, PPrint b) => a -> a -> b -> Doc
instance Koshucode.Baala.Base.Text.PPrint.PPrint Text.PrettyPrint.HughesPJ.Doc
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Types.Int
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Integer.Type.Integer
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Base.String


-- | Mix text.
module Koshucode.Baala.Base.MixText


-- | Bundle of list modules.
module Koshucode.Baala.Base.List


-- | I/O point: file, standard input, direct text, etc.
module Koshucode.Baala.Base.IO.IOPoint

-- | Named I/O handle.
data NamedHandle
NamedHandle :: String -> Handle -> NamedHandle

-- | Name of handle
[handleName] :: NamedHandle -> String

-- | I/O handle
[handle] :: NamedHandle -> Handle

-- | I/O point: file, standard input, direct text, etc.
data IOPoint

-- | Context directory and target path
IOPointFile :: FilePath -> FilePath -> IOPoint

-- | Universal resource identifier
IOPointUri :: String -> IOPoint

-- | Code itself
IOPointText :: (Maybe String) -> Code -> IOPoint

-- | Custom I/O
IOPointCustom :: String -> Bz -> IOPoint

-- | Sandard input
IOPointStdin :: IOPoint

-- | Sandard output
IOPointStdout :: IOPoint

-- | Output handler
IOPointOutput :: NamedHandle -> IOPoint

-- | Name of I/O point, i.e., <tt>"file"</tt>, <tt>"url"</tt>,
--   <tt>"text"</tt>, <tt>"stdin"</tt>, or <tt>"stdout"</tt>.
ioPointType :: IOPoint -> String

-- | Name of I/O point.
ioPointText :: IOPoint -> String

-- | Create I/O point.
ioPointFrom :: FilePath -> FilePath -> IOPoint

-- | Create I/O points from using stdin, texts itself, filenames, and urls.
ioPointList :: Bool -> [Code] -> FilePath -> [FilePath] -> [IOPoint]

-- | Numbered I/O point.
data NIOPoint
NIOPoint :: Int -> IOPoint -> NIOPoint

-- | Sequential number (0 for unnumbered, &gt; 0 for numbered)
[nioNumber] :: NIOPoint -> Int

-- | I/O point
[nioPoint] :: NIOPoint -> IOPoint

-- | Create input point for given lazy bytestring.
--   
--   <pre>
--   &gt;&gt;&gt; nioFrom "abc"
--   NIOPoint {nioNumber = 0, nioPoint = IOPointText Nothing "abc"}
--   </pre>
nioFrom :: (ToCode code) => code -> NIOPoint

-- | This implementation uses lazy bytestring as code string.
type Code = Bz

-- | Convert to code string.
class ToCode a
toCode :: ToCode a => a -> Code
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance Data.Default.Class.Default Koshucode.Baala.Base.IO.IOPoint.NIOPoint
instance Koshucode.Baala.Base.IO.IOPoint.ToCode Koshucode.Baala.Base.Prelude.Import.Bz
instance Koshucode.Baala.Base.IO.IOPoint.ToCode GHC.Base.String


-- | Suffix and prefix.
module Koshucode.Baala.Base.Text.Suffix

-- | Remove characters-delimiter prefix.
--   
--   <pre>
--   &gt;&gt;&gt; unprefix (`elem` "0123456789") '-' "12-foo"
--   "foo"
--   </pre>
unprefix :: Test Char -> Char -> StringMap

-- | Remove delimiter-characters suffix.
--   
--   <pre>
--   &gt;&gt;&gt; unsuffix (`elem` "0123456789") '-' "foo-12"
--   "foo"
--   </pre>
unsuffix :: Test Char -> Char -> StringMap

-- | Make names unique by adding integer suffixes.
--   
--   <pre>
--   &gt;&gt;&gt; uniqueNames '-' $ words "a b b c"
--   ["a", "b-1", "b-2", "c"]
--   </pre>
uniqueNames :: Char -> Map [String]


-- | Bundle of text modules.
module Koshucode.Baala.Base.Text


-- | Position on code string.
module Koshucode.Baala.Base.IO.CodePos

-- | Position on input code string.
data CodePos
CodePos :: NIOPoint -> Int -> String -> String -> CodePos

-- | Source of code
[cpSource] :: CodePos -> NIOPoint

-- | Line number
[cpLineNo] :: CodePos -> Int

-- | Code string line
[cpLineText] :: CodePos -> String

-- | Current code string
[cpText] :: CodePos -> String

-- | Column number at which code starts.
--   
--   <pre>
--   &gt;&gt;&gt; let cp = CodePos (B.nioFrom "abcdefg") 1 "abcdefg" "abc"
--   
--   &gt;&gt;&gt; cp
--   /0.1.4/
--   
--   &gt;&gt;&gt; cpColumnNo cp
--   4
--   </pre>
cpColumnNo :: CodePos -> Int

-- | Type which has code positions.
class GetCodePos a where getCP a = headNull def $ getCPs a
getCPs :: GetCodePos a => a -> [CodePos]
getCP :: GetCodePos a => a -> CodePos

-- | Value with code string.
data Codic a
Codic :: [CodePos] -> a -> Codic a

-- | Code positions.
[codicCPs] :: Codic a -> [CodePos]

-- | Value.
[uncodic] :: Codic a -> a

-- | Create value with code position.
codic :: (GetCodePos cp) => cp -> a -> Codic a

-- | Create codic value without code string.
noCodic :: a -> Codic a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.IO.CodePos.Codic a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.IO.CodePos.Codic a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.IO.CodePos.Codic a)
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.CodePos.CodePos
instance GHC.Show.Show Koshucode.Baala.Base.IO.CodePos.CodePos
instance Koshucode.Baala.Base.Text.PPrint.PPrint Koshucode.Baala.Base.IO.CodePos.CodePos
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.CodePos.CodePos
instance Data.Default.Class.Default Koshucode.Baala.Base.IO.CodePos.CodePos
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos Koshucode.Baala.Base.IO.CodePos.CodePos
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos cp => Koshucode.Baala.Base.IO.CodePos.GetCodePos [cp]
instance GHC.Base.Functor Koshucode.Baala.Base.IO.CodePos.Codic
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos (Koshucode.Baala.Base.IO.CodePos.Codic a)


-- | I/O related modules.
module Koshucode.Baala.Base.IO


-- | Abort reasons.
module Koshucode.Baala.Base.Abort.Reason

-- | Abort reason.
data AbortReason
AbortReason :: String -> [String] -> [String] -> [(AbortTag, CodePos)] -> AbortReason

-- | Reason in one line
[abortReason] :: AbortReason -> String

-- | Detailed description
[abortDetail] :: AbortReason -> [String]

-- | Additional notes for long description
[abortNote] :: AbortReason -> [String]

-- | Tag and aborting point
[abortPoint] :: AbortReason -> [(AbortTag, CodePos)]

-- | Tag on aborting point.
type AbortTag = String

-- | Abortable result, i.e., either of right result or abort reason.
type Ab a = Either AbortReason a

-- | Abortable mapping.
type AbMap a = a -> Ab a

-- | Abortable-to-abortable mapping.
type MapAb a = Ab a -> Ab a

-- | Abortable many map.
type AbManyMap a = a -> Ab [a]

-- | Abortable Boolean-valued function.
type AbTest a = a -> Ab Bool

-- | Abortable I/O.
type IOAb a = IO (Ab a)

-- | Type for abortable binary operators.
type BinAb a = a -> a -> Ab a

-- | Construct abort reason with reason text.
abortBecause :: String -> AbortReason

-- | Construct abort reason with reason and detailed text.
abortLine :: String -> String -> AbortReason

-- | Construct abort reason with reason and multilined detailed text.
abortLines :: String -> [String] -> AbortReason

-- | Construct abort reason with reason and note.
abortPage :: String -> [String] -> AbortReason

-- | Abortable process.
type Abortable cp b = cp -> MapAb b

-- | Push source information when process is aborted.
abortable :: (GetCodePos cp) => AbortTag -> Abortable cp b

-- | Extract right value or print error message.
unabort :: Ab a -> a
instance GHC.Classes.Ord Koshucode.Baala.Base.Abort.Reason.AbortReason
instance GHC.Classes.Eq Koshucode.Baala.Base.Abort.Reason.AbortReason
instance GHC.Show.Show Koshucode.Baala.Base.Abort.Reason.AbortReason


-- | Report abort reasons.
--   
--   Abortable process returns <tt>Left</tt> <a>AbortReason</a> when
--   aborted. The <a>abortable</a> function adds code positions to the
--   reason. <a>abortPrint</a> outputs aborted message in the following
--   format.
--   
--   <pre>
--   ** ABORTED  {main reason}
--   ** -------- --------------------------------------------
--   ** Detail   {detailed reason}
--   **          {detailed reason}
--   ** Source   {line #} {char #} {source}
--   **          &gt; {code string}
--   **          {line #} {char #} {source}
--   **          &gt; {code string}
--   ** Command  {program name}
--   **          {arg 1}
--   **          {arg 2}
--   </pre>
module Koshucode.Baala.Base.Abort.Report

-- | Command name and its arguments.
type CommandLine = [String]

-- | Create position and line information.
cpMessage :: (AbortTag, CodePos) -> [(String, AbortTag)]

-- | Convert abort reason to message lines.
abortMessage :: CommandLine -> AbortReason -> [String]

-- | Print abort message.
--   
--   Prepare code position and abort reason.
--   
--   <pre>
--   &gt;&gt;&gt; let cp = B.CodePos (B.nioFrom "abcdefg") 1 "abcdefg" "defg"
--   
--   &gt;&gt;&gt; let Left a = B.abortable "tag" cp $ Left $ B.abortBecause "Bad luck"
--   </pre>
--   
--   Print it.
--   
--   <pre>
--   &gt;&gt;&gt; abortPrint (words "prog x y") a
--   **
--   **  ABORTED  Bad luck
--   **  -------- ---------- ------
--   **  Source   1 4 &lt;text&gt;
--   **           &gt; defg     .. tag
--   **  Command  prog
--   **           x
--   **           y
--   **
--   </pre>
abortPrint :: CommandLine -> AbortReason -> IO ()

-- | Stop program execution abnormally.
abort :: AbortReason -> IO x

-- | Abort with a command line.
abortCommand :: CommandLine -> AbortReason -> IO x

-- | Abort when getting abort reason.
abortLeft :: Ab b -> IO b

-- | Stop on error <tt>'BUG DISCOVERED'</tt>
bug :: String -> a


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Code.Line

-- | Line number.
type LineNumber = Int

-- | Line with number.
type NumberedLine = (LineNumber, String)

-- | Line number and its content.
linesCrlfNumbered :: String -> [NumberedLine]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; linesCrlf "aaa\nbbb\r\nccc\n\nddd\n"
--   ["aaa","bbb","ccc","","ddd"]
--   </pre>
linesCrlf :: String -> [String]

-- | Create numbered lines from lazy bytestring.
linesCrlfBzNumbered :: Bz -> [NumberedLine]

-- | Split lazy bytestring by newline character sequence. This function
--   drops the BOM sequence.
linesCrlfBz :: Bz -> [Bz]

-- | Create string lines from lazy bytestring.
linesCrlfBzString :: Bz -> [String]

-- | Remove UTF-8 BOM (EF BB BF) from lazy bytestring.
dropBom :: Bz -> Bz

-- | Tokens in line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
[lineNumber] :: CodeLine a -> LineNumber

-- | Line content without newline.
[lineContent] :: CodeLine a -> String

-- | Tokens in the line.
[lineTokens] :: CodeLine a -> [a]

-- | Type for indent size.
type IndentSize = Int

-- | Calculate indent of line and pairing it.
lineIndentPair :: (a -> IndentSize) -> CodeLine a -> (IndentSize, CodeLine a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Code.Line.CodeLine a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Code.Line.CodeLine a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Code.Line.CodeLine a)
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos a => Koshucode.Baala.Base.IO.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Line.CodeLine a)


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <tt>CodeLine</tt> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <tt>CodeLine</tt>.
module Koshucode.Baala.Base.Code.Clause

-- | Tokens in clause.
data CodeClause a
CodeClause :: [CodeLine a] -> [a] -> CodeClause a

-- | Source lines of clause
[clauseLines] :: CodeClause a -> [CodeLine a]

-- | Source tokens of clause
[clauseTokens] :: CodeClause a -> [a]

-- | Clause with no tokens.
codeClauseEmpty :: CodeClause a

-- | Split lines into clause based on indent size.
--   
--   <pre>
--   &gt;&gt;&gt; splitClause [(0, "a"), (2, "b"), (0, "c"), (1, "d")]
--   (["a","b"], [(0,"c"),(1,"d")])
--   </pre>
splitClause :: Gather [(IndentSize, a)] [a]
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Code.Clause.CodeClause a)
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos a => Koshucode.Baala.Base.IO.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Clause.CodeClause a)


-- | Code scanner.
module Koshucode.Baala.Base.Code.Scan

-- | Code scanner divides input text into output tokens.
data CodeScan i o
CodeScan :: [CodeScanMap i o] -> CodeScanMap i o -> CodePos -> i -> [o] -> WordTable -> CodeScan i o

-- | Saved updater
[codeMapSaved] :: CodeScan i o -> [CodeScanMap i o]

-- | Updater
[codeMap] :: CodeScan i o -> CodeScanMap i o

-- | Code position
[codeInputPt] :: CodeScan i o -> CodePos

-- | Input text
[codeInput] :: CodeScan i o -> i

-- | Output tokens
[codeOutput] :: CodeScan i o -> [o]

-- | Collected words
[codeWords] :: CodeScan i o -> WordTable

-- | Update code scanner.
type CodeScanMap i o = Map (CodeScan i o)

-- | Collected words.
type WordTable = Map String String

-- | Test scanner at the beginning of line, i.e., no output collected.
isBol :: Test (CodeScan i o)

-- | Save current updater.
codeScanSave :: CodeScanMap i o

-- | Restore saved updater.
codeScanRestore :: CodeScanMap i o

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><a>LineNumber</a><tt>,
--   </tt><a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeScanUp :: CodeScanMap String o -> NIOPoint -> String -> [CodeLine o]

-- | Lazy bytestring version of <a>codeScanUp</a>.
codeScanUpBz :: CodeScanMap String o -> NIOPoint -> Bz -> [CodeLine o]

-- | Update <a>codeInput</a> and push result element to <a>codeOutput</a>.
codeUpdate :: i -> o -> CodeScanMap i o

-- | Update code scanner with word table.
codeUpdateWords :: WordTable -> i -> o -> CodeScanMap i o

-- | Multi-element version of <a>codeUpdate</a>.
codeUpdateList :: i -> [o] -> CodeScanMap i o

-- | Multi-element and cached version of <a>codeUpdate</a>.
codeUpdateListWords :: WordTable -> i -> [o] -> CodeScanMap i o

-- | Change mapper of code sc.
codeChange :: Map (CodeScanMap i o)
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Scan.CodeScan i o)


-- | Abort symbols
module Koshucode.Baala.Base.Abort


-- | Message list.
module Koshucode.Baala.Base.Abort.Message

-- | AD-LIB: <i>reason</i>
adlib :: String -> Ab a

-- | BUG: <i>reason</i>
bug :: String -> Ab a

-- | Unsupported feature.
unsupported :: String -> Ab a


-- | Message list.
module Koshucode.Baala.Base.Code.Message

-- | Abortable scope for code.
abCode :: (GetCodePos cp) => Abortable cp b

-- | Extra close bracket
extraCloseBracket :: Ab a

-- | Unclosed open bracket
extraOpenBracket :: Ab a


-- | Bundle of message modules.
module Koshucode.Baala.Base.Message


-- | Tree structure.
module Koshucode.Baala.Base.Code.Tree

-- | Tree of leaf and branch.
data CodeTree p a

-- | <b>Leaf:</b> Terminal of tree.
TreeL :: a -> CodeTree p a

-- | <b>Branch:</b> Bracket-type, open/close leaves, and subtrees.
TreeB :: p -> (Maybe (a, a)) -> [CodeTree p a] -> CodeTree p a

-- | Convert a list of elements to a single tree.
tree :: (Ord p, GetCodePos a) => GetBracketType p a -> Bracket p -> p -> [a] -> Ab (CodeTree p a)

-- | Convert a list of elements to trees.
trees :: (Ord p, GetCodePos a) => GetBracketType p a -> Bracket p -> [a] -> Ab [CodeTree p a]

-- | Convert tree to list of tokens.
untree :: CodeTree p a -> [a]

-- | Convert tree to list of tokens.
untrees :: [CodeTree p a] -> [a]

-- | Collect leaves in tree.
treeLeaves :: CodeTree p a -> [a]

-- | Simplify tree by removing double brackets, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Test p -> Map (CodeTree p a)

-- | Wrap trees into single tree.
treeWrap :: p -> [CodeTree p a] -> CodeTree p a

-- | Map function to all leaves. This function is similar to <a>fmap</a>,
--   but not map to bracket leaf.
treeLeafMap :: (a -> a) -> Map (CodeTree p a)

-- | Map function to all branches.
treeBranchMap :: (p -> Maybe (a, a) -> [CodeTree p a] -> CodeTree p a) -> Map (CodeTree p a)

-- | Bracket type.
data Bracket p

-- | None bracket
BracketNone :: Bracket p

-- | Open bracket
BracketOpen :: p -> Bracket p

-- | Close bracket
BracketClose :: p -> Bracket p

-- | Get a bracket type.
type GetBracketType p a = a -> Bracket p

-- | Create <a>GetBracketType</a> functions from a type-open-close table.
--   
--   <i>Example</i>
--   
--   Create bracket/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let bracket n [a, b] = (n, ((== a), (== b)))
--   
--   &gt;&gt;&gt; let pt = bracketTable [ bracket 1 "()", bracket 2 "[]" ]
--   </pre>
--   
--   Get bracket types for each chars. Types of open brackets are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [BracketNone, BracketNone,
--    BracketOpen 1, BracketNone, BracketNone,
--     BracketOpen 2, BracketNone, BracketNone, BracketClose 2,
--    BracketClose 1, BracketNone]
--   </pre>
bracketTable :: (Eq a) => [(p, (Test a, Test a))] -> GetBracketType p a
instance GHC.Classes.Ord p => GHC.Classes.Ord (Koshucode.Baala.Base.Code.Tree.Bracket p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (Koshucode.Baala.Base.Code.Tree.Bracket p)
instance GHC.Show.Show p => GHC.Show.Show (Koshucode.Baala.Base.Code.Tree.Bracket p)
instance (GHC.Classes.Ord p, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Base.Code.Tree.CodeTree p a)
instance (GHC.Classes.Eq p, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Base.Code.Tree.CodeTree p a)
instance (GHC.Show.Show p, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Base.Code.Tree.CodeTree p a)
instance GHC.Base.Functor (Koshucode.Baala.Base.Code.Tree.CodeTree p)
instance Koshucode.Baala.Base.IO.CodePos.GetCodePos a => Koshucode.Baala.Base.IO.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Tree.CodeTree p a)


-- | Convert infixed-operator trees into prefixed-operator trees.
module Koshucode.Baala.Base.Code.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
--   
--   <pre>
--   &gt;&gt;&gt; infixHeight Just [('.', Right 3), (':', Right 5)] &lt;$&gt; "1.2:3"
--   [Left 0, Right 3, Left 0, Right 5, Left 0]
--   </pre>
infixHeight :: (Ord b) => (a -> Maybe b) -> [(b, InfixHeight)] -> (a -> InfixHeight)

-- | Split branches in a given tree at infixed binary operators.
infixToPrefix :: (Map a, Map a, Map a) -> (a -> InfixHeight) -> Collect (InfixTree p a) -> InfixMapper p a -> InfixConv a (CodeTree p a)

-- | Intermediate infix-to-prefix conversion.
type InfixMapper p a = InfixConv a [InfixTree p a] -> InfixConv a (InfixTree p a)

-- | Infix-to-prefix conversion.

-- | <i>Warning: This is only used in defined module.</i>
type InfixConv a tree = tree -> InfixAmb a tree

-- | Code tree or ambiguous infix.

-- | <i>Warning: This is only used in defined module.</i>
type InfixAmb a tree = Either [(InfixHeight, a)] tree

-- | Code tree with infix height.

-- | <i>Warning: This is only used in defined module.</i>
type InfixTree p a = CodeTree p (InfixHeight, a)


-- | Syntactic functions.
module Koshucode.Baala.Base.Code


-- | Bundle of base modules.
module Koshucode.Baala.Base
