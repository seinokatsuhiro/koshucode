-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.209.0.0


-- | Suffix and prefix.
module Koshucode.Baala.Base.Text.Suffix

-- | Remove characters-delimiter prefix.
--   
--   <pre>
--   &gt;&gt;&gt; unprefix (`elem` "0123456789") '-' "12-foo"
--   "foo"
--   </pre>
unprefix :: Test Char -> Char -> StringMap

-- | Remove delimiter-characters suffix.
--   
--   <pre>
--   &gt;&gt;&gt; unsuffix (`elem` "0123456789") '-' "foo-12"
--   "foo"
--   </pre>
unsuffix :: Test Char -> Char -> StringMap

-- | Make names unique by adding integer suffixes.
--   
--   <pre>
--   &gt;&gt;&gt; uniqueNames '-' $ words "a b b c"
--   ["a", "b-1", "b-2", "c"]
--   </pre>
uniqueNames :: Char -> Map [String]


-- | Text table
module Koshucode.Baala.Base.Text.TextTable

-- | Position in text table.
data Position
Front :: Position
Middle :: Position
Rear :: Position

-- | Convert position symbols to <a>Position</a>.
--   
--   <pre>
--   &gt;&gt;&gt; textPos "&lt;-&gt;-"
--   [Front,Middle,Rear,Middle]
--   </pre>
textPos :: String -> [Position]

-- | Cell in text table.
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
[cellText] :: Cell -> [String]
[cellWidth] :: Cell -> Int
[cellHeight] :: Cell -> Int
[cellPos] :: Cell -> Position
[cellPad] :: Cell -> Char

-- | Create text table from cell strings.
textTable :: [Position] -> [[String]] -> [[Cell]]

-- | Create text table with table heading.
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]

-- | Convert string to cell.
textCell :: Position -> String -> Cell

-- | Create rule cell.
textRuleCell :: Char -> Cell

-- | Create multi-line cell.
textBlockCell :: Position -> [String] -> Cell

-- | Create multi-line cell with padding line.
textBlockCellPlus :: Int -> Position -> [String] -> Cell

-- | Align cells.
alignTable :: [[Cell]] -> [[Cell]]

-- | Render text table.
renderTable :: String -> [[Cell]] -> [String]
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Show.Show Koshucode.Baala.Base.Text.TextTable.Cell
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.TextTable.Position
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.TextTable.Position
instance GHC.Show.Show Koshucode.Baala.Base.Text.TextTable.Position


-- | Simple document used in comments.
module Koshucode.Baala.Base.Text.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec

-- | Comment string <tt>-*- koshu -*-</tt> for The Emacs editor.
emacsModeComment :: String

-- | Wrap string in comment.
--   
--   <pre>
--   &gt;&gt;&gt; commentLine "Hello Koshu"
--   "**  Hello Koshu"
--   </pre>
commentLine :: StringMap

-- | Print strings as comment lines.
--   
--   <pre>
--   &gt;&gt;&gt; putCommentLines ["Hello", "Koshu"]
--   **  Hello
--   **  Koshu
--   </pre>
putCommentLines :: [String] -> IO ()

-- | Print strings as comment lines.
hPutCommentLines :: Handle -> [String] -> IO ()
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Show.Show Koshucode.Baala.Base.Text.Comment.CommentDoc
instance GHC.Classes.Ord Koshucode.Baala.Base.Text.Comment.CommentSec
instance GHC.Classes.Eq Koshucode.Baala.Base.Text.Comment.CommentSec
instance GHC.Show.Show Koshucode.Baala.Base.Text.Comment.CommentSec
instance Koshucode.Baala.Base.Text.Comment.Texts Koshucode.Baala.Base.Text.Comment.CommentDoc
instance Koshucode.Baala.Base.Text.Comment.Texts Koshucode.Baala.Base.Text.Comment.CommentSec


-- | Additional functions for pairs.
module Koshucode.Baala.Base.Prelude.Pair

-- | Apply function to <a>fst</a> element.
mapFst :: (a -> c) -> (a, b) -> (c, b)

-- | Apply function to <a>snd</a> element.
mapSnd :: (b -> c) -> (a, b) -> (a, c)

-- | Cons up an element to <a>fst</a> list.
consFst :: a -> Map ([a], b)

-- | Cons up an element to <a>snd</a> list.
consSnd :: b -> Map (a, [b])

-- | Apply function to <a>fst</a> element in functor data.
--   
--   <pre>
--   &gt;&gt;&gt; mapFstTo length $ Just ("aa", "bbbb")
--   Just (2, "bbbb")
--   </pre>
mapFstTo :: (Functor m) => (a -> c) -> m (a, b) -> m (c, b)

-- | Create right pair from either pair.
--   
--   <pre>
--   &gt;&gt;&gt; right2 (Right 'a', Right 'b') :: Either Char (Char, Char)
--   Right ('a','b')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; right2 (Left 'a', Right 'b') :: Either Char (Char, Char)
--   Left 'a'
--   </pre>
right2 :: (Either a b, Either a c) -> Either a (b, c)

-- | Create right triple from either triple.
right3 :: (Either a b, Either a c, Either a d) -> Either a (b, c, d)

-- | Create right quadruple from either quadruple.
right4 :: (Either a b, Either a c, Either a d, Either a e) -> Either a (b, c, d, e)

-- | Monadic sequencing of <a>fst</a> elements.
sequenceFst :: (Monad m) => [(m a, b)] -> m [(a, b)]

-- | Monadic sequencing of <a>snd</a> elements.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceSnd [("a", Just "x"), ("b", Just "y")]
--   Just [("a","x"), ("b","y")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceSnd [("a", Just "x"), ("b", Nothing)]
--   Nothing
--   </pre>
sequenceSnd :: (Monad m) => [(a, m b)] -> m [(a, b)]


-- | Reexport list.
module Koshucode.Baala.Base.Prelude.Import

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | <tt><a>guard</a> b</tt> is <tt><a>pure</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>empty</a> if <tt>b</tt> is <a>False</a>.
guard :: Alternative f => Bool -> f ()

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: Traversable t => forall (m :: * -> *) a. Monad m => t (m a) -> m (t a)

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Convert string to strict bytestring. This is same as
--   <a>fromString</a>.
stringBs :: String -> Bs

-- | Convert strict bytestring to string. This is same as <a>toString</a>.
bsString :: Bs -> String

-- | Convert string into lazy bytestring. This is same as
--   <a>fromString</a>.
stringBz :: String -> Bz

-- | Convert lazy bytestring to string. This is same as <a>toString</a>.
bzString :: Bz -> String
class Default a
def :: Default a => a

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | Same as <a>lookup</a> in <tt>Data.Map</tt> module.
lookupMap :: (Ord k) => k -> Map k a -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a

-- | Convert string to strict text. This is same as <a>pack</a>.
stringTx :: String -> Tx

-- | Convert strict text to string. This is same as <a>unpack</a>.
txString :: Tx -> String

-- | Convert string to lazy text. This is same as <a>pack</a>.
stringTz :: String -> Tz

-- | Convert lazy text to string. This is same as <a>unpack</a>.
tzString :: Tz -> String

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | Defines the exit codes that a program can return.
data ExitCode :: *

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as it it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is not an <a>IOError</a>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <tt>catch</tt> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | Same as <a>empty</a>.
docEmpty :: Doc

-- | Same as <a>hang</a>.
docHang :: Doc -> Int -> Doc -> Doc

-- | Same as <a>zeroWidthText</a>.
docZero :: String -> Doc


-- | Queue.
module Koshucode.Baala.Base.Prelude.Queue

-- | First-in first-out list.
data Queue a

-- | Create queue from list.
qFrom :: [a] -> Queue a

-- | Convert queue to list.
qTo :: Queue a -> [a]

-- | Test queue is empty.
qNull :: Queue a -> Bool

-- | Number of elements in queue.
qLength :: Queue a -> Int

-- | Enqueue element.
--   
--   <pre>
--   &gt;&gt;&gt; enq 2 $ enq 1 (B.def :: Queue Int)
--   Queue [1,2]
--   </pre>
enq :: a -> Queue a -> Queue a

-- | Enqueue multiple elements.
--   
--   <pre>
--   &gt;&gt;&gt; enqs [1,2,3] (B.def :: Queue Int)
--   Queue [1,2,3]
--   </pre>
enqs :: [a] -> Queue a -> Queue a

-- | Dequeue.
--   
--   <pre>
--   &gt;&gt;&gt; deq $ enq 2 $ enq 1 (B.def :: Queue Int)
--   (Just 1, Queue [2])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deq (B.def :: Queue Int)
--   (Nothing, Queue [])
--   </pre>
deq :: Queue a -> (Maybe a, Queue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Prelude.Queue.Queue a)
instance Data.Default.Class.Default (Koshucode.Baala.Base.Prelude.Queue.Queue a)


-- | General utilities.
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name.
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)

-- | Create named pair.
named :: (Name a) => a -> Named a

-- | Wrap list.
type Collect a = [a] -> a

-- | Choose one of two.
class Choose m
(<|>) :: Choose m => m a -> m a -> m a
instance Koshucode.Baala.Base.Prelude.Class.Choose GHC.Base.Maybe
instance Koshucode.Baala.Base.Prelude.Class.Choose (Data.Either.Either a)


-- | Case-error versions of functions.
module Koshucode.Baala.Base.Prelude.Case

-- | Apply function unless null list.
caseNull :: (Foldable t) => (t a -> b) -> b -> t a -> b

-- | Case-null version of <a>head</a>.
--   
--   <pre>
--   &gt;&gt;&gt; headNull 0 [20, 70, 80] :: Int
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headNull 0 [] :: Int
--   0
--   </pre>
headNull :: a -> [a] -> a

-- | Case-null version of <a>tail</a>.
tailNull :: [a] -> [a] -> [a]

-- | Case-null version of <a>minimum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; minimumNull 100 [20, 70, 80] :: Int
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumNull 100 [] :: Int
--   100
--   </pre>
minimumNull :: (Ord a) => a -> [a] -> a

-- | Case-null version of <a>maximum</a>.
maximumNull :: (Ord a) => a -> [a] -> a

-- | Apply function unless 0.
caseZero :: (Eq a, Num a) => (a -> b) -> b -> a -> b

-- | Case-zero version of <a>quot</a>.
quotZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>rem</a>.
remZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>div</a>.
--   
--   <pre>
--   &gt;&gt;&gt; divZero 0 10 2 :: Int
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divZero 0 10 0 :: Int
--   0
--   </pre>
divZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>mod</a>.
modZero :: (Integral a) => a -> a -> a -> a

-- | Case-zero version of <a>quotRem</a>.
--   
--   <pre>
--   &gt;&gt;&gt; quotRemZero (0,0) 20 6 :: (Int, Int)
--   (3,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemZero (0,0) 20 0 :: (Int, Int)
--   (0,0)
--   </pre>
quotRemZero :: (Integral a) => (a, a) -> a -> a -> (a, a)

-- | Case-zero version of <a>divMod</a>.
divModZero :: (Integral a) => (a, a) -> a -> a -> (a, a)


-- | Line break setting for mix text.
module Koshucode.Baala.Base.MixText.LineBreak

-- | Line break setting.
data LineBreak
LineBreak :: Maybe Int -> String -> String -> String -> LineBreak

-- | Max width of line.
[breakWidth] :: LineBreak -> Maybe Int

-- | Newline string.
[breakNewline] :: LineBreak -> String

-- | Newline string for breaking long line.
[breakContinue] :: LineBreak -> String

-- | Indent string for breaking long line.
[breakIndent] :: LineBreak -> String

-- | LF: <tt>"\n"</tt>
lfString :: String

-- | CRLF: <tt>"\r\n"</tt>
crlfString :: String

-- | Line break by single space.
noBreak :: LineBreak

-- | Line break by LF.
lfBreak :: LineBreak

-- | Line break by CRLF.
crlfBreak :: LineBreak

-- | Line break by LF with 2 spaces indent and given-length column.
lf2 :: Int -> LineBreak

-- | Line break by LF with 4 spaces indent and given-length column.
lf4 :: Int -> LineBreak

-- | Line break by LF with 8 spaces indent and given-length column.
lf8 :: Int -> LineBreak

-- | Line break by CRLF with 2 spaces indent and given-length column.
crlf2 :: Int -> LineBreak

-- | Line break by CRLF with 4 spaces indent and given-length column.
crlf4 :: Int -> LineBreak

-- | Line break by CRLF with 8 spaces indent and given-length column.
crlf8 :: Int -> LineBreak
instance GHC.Classes.Ord Koshucode.Baala.Base.MixText.LineBreak.LineBreak
instance GHC.Classes.Eq Koshucode.Baala.Base.MixText.LineBreak.LineBreak
instance GHC.Show.Show Koshucode.Baala.Base.MixText.LineBreak.LineBreak
instance Data.Default.Class.Default Koshucode.Baala.Base.MixText.LineBreak.LineBreak


-- | Mix text.
module Koshucode.Baala.Base.MixText.MixText

-- | Text mixable string, text, and bytestring.
data MixText

-- | Create mix text from strict bytestring.
mixBs :: ByteString -> MixText

-- | Create mix text from lazy bytestring.
mixBz :: ByteString -> MixText

-- | Create mix text from strict text.
mixTx :: Text -> MixText

-- | Create mix text from lazy text.
mixTz :: Text -> MixText

-- | Create mix text from string.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "abc" &lt;&gt; mixString "def"
--   MixText "abcdef"
--   </pre>
mixString :: String -> MixText

-- | Create mix text from char.
mixChar :: Char -> MixText

-- | Put mix text to left edge in given-length char sequence.
--   
--   <pre>
--   &gt;&gt;&gt; mixLeft '.' 10 $ mixString "abc"
--   MixText "abc......."
--   </pre>
mixLeft :: Char -> Int -> MixText -> MixText

-- | Put mix text to right edge in given-length char sequence.
--   
--   <pre>
--   &gt;&gt;&gt; mixRight '.' 10 $ mixString "abc"
--   MixText ".......abc"
--   </pre>
mixRight :: Char -> Int -> MixText -> MixText

-- | Create mix text of given-length spaces.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "|" &lt;&gt; mixSpace 4 &lt;&gt; mixString "|"
--   MixText "|    |"
--   </pre>
mixSpace :: Int -> MixText

-- | Infix mix space.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "a" `mixSep` mixString "b"
--   MixText "a b"
--   </pre>
mixSep :: MixText -> MixText -> MixText

-- | Infix mix space.
--   
--   <pre>
--   &gt;&gt;&gt; mixString "a" `mixSep2` mixString "b"
--   MixText "a  b"
--   </pre>
mixSep2 :: MixText -> MixText -> MixText

-- | Empty space.
mix0 :: MixText

-- | One space.
mix1 :: MixText

-- | Two-length spaces.
mix2 :: MixText

-- | Three-length spaces.
mix3 :: MixText

-- | Four-length spaces.
mix4 :: MixText

-- | Mix text of octal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixOct (12 :: Int)
--   MixText "14"
--   </pre>
mixOct :: (Integral n, Show n) => n -> MixText

-- | Mix text of decimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixDec (12 :: Int)
--   MixText "12"
--   </pre>
mixDec :: (Integral n, Show n) => n -> MixText

-- | Mix text of hexadecimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixHex (12 :: Int)
--   MixText "c"
--   </pre>
mixHex :: (Integral n, Show n) => n -> MixText

-- | Sign of number or space.
--   
--   <pre>
--   &gt;&gt;&gt; mixSign $ O.int 3
--   MixText "+"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixSign $ O.int (-3)
--   MixText "-"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixSign $ O.int 0
--   MixText " "
--   </pre>
mixSign :: (Num n, Ord n) => n -> MixText

-- | Zero-padding decimal number.
--   
--   <pre>
--   &gt;&gt;&gt; mixDecZero 6 $ O.int 123
--   MixText "000123"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixDecZero 6 $ O.int (-123)
--   MixText "-00123"
--   </pre>
mixDecZero :: (Integral n, Show n) => Int -> n -> MixText

-- | Generalized version of <a>mixDecZero</a>.
--   
--   <pre>
--   &gt;&gt;&gt; mixNumZero mixHex 6 $ O.int 123
--   MixText "00007b"
--   </pre>
mixNumZero :: (Integral n, Show n) => (n -> MixText) -> Int -> n -> MixText

-- | Append line break.
mixLine :: MixText -> MixText

-- | Append line break to each mix texts.
mixLines :: [MixText] -> MixText

-- | Soft line break, i.e., suppress at the beginning of line.
mixSoft :: MixText

-- | Hard line break, i.e., suppress only after auto line break.
mixHard :: MixText

-- | Mix text with local line break setting.
mixBreak :: LineBreak -> MixText -> MixText

-- | Block of multiple mix texts.
mixBlock :: [MixText] -> MixText

-- | Map function to mix texts directly in mix block.
--   
--   <pre>
--   &gt;&gt;&gt; let m1 = mixBlock [mixString "cd", mixString "ef" &lt;&gt; mixBlock [mixString "g"]]
--   
--   &gt;&gt;&gt; let m2 = mixBlock [mixString "ab", m1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; m2
--   MixText "abcdegh"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixBlockMap mixLine m2
--   MixText "ab\r\ncd\r\nefg\r\n"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mixBlockMap (\x -&gt; mixString "[" &lt;&gt; x &lt;&gt; mixString "]") m2
--   MixText "[ab][cd][efg]"
--   </pre>
mixBlockMap :: (MixText -> MixText) -> MixText -> MixText

-- | Showed mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixShow (Just 'a')
--   MixText "Just 'a'"
--   </pre>
mixShow :: (Show a) => a -> MixText

-- | Empty mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixEmpty
--   MixText ""
--   </pre>
mixEmpty :: MixText

-- | Convert mix text to lazy bytestring builder.
mixToBuilder :: LineBreak -> MixText -> Builder

-- | Convert mix text to lazy bytestring.
mixToBz :: LineBreak -> MixText -> ByteString

-- | Convert mix text to string.
mixToString :: LineBreak -> MixText -> String

-- | Convert mix text to string without line breaks.
mixToFlatString :: MixText -> String

-- | Print mix text to the standard output.
putMix :: LineBreak -> MixText -> IO ()

-- | Print mix text and newline to the standard output.
putMixLn :: LineBreak -> MixText -> IO ()

-- | Print mix text to the given output handler.
hPutMix :: LineBreak -> Handle -> MixText -> IO ()

-- | Print mix text and newline to the given output handler.
hPutMixLn :: LineBreak -> Handle -> MixText -> IO ()

-- | Print mix text lines to the standard output.
putMixLines :: LineBreak -> [MixText] -> IO ()

-- | Print mix text lines to the given output handler.
hPutMixLines :: LineBreak -> Handle -> [MixText] -> IO ()

-- | Write mix text to a file.
writeMix :: LineBreak -> FilePath -> MixText -> IO ()

-- | Output mix text to a file when the file path is given, or to the
--   standard output.
outputMix :: LineBreak -> Maybe FilePath -> MixText -> IO ()
instance GHC.Show.Show Koshucode.Baala.Base.MixText.MixText.MixText
instance GHC.Classes.Eq Koshucode.Baala.Base.MixText.MixText.MixText
instance GHC.Classes.Ord Koshucode.Baala.Base.MixText.MixText.MixText
instance Data.Default.Class.Default Koshucode.Baala.Base.MixText.MixText.MixText
instance GHC.Base.Monoid Koshucode.Baala.Base.MixText.MixText.MixText


-- | Class for constructing mix text.
module Koshucode.Baala.Base.MixText.MixClass

-- | Construct mix text.
class Mix a
mix :: Mix a => a -> MixText

-- | Enclose mix text with open and close bracket.
mixBracket :: (Mix m) => (m, m) -> MixText -> MixText

-- | Enclose mix text with bracket and space.
mixBracketS :: (Mix m) => (m, m) -> MixText -> MixText

-- | Concatenate mix texts with delimiter.
mixJoin :: (Mix m) => m -> [MixText] -> MixText

-- | Concatenate mix texts with delimiter and space.
mixJoinS :: (Mix m) => m -> [MixText] -> MixText

-- | Join with one space.
mixJoin1 :: [MixText] -> MixText

-- | Join with vertical bar.
mixJoinBar :: [MixText] -> MixText

-- | Insert infix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixInfix "-" (mix "12") (mix "34")
--   MixText "12-34"
--   </pre>
mixInfix :: (Mix m) => m -> MixText -> MixText -> MixText
instance Koshucode.Baala.Base.MixText.MixClass.Mix Koshucode.Baala.Base.MixText.MixText.MixText
instance Koshucode.Baala.Base.MixText.MixClass.Mix ()
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.ByteString.Internal.ByteString
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.ByteString.Lazy.Internal.ByteString
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.Text.Internal.Text
instance Koshucode.Baala.Base.MixText.MixClass.Mix Data.Text.Internal.Lazy.Text
instance Koshucode.Baala.Base.MixText.MixClass.Mix GHC.Base.String
instance Koshucode.Baala.Base.MixText.MixClass.Mix GHC.Types.Char
instance Koshucode.Baala.Base.MixText.MixClass.Mix GHC.Types.Int
instance Koshucode.Baala.Base.MixText.MixClass.Mix [Koshucode.Baala.Base.MixText.MixText.MixText]
instance Koshucode.Baala.Base.MixText.MixClass.Mix (GHC.Base.Maybe Koshucode.Baala.Base.MixText.MixText.MixText)


-- | Derived mix text.
module Koshucode.Baala.Base.MixText.Deriv

-- | Mix text tab character.
--   
--   <pre>
--   &gt;&gt;&gt; B.mixString "a" `mixTab` B.mixString "b"
--   MixText "a\tb"
--   </pre>
mixTab :: MixText

-- | Concatenate terms of content.
--   
--   <pre>
--   &gt;&gt;&gt; mixTerms B.mix2 [("a", "foo"), ("b", "bar")]
--   MixText "/a foo  /b bar"
--   </pre>

-- | <i>Deprecated: Use <tt>termsToMix2</tt> instead.</i>
mixTerms :: (Mix sep, Mix c) => sep -> [(String, c)] -> MixText

-- | Create judgement using mix text.
--   
--   <pre>
--   &gt;&gt;&gt; mixJudge B.mix2 "AB" [("a", "foo"), ("b", "bar")]
--   MixText "|-- AB  /a foo  /b bar"
--   </pre>

-- | <i>Deprecated: Use <tt>judgeMix2</tt> instead.</i>
mixJudge :: (Mix sep, Mix cl, Mix c) => sep -> cl -> [(String, c)] -> MixText


-- | Encode using mix text.
module Koshucode.Baala.Base.MixText.MixEncode

-- | Encode via mix text.
class MixEncode a where mixEncode = mixTransEncode nothing mixTransEncode _ = mixEncode
mixEncode :: MixEncode a => a -> MixText
mixTransEncode :: MixEncode a => TransString -> a -> MixText

-- | Transform string to another form.
type TransString = String -> Maybe String

-- | Encode to string.
encode :: (MixEncode a) => a -> String

-- | Encode to string.

-- | <i>Deprecated: Use <a>encode</a> instead.</i>
plainEncode :: (MixEncode a) => a -> String
instance Koshucode.Baala.Base.MixText.MixEncode.MixEncode GHC.Types.Bool


-- | Split lists.
module Koshucode.Baala.Base.List.Split

-- | Split elements into subelements.
type Split1 t a = t a -> Maybe (t a)

-- | Split list into sublist.
type SplitList1 a = Split1 [] a

-- | Split elements into two subelements.
type Split2 t a = t a -> Maybe (t a, t a)

-- | Split list into two sublists.
type SplitList2 a = Split2 [] a

-- | Split elements into before-elem-after parts.
type Split3e t a = t a -> Maybe (t a, a, t a)

-- | Split list into before-elem-after parts.
type SplitList3e a = Split3e [] a

-- | Split elements into three subelements.
type Split3 t a = t a -> Maybe (t a, t a, t a)

-- | Split list into three sublists.
type SplitList3 a = Split3 [] a

-- | Drop sublist.
dropSubBy :: SplitList2 a -> SplitList1 a

-- | Drop prefix part from a list. This function is similar to
--   <a>stripPrefix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "abc" "abcdefghi"
--   Just "defghi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "" "abcdefghi"
--   Just "abcdefghi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropSub "xyz" "abcdefghi"
--   Nothing
--   </pre>
dropSub :: (Eq a) => [a] -> SplitList1 a

-- | Split list by given predicate.
splitSubBy :: SplitList2 a -> SplitList3 a

-- | Split list by given sublist.
--   
--   <pre>
--   &gt;&gt;&gt; splitSub "def" "abcdefghi"
--   Just ("abc","def","ghi")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitSub "" "abcdefghi"
--     Just ("","","abcdefghi")
--   </pre>
splitSub :: (Eq a) => [a] -> SplitList3 a

-- | Split list by predicate.
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "b c"
--   Left "b c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "a | b | c"
--   Right ("a ", '|', " b | c")
--   </pre>
splitBy :: (a -> Bool) -> SplitList3e a

-- | Divide list into sublists of given length.
--   
--   <pre>
--   &gt;&gt;&gt; dividePer 7 ['a' .. 'z']
--   ["abcdefg", "hijklmn", "opqrstu", "vwxyz"]
--   </pre>
dividePer :: Int -> [a] -> [[a]]

-- | Divide list into <i>N</i> portions.
--   
--   <pre>
--   &gt;&gt;&gt; divideInto 4 ['a' .. 'z']
--   ["abcdefg", "hijklmn", "opqrstu", "vwxyz"]
--   </pre>
divideInto :: Int -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divide '|' "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divide :: (Eq a) => a -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divideBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divideBy :: (a -> Bool) -> [a] -> [[a]]

-- | Divide string into words.
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (== '|') "a|bb||ccc|"
--   ["a","bb","ccc"]
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]


-- | Set-like operation.
module Koshucode.Baala.Base.List.Set

-- | Extract duplicate elements.
--   
--   <pre>
--   &gt;&gt;&gt; duplicates "banana"
--   "ana"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duplicates "grape"
--   ""
--   </pre>
duplicates :: (Ord a) => [a] -> [a]

-- | Test list has duplicated elements.
--   
--   <pre>
--   &gt;&gt;&gt; duplicated "banana"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duplicated "grape"
--   False
--   </pre>
duplicated :: (Ord a) => Test [a]

-- | Remove duplicate elements.
--   
--   <pre>
--   &gt;&gt;&gt; unique "banana"
--   "ban"
--   </pre>
unique :: (Ord a) => [a] -> [a]

-- | Collect elements in occurence order.
--   
--   <pre>
--   &gt;&gt;&gt; uniqueConcat ["apple", "banana", "cocoa"]
--   "aplebnco"
--   </pre>
uniqueConcat :: (Ord a) => [[a]] -> [a]

-- | Union list to base list.
--   
--   <pre>
--   &gt;&gt;&gt; unionUp "cde" "abc"
--   "deabc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; List.union "cde" "abc"
--   "cdeab"
--   </pre>
unionUp :: (Eq a) => [a] -> [a] -> [a]

-- | Filter by set membership. <tt>keepMember</tt> <i>A</i> <i>B</i> is
--   same to the intersection of <i>A</i> and <i>B</i>, except for the
--   ordering of <i>B</i> is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; keepMember "cba" "abcdefg"
--   "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; keepMember "abcdefg" "cba"
--   "cba"
--   </pre>

-- | <i>Deprecated: Use <tt>selectShare</tt> instead.</i>
keepMember :: (Ord a) => [a] -> [a] -> [a]

-- | Anti-filter by set membership. <tt>omitMember</tt> <i>A</i> <i>B</i>
--   is same to <i>B</i> minus <i>f</i>A, except for the ordering of
--   <i>B</i> is preserved.
--   
--   <pre>
--   &gt;&gt;&gt; omitMember "cba" "abcdefg"
--   "defg"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; omitMember "abcdefg" "cba"
--   ""
--   </pre>

-- | <i>Deprecated: Use <tt>selectRight</tt> instead.</i>
omitMember :: (Ord a) => [a] -> [a] -> [a]

-- | Test sublist.
--   
--   <pre>
--   &gt;&gt;&gt; sublist "cab" "abcdefg"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sublist "cab" "dec"
--   False
--   </pre>
sublist :: (Ord a) => [a] -> [a] -> Bool

-- | Convert to set-like list, in other words, remove duplicate elements
--   and sort list.
--   
--   <pre>
--   &gt;&gt;&gt; setList "abracadabra"
--   "abcdr"
--   </pre>
setList :: (Ord a) => [a] -> [a]

-- | Set-like equality, in other words, duplication and ordering are
--   ignored.
--   
--   <pre>
--   &gt;&gt;&gt; setEq "abc" "bca"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setEq "abc" "ab"
--   False
--   </pre>
setEq :: (Ord a) => [a] -> [a] -> Bool

-- | Test two list has no elements in common.
--   
--   <pre>
--   &gt;&gt;&gt; disjoint "abc" "de"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; disjoint "abc" "cde"
--   False
--   </pre>
disjoint :: (Eq a) => [a] -> [a] -> Bool

-- | Test two list has some common elements.
--   
--   <pre>
--   &gt;&gt;&gt; overlap "abc" "de"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; overlap "abc" "cde"
--   True
--   </pre>
overlap :: (Eq a) => [a] -> [a] -> Bool


-- | Select elements.
module Koshucode.Baala.Base.List.Select

-- | Select elements using indicies.
type Select a = [Int] -> Map [a]

-- | Selection for different types.
type Select2 a b = (Select a, Select b)

-- | Indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndex "bdk" "abcdefg"
--   [1,3]
--   </pre>
selectIndex :: (Eq a) => [a] -> [a] -> [Int]

-- | Indicies of shared-and-unknown elements.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndexFull "bcx" "abcdefg"
--   [1,2,-1]
--   </pre>
selectIndexFull :: (Eq a) => [a] -> [a] -> [Int]

-- | Left-and-right indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndexBoth "abc" "bcd"
--   ([1,2], [0,1])
--   </pre>
selectIndexBoth :: (Ord a) => [a] -> [a] -> ([Int], [Int])

-- | Pick up indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; [1,3] `selectElems` "abcdefg"
--   "bd"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,3] `selectElems` "ABCDEFG"
--   "BD"
--   </pre>
selectElems :: Select a

-- | Cut off indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndex "ce" "abcdefg" `selectOthers` "ABCDEFG"
--   "ABDFG"
--   </pre>
selectOthers :: Select a

-- | Pair of picking-up and cutting-off elements.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndex "ce" "abcdefg" `selectBoth` "ABCDEFG"
--   ("CE", "ABDFG")
--   </pre>
selectBoth :: [Int] -> [a] -> ([a], [a])

-- | Take shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" `selectShare` "cbefg"
--   "bc"
--   </pre>
selectShare :: (Ord a) => Bin [a]

-- | Take left-side elements.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" `selectLeft` "bcefg"
--   "ad"
--   </pre>
selectLeft :: (Ord a) => Bin [a]

-- | Take right-side elements.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" `selectRight` "bcefg"
--   "efg"
--   </pre>
selectRight :: (Ord a) => Bin [a]

-- | Move indexed elements to the front.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndex "cd" "abcdefg" `permuteForward` "ABCDEFG"
--   "CDABEFG"
--   </pre>
permuteForward :: Select a

-- | Move indexed elements to the rear.
--   
--   <pre>
--   &gt;&gt;&gt; selectIndex "cd" "abcdefg" `permuteBackward` "ABCDEFG"
--   "ABEFGCD"
--   </pre>
permuteBackward :: Select a

-- | Double forward.
permuteForward2 :: Select2 a b

-- | Double backward.
permuteBackward2 :: Select2 a b

-- | Reorder elements.
--   
--   <pre>
--   &gt;&gt;&gt; permuteOrder "bca" "abc" "ABC"
--   "BCA"
--   </pre>
permuteOrder :: (Eq a) => [a] -> [a] -> Map [c]


-- | Picker is a data for picking target elements based on element names.
module Koshucode.Baala.Base.List.Picker

-- | Create picker.
picker :: (Ord n) => [n] -> [n] -> Picker n c

-- | Picker data.
--   
--   For example, <b>/a /b /c</b> and <b>/b /c /d /e</b> have left-proper
--   names <b>/a</b>, shared names <b>/b /c</b>, and right-proper names
--   <b>/d /e</b>.
--   
--   <pre>
--   &gt;&gt;&gt; let pk = picker (words "/a /b /c") (words "/b /c /d /e")
--   </pre>
data Picker n c
Picker :: Bool -> [Int] -> [Int] -> [n] -> [n] -> [n] -> [n] -> [n] -> [n] -> Map [c] -> Map [c] -> Map [c] -> Map [c] -> Map [c] -> Map [c] -> ([c] -> ([c], [c])) -> ([c] -> ([c], [c])) -> Picker n c

-- | <b>Test:</b> Whether shared part is empty
--   
--   <pre>
--   &gt;&gt;&gt; pkDisjoint pk
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pkDisjoint $ picker (words "/a /b /c") (words "/d /e")
--   True
--   </pre>
[pkDisjoint] :: Picker n c -> Bool

-- | <b>Index:</b> Indicies of right-shared part
--   
--   <pre>
--   &gt;&gt;&gt; pkLShareIndex pk
--   [1, 2]
--   </pre>
[pkLShareIndex] :: Picker n c -> [Int]

-- | <b>Index:</b> Indicies of left-shared part
--   
--   <pre>
--   &gt;&gt;&gt; pkRShareIndex pk
--   [0, 1]
--   </pre>
[pkRShareIndex] :: Picker n c -> [Int]

-- | <b>Name:</b> Left names
--   
--   <pre>
--   &gt;&gt;&gt; pkLNames pk
--   ["/a","/b","/c"]
--   </pre>
[pkLNames] :: Picker n c -> [n]

-- | <b>Name:</b> Right names
--   
--   <pre>
--   &gt;&gt;&gt; pkRNames pk
--   ["/b","/c","/d","/e"]
--   </pre>
[pkRNames] :: Picker n c -> [n]

-- | <b>Name:</b> Left-proper names
--   
--   <pre>
--   &gt;&gt;&gt; pkLProperNames pk
--   ["/a"]
--   </pre>
[pkLProperNames] :: Picker n c -> [n]

-- | <b>Name:</b> Left-shared names
--   
--   <pre>
--   &gt;&gt;&gt; pkLShareNames pk
--   ["/b","/c"]
--   </pre>
[pkLShareNames] :: Picker n c -> [n]

-- | <b>Name:</b> Right-proper names
--   
--   <pre>
--   &gt;&gt;&gt; pkRProperNames pk
--   ["/d","/e"]
--   </pre>
[pkRProperNames] :: Picker n c -> [n]

-- | <b>Name:</b> Right-shared names
--   
--   <pre>
--   &gt;&gt;&gt; pkRShareNames pk
--   ["/b","/c"]
--   </pre>
[pkRShareNames] :: Picker n c -> [n]

-- | <b>Map:</b> Pick left-proper part from left contents
--   
--   <pre>
--   &gt;&gt;&gt; pkLProper pk "ABC"
--   "A"
--   </pre>
[pkLProper] :: Picker n c -> Map [c]

-- | <b>Map:</b> Pick left-shared part from left contents
--   
--   <pre>
--   &gt;&gt;&gt; pkLShare pk "ABC"
--   "BC"
--   </pre>
[pkLShare] :: Picker n c -> Map [c]

-- | <b>Map:</b> Pick right-shared part from right contents
--   
--   <pre>
--   &gt;&gt;&gt; pkRShare pk "BCDE"
--   "BC"
--   </pre>
[pkRShare] :: Picker n c -> Map [c]

-- | <b>Map:</b> Pick right-proper part from right contents
--   
--   <pre>
--   &gt;&gt;&gt; pkRProper pk "BCDE"
--   "DE"
--   </pre>
[pkRProper] :: Picker n c -> Map [c]

-- | <b>Map:</b> Move shared names forward.
--   
--   <pre>
--   &gt;&gt;&gt; pkRForward pk "BCDE"
--   "BCDE"
--   </pre>
[pkRForward] :: Picker n c -> Map [c]

-- | <b>Map:</b> Move shared names backward.
--   
--   <pre>
--   &gt;&gt;&gt; pkRBackward pk "BCDE"
--   "DEBC"
--   </pre>
[pkRBackward] :: Picker n c -> Map [c]

-- | <b>Split:</b> Pick right-shared and right-proper part
--   
--   <pre>
--   &gt;&gt;&gt; pkRSplit pk "BCDE"
--   ("BC", "DE")
--   </pre>
[pkRSplit] :: Picker n c -> [c] -> ([c], [c])

-- | <b>Split:</b> Pick right-shared part and right contents
--   
--   <pre>
--   &gt;&gt;&gt; pkRAssoc pk "BCDE"
--   ("BC", "BCDE")
--   </pre>
[pkRAssoc] :: Picker n c -> [c] -> ([c], [c])
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Base.List.Picker.Picker n c)


-- | List utilities.
module Koshucode.Baala.Base.List.List

-- | Test list has single element.
isSingleton :: Test [a]

-- | Test lengths of two lists are same.
--   
--   <pre>
--   &gt;&gt;&gt; sameLength "abc" "ABC"
--   True
--   </pre>
sameLength :: Test2 [a] [b]

-- | Test lengths of two lists are not same.
--   
--   <pre>
--   &gt;&gt;&gt; notSameLength "abc" "ABC"
--   False
--   </pre>
notSameLength :: Test2 [a] [b]

-- | Take first element; if empty list is given, returns empty list.
--   
--   <pre>
--   &gt;&gt;&gt; takeFirst "abc"
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeFirst ""
--   ""
--   </pre>
takeFirst :: [a] -> [a]

-- | Take last element; if empty list is given, returns empty list.
--   
--   <pre>
--   &gt;&gt;&gt; takeLast "abc"
--   "c"
--   </pre>
takeLast :: [a] -> [a]

-- | Take middle <i>N</i> elements.
--   
--   <pre>
--   &gt;&gt;&gt; (`takeMiddle` ['A' .. 'Z']) &lt;$&gt; [-1 .. 7 :: Int]
--   ["", "", "M", "MN", "LMN", "LMNO", "KLMNO", "KLMNOP", "JKLMNOP"]
--   </pre>
takeMiddle :: Int -> [a] -> [a]

-- | Take <i>N</i> elements at the end of the list.
--   
--   <pre>
--   &gt;&gt;&gt; takeEnd 3 "ABCDEFG"
--   "EFG"
--   </pre>
takeEnd :: Int -> [a] -> [a]

-- | Take elements at odd positions, i.e., first, third, ...
--   
--   <pre>
--   &gt;&gt;&gt; takeOdd "abcdeft"
--   "acet"
--   </pre>
takeOdd :: [a] -> [a]

-- | Take elements at even positions. i.e., second, fourth, ...
--   
--   <pre>
--   &gt;&gt;&gt; takeEven "abcdeft"
--   "bdf"
--   </pre>
takeEven :: [a] -> [a]

-- | Take <i>N</i> elements with filler.
--   
--   <pre>
--   &gt;&gt;&gt; takeFill 0 3 [0 .. 8]
--     [0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeFill 0 5 [6 .. 8]
--     [6,7,8,0,0]
--   </pre>
takeFill :: a -> Int -> [a] -> [a]

-- | Take tail-side <i>N</i> elements with filler.
--   
--   <pre>
--   &gt;&gt;&gt; takeTailFill 0 3 [0 .. 8]
--     [6,7,8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeTailFill 0 5 [6 .. 8]
--     [0,0,6,7,8]
--   </pre>
takeTailFill :: a -> Int -> [a] -> [a]

-- | Take indexed chunks from <i>N</i> chunks.
--   
--   <pre>
--   &gt;&gt;&gt; takeChunks 20 [10, 0, 19, 20] [0 .. 98 :: Int]
--   [[50,51,52,53,54], [0,1,2,3,4], [95,96,97,98], []]
--   </pre>
takeChunks :: Int -> [Int] -> [a] -> [[a]]

-- | Make singleton list.
--   
--   <pre>
--   &gt;&gt;&gt; list1 'a'
--   "a"
--   </pre>
list1 :: a -> [a]

-- | Make two-element list.
--   
--   <pre>
--   &gt;&gt;&gt; list2 'a' 'b'
--   "ab"
--   </pre>
list2 :: a -> a -> [a]

-- | Make three-element list.
--   
--   <pre>
--   &gt;&gt;&gt; list3 'a' 'b' 'c'
--   "abc"
--   </pre>
list3 :: a -> a -> a -> [a]

-- | Conditional cons up.
consIf :: Bool -> a -> [a] -> [a]

-- | Range generation
type RangeBy a = a -> a -> [a]

-- | Generate range of something.
--   
--   <pre>
--   &gt;&gt;&gt; rangeBy (+ 3) 0 10
--   [0,3,6,9]
--   </pre>
rangeBy :: (Ord a) => Map a -> RangeBy a

-- | Zip optoinal elements.
--   
--   <pre>
--   &gt;&gt;&gt; zipMaybe [Just 'a', Nothing] "AB"
--   [('a','A')]
--   </pre>
zipMaybe :: [Maybe a] -> [b] -> [(a, b)]

-- | Zip filter.
--   
--   <pre>
--   &gt;&gt;&gt; zipMaybe2 [Just 'a', Nothing] "AB"
--   [('a','A')]
--   </pre>
zipMaybe2 :: [Maybe a] -> [b] -> [b]

-- | Apply function to specific element.
--   
--   <pre>
--   &gt;&gt;&gt; mapAt (const '-') 3 "abcdefg"
--   "abc-efg"
--   </pre>
mapAt :: Map a -> Int -> Map [a]

-- | Omit elements, i.e., anti-<a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; omit (`elem` "ae") "abcdefg"
--   "bcdfg"
--   </pre>
omit :: (a -> Bool) -> Map [a]

-- | Compress continued multile elements into single elements.
--   
--   <pre>
--   &gt;&gt;&gt; squeeze (== '?') "Koshu???"
--   "Koshu?"
--   </pre>
squeeze :: (a -> Bool) -> Map [a]

-- | Compress continued white lines.
--   
--   <pre>
--   &gt;&gt;&gt; squeezeEmptyLines ["a", "b", " ", "c", "", " ", "  ", "d"]
--   ["a", "b", " ", "c", "  ", "d"]
--   </pre>
squeezeEmptyLines :: Map [String]


-- | Utilities for association lists.
module Koshucode.Baala.Base.List.Assoc

-- | Construct assoc list by splitting base list.
assocBy :: (a -> Maybe k) -> [a] -> ([a], [(k, [a])])

-- | Check which given key is there in assoc list.
assocExist :: (Eq k) => k -> [(k, a)] -> Bool

-- | Lookup association list using Boolean function.
--   
--   <pre>
--   &gt;&gt;&gt; lookupBy (&gt; (4 :: Int)) [(1, "one"), (3, "three"), (5, "five")]
--   Just "five"
--   </pre>
lookupBy :: Test a -> [(a, b)] -> Maybe b

-- | Lookup assoc list that keys are truth-valued functions.
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b

-- | Create lookup function for fixed association list.
--   
--   <pre>
--   &gt;&gt;&gt; let f = assocFinder [('a', "apple"), ('b', "banana")]
--   
--   &gt;&gt;&gt; f 'a'
--   Just "apple"
--   </pre>
assocFinder :: (Ord k) => [(k, v)] -> k -> Maybe v

-- | Pick up associations that have given keys.
--   
--   <pre>
--   &gt;&gt;&gt; assocPick ["a","c"] [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]
--   </pre>
assocPick :: (Eq k) => [k] -> Map [(k, a)]

-- | Cut off associations that have given keys.
--   
--   <pre>
--   &gt;&gt;&gt; assocCut ["a","c"] [("a",1), ("b",2), ("c",3)]
--   [("b",2)]
--   </pre>
assocCut :: (Eq k) => [k] -> Map [(k, a)]

-- | Single key version of <a>assocCut</a>.
--   
--   <pre>
--   &gt;&gt;&gt; assocCut1 "b" [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]
--   </pre>
assocCut1 :: (Eq k) => k -> Map [(k, a)]

-- | Change key of assoc list.
--   
--   <pre>
--   &gt;&gt;&gt; assocRename1 "x" "a" [("a",1), ("b",2), ("c",3)]
--   [("x",1), ("b",2), ("c",3)]
--   </pre>
assocRename1 :: (Eq k) => k -> k -> Map [(k, a)]

-- | Compose two assocs.
--   
--   <pre>
--   &gt;&gt;&gt; assocCompose [("A","H"), ("B","J")] [("H","P"), ("H","Q"), ("I","R"), ("J","S")]
--   [("A","P"), ("A","Q"), ("B","S")]
--   </pre>
assocCompose :: (Eq b) => [(a, b)] -> [(b, c)] -> [(a, c)]

-- | Meet two assocs.
--   
--   <pre>
--   &gt;&gt;&gt; assocMeet [("A","H"), ("B","J")] [("H","P"), ("H","Q"), ("I","R"), ("J","S")]
--   [("A","H","P"), ("A","H","Q"), ("B","J","S")]
--   </pre>
assocMeet :: (Eq b) => [(a, b)] -> [(b, c)] -> [(a, b, c)]

-- | Snip <i>b</i> from sequence <i>a</i>.
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]

-- | Gather (<i>k</i>, <i>v</i>) to <a>Map</a> <i>k</i> [<i>v</i>].
--   
--   <pre>
--   &gt;&gt;&gt; gatherToMap [(1 :: Int, 'a'), (2, 'b'), (1, 'c')]
--   fromList [(1,"ca"),(2,"b")]
--   </pre>
gatherToMap :: (Ord k) => [(k, v)] -> Map k [v]

-- | Gather (<i>v</i>, <i>k</i>) to <a>Map</a> <i>k</i> [<i>v</i>].
gatherToMapSwap :: (Ord k) => [(v, k)] -> Map k [v]

-- | Gather values of duplicable associations.
--   
--   <pre>
--   &gt;&gt;&gt; gatherToAssoc [(1 :: Int, 'a'), (2, 'b'), (1, 'c')]
--   [(1,"ca"), (2,"b")]
--   </pre>
gatherToAssoc :: (Ord k) => [(k, v)] -> [(k, [v])]

-- | Gather values of duplicable associations.
--   
--   <pre>
--   &gt;&gt;&gt; gatherToAssocOrder [(1 :: Int, 'a'), (2, 'b'), (1, 'c')]
--   [(1,"ac"),(2,"b")]
--   </pre>
gatherToAssocOrder :: (Ord k) => [(k, v)] -> [(k, [v])]


-- | Additional prelude.
module Koshucode.Baala.Base.Prelude


-- | Position on code string.
module Koshucode.Baala.Base.Abort.CodePos

-- | Code position of string code.
type CodePos = TCodePos String

-- | Position on input code.
data TCodePos t
CodePos :: Ix -> IOPath -> Int -> t -> t -> TCodePos t

-- | Index of code source
[cpIndex] :: TCodePos t -> Ix

-- | Path of code source
[cpPath] :: TCodePos t -> IOPath

-- | Line number
[cpLineNo] :: TCodePos t -> Int

-- | Code line
[cpLineText] :: TCodePos t -> t

-- | Current code text
[cpText] :: TCodePos t -> t

-- | Character position at which code starts.
--   
--   <pre>
--   &gt;&gt;&gt; let cp = B.def { cpLineText = "abcdefg", cpText = "defg" }
--   
--   &gt;&gt;&gt; cp
--   /0.0.3/
--   
--   &gt;&gt;&gt; cpCharNo cp
--   3
--   </pre>
cpCharNo :: (Textual t) => TCodePos t -> Int

-- | Before and after text of code position.
--   
--   <pre>
--   &gt;&gt;&gt; cpSplit $ CodePos 0 "&lt;stdin&gt;" 1 "abcdefg" "defg"
--   ("abc", "defg")
--   </pre>
cpSplit :: CodePos -> (String, String)

-- | Type which has code positions.
class GetCodePos a where getCP a = headNull def $ getCPs a
getCPs :: GetCodePos a => a -> [CodePos]
getCP :: GetCodePos a => a -> CodePos

-- | Value with code string.
data Codic a
Codic :: [CodePos] -> a -> Codic a

-- | Code positions.
[codicCPs] :: Codic a -> [CodePos]

-- | Value.
[uncodic] :: Codic a -> a

-- | Create value with code position.
codic :: (GetCodePos cp) => cp -> a -> Codic a

-- | Create codic value without code string.
noCodic :: a -> Codic a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.Abort.CodePos.Codic a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.Abort.CodePos.Codic a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.Abort.CodePos.Codic a)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Koshucode.Baala.Base.Abort.CodePos.TCodePos t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => GHC.Show.Show (Koshucode.Baala.Base.Abort.CodePos.TCodePos t)
instance GHC.Base.Functor Koshucode.Baala.Base.Abort.CodePos.TCodePos
instance Koshucode.Baala.Overture.Index.GetIx (Koshucode.Baala.Base.Abort.CodePos.TCodePos t)
instance Koshucode.Baala.Overture.Misc.GetIOPath (Koshucode.Baala.Base.Abort.CodePos.TCodePos t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => GHC.Classes.Ord (Koshucode.Baala.Base.Abort.CodePos.TCodePos t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => Data.Default.Class.Default (Koshucode.Baala.Base.Abort.CodePos.TCodePos t)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos Koshucode.Baala.Base.Abort.CodePos.CodePos
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos cp => Koshucode.Baala.Base.Abort.CodePos.GetCodePos [cp]
instance GHC.Base.Functor Koshucode.Baala.Base.Abort.CodePos.Codic
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Base.Abort.CodePos.Codic a)


-- | Sort by ascending order or descending order.
module Koshucode.Baala.Base.List.Order

-- | Data for indicating order.
data OrderCap a

-- | Ascending order
Asc :: a -> OrderCap a

-- | Descending order
Desc :: a -> OrderCap a

-- | Select order cap for ordering value. <a>GT</a> and <a>EQ</a> mean
--   <a>Asc</a>, <a>LT</a> means <a>Desc</a>.
orderingCap :: (Ordering, a) -> OrderCap a

-- | Sort by capped name.
--   
--   <pre>
--   &gt;&gt;&gt; sortByName (words "a b c") [Asc "b"] [[1,3,3], [1,2,3], [1,1,3 :: Int]]
--   [[1,1,3], [1,2,3], [1,3,3]]
--   </pre>
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]

-- | Sort elements by function result.
--   
--   <pre>
--   &gt;&gt;&gt; sortWith length $ words "aaa b ccc dd"
--   ["b", "dd", "aaa", "ccc"]
--   </pre>
sortWith :: (Ord a, Ord b) => (a -> b) -> Map [a]

-- | Ranking function.
type Ranking n a = Int  Number of the top rank. -> [OrderCap n]  Ranking specification. -> [n]  Term names. -> [[a]]  List of tuples. -> ([Int], [[a]])  Ranks and sorted data.

-- | Sort and numbering like 1234.
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a

-- | Sort and rank like 1223.
--   
--   <pre>
--   &gt;&gt;&gt; sortByNameDenseRank 1 [Asc "a"] ["a", "b"] [["b", "y"], ["a", "x"], ["a", "y"]]
--   ([1,1,2], [["a","x"], ["a","y"], ["b","y"]])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortByNameDenseRank 0 [Asc "b"] ["a", "b"] [["b", "y"], ["a", "x"], ["a", "y"]]
--   ([0,1,1], [["a","x"], ["a","y"], ["b","y"]])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sortByNameDenseRank 0 [Desc "a"] ["a", "b"] [["b", "y"], ["a", "x"], ["a", "y"]]
--   ([0,1,1], [["b","y"], ["a","x"], ["a","y"]])
--   </pre>
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a

-- | Sort and rank like 1224.
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a

-- | 1223 ranking start with given number.
--   
--   <pre>
--   &gt;&gt;&gt; denseRankFrom (1 :: Int) "abbc"
--   [1,2,2,3]
--   </pre>
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]

-- | 1224 ranking start with given number.
--   
--   <pre>
--   &gt;&gt;&gt; gapRankFrom (1 :: Int) "abbc"
--   [1,2,2,4]
--   </pre>
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Base.List.Order.OrderCap a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Base.List.Order.OrderCap a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Base.List.Order.OrderCap a)


-- | Encoding.
module Koshucode.Baala.Base.IO.Encoding

-- | Set I/O handle for Koshucode output.
hSetKoshuOutput :: Handle -> IO ()

-- | Encoding judgement string.
--   
--   <pre>
--   &gt;&gt;&gt; currentEncodings
--   "|-- ENCODING  /content 'UTF-8  /file 'UTF-8"
--   </pre>
currentEncodings :: IO String

-- | Program name and command-line arguments. This function removes carrige
--   returns from the arguments.
progAndArgs :: IO (String, [String])


-- | Retrieve via HTTP.
module Koshucode.Baala.Base.IO.Http

-- | Pair of protocol name and proxy URI.
type HttpProxy = (String, Maybe IOPath)

-- | Get HTTP content as lazy bytestring. If request succeeded as 200 OK,
--   returns lazy-bytestring content in <a>Right</a> part, otherwise,
--   returns status code and message in <a>Left</a> part.
--   
--   <pre>
--   &gt;&gt;&gt; httpGet [] "https://httpbin.org/robots.txt"
--   Right "User-agent: *\nDisallow: /deny\n"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (print O.#. httpGet []) O.&lt;#!&gt; ((\c -&gt; "http://httpbin.org/status/" ++ show c) &lt;$&gt; [400 .. 404 :: Int])
--   Left (400, "BAD REQUEST")
--   Left (401, "UNAUTHORIZED")
--   Left (402, "PAYMENT REQUIRED")
--   Left (403, "FORBIDDEN")
--   Left (404, "NOT FOUND")
--   </pre>
httpGet :: [HttpProxy] -> IOPath -> IO (Either (Int, String) Bz)

-- | Get HTTP content wrapped in <tt>&lt;document&gt;</tt> tag.
--   
--   <pre>
--   &gt;&gt;&gt; httpGetDoc [] "https://httpbin.org/robots.txt"
--   Right "&lt;document id=\"https://httpbin.org/robots.txt\"\r\n&gt;User-agent: *\nDisallow: /deny\n&lt;/document&gt;\r\n"
--   </pre>
httpGetDoc :: [HttpProxy] -> IOPath -> IO (Either (Int, String) Bz)

-- | Text message of HTTP exception.
httpExceptionSummary :: HttpException -> String


-- | Convert to <a>Doc</a> pretty printer.
module Koshucode.Baala.Base.Text.PPrint

-- | Convert to <a>Doc</a> pretty printer.
class PPrint a
pprint :: PPrint a => a -> Doc

-- | Concatenate docs horizontally with space, same as <a>hsep</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pprintH ["abc", "def"]
--   abc def
--   </pre>
pprintH :: (PPrint a) => [a] -> Doc

-- | Concatenate docs vertically, same as <a>vcat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pprintV ["abc", "def"]
--   abc
--   def
--   </pre>
pprintV :: (PPrint a) => [a] -> Doc

-- | Wrap doc with open and close docs.
--   
--   <pre>
--   &gt;&gt;&gt; pprintWraps "(" ")" "abc"
--   ( abc )
--   </pre>
pprintWraps :: (PPrint a, PPrint b) => a -> a -> b -> Doc
instance Koshucode.Baala.Base.Text.PPrint.PPrint Text.PrettyPrint.HughesPJ.Doc
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Types.Int
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Integer.Type.Integer
instance Koshucode.Baala.Base.Text.PPrint.PPrint GHC.Base.String


-- | Mix text.
module Koshucode.Baala.Base.MixText


-- | Bundle of list modules.
module Koshucode.Baala.Base.List


-- | Abort reasons.
module Koshucode.Baala.Base.Abort.Reason

-- | Abort reason.
data AbortReason
AbortReason :: String -> [String] -> [String] -> [CodePosInfo] -> AbortReason

-- | Reason in one line
[abortReason] :: AbortReason -> String

-- | Detailed description
[abortDetail] :: AbortReason -> [String]

-- | Additional notes for long description
[abortNote] :: AbortReason -> [String]

-- | Tag and aborting points
[abortPoint] :: AbortReason -> [CodePosInfo]

-- | Tag on aborting point.
type AbortTag = String

-- | Source code position information.
type CodePosInfo = (CodePos, AbortTag)

-- | Upward aborting points, i.e., from callee to caller.
abortPointUp :: AbortReason -> [CodePosInfo]

-- | Abortable result, i.e., either of right result or abort reason.
type Ab a = Either AbortReason a

-- | Abortable mapping.
type AbMap a = a -> Ab a

-- | Abortable-to-abortable mapping.
type MapAb a = Ab a -> Ab a

-- | Abortable many map.
type AbManyMap a = a -> Ab [a]

-- | Abortable Boolean-valued function.
type AbTest a = a -> Ab Bool

-- | Abortable I/O.
type IOAb a = IO (Ab a)

-- | Type for abortable binary operators.
type BinAb a = a -> a -> Ab a

-- | Construct abort reason with reason text.
abortBecause :: (Textual s) => s -> AbortReason

-- | Construct abort reason with reason and detailed text.
abortLine :: (Textual s, Textual t) => s -> t -> AbortReason

-- | Construct abort reason with reason and multilined detailed text.
abortLines :: (Textual s, Textual t) => s -> [t] -> AbortReason

-- | Construct abort reason with reason and note.
abortPage :: (Textual s, Textual t) => s -> [t] -> AbortReason

-- | <a>Left</a> plus <a>abortBecause</a>.
leftBecause :: (Textual s) => s -> Ab a

-- | <a>Left</a> plus <a>abortLine</a>.
leftLine :: (Textual s, Textual t) => s -> t -> Ab a

-- | <a>Left</a> plus <a>abortLines</a>.
leftLines :: (Textual s, Textual t) => s -> [t] -> Ab a

-- | <a>Left</a> plus <a>abortPage</a>.
leftPage :: (Textual s, Textual t) => s -> [t] -> Ab a

-- | Abortable process.
type Abortable cp b = cp -> MapAb b

-- | Push source information when process is aborted.
abortable :: (GetCodePos cp) => AbortTag -> Abortable cp b

-- | Extract right value or print error message.
unabort :: Ab a -> a
instance GHC.Classes.Ord Koshucode.Baala.Base.Abort.Reason.AbortReason
instance GHC.Classes.Eq Koshucode.Baala.Base.Abort.Reason.AbortReason
instance GHC.Show.Show Koshucode.Baala.Base.Abort.Reason.AbortReason


-- | I/O point: file, standard input, direct text, etc.
module Koshucode.Baala.Base.IO.IOPoint

-- | This implementation uses lazy bytestring as input code.
type Bytes = Bz

-- | Convert to bytes.
class ToBytes a
toBytes :: ToBytes a => a -> Bytes

-- | Named I/O handle.
data NamedHandle
NamedHandle :: String -> Handle -> NamedHandle

-- | Name of handle
[handleName] :: NamedHandle -> String

-- | I/O handle
[handle] :: NamedHandle -> Handle

-- | I/O point: file, standard input, direct text, etc.
data IOPoint

-- | <b>1 Input/Output:</b> Context directory and target path.
IOPointFile :: FilePath -> FilePath -> IOPoint

-- | <b>2 Input:</b> Universal resource identifier.
IOPointUri :: IOPath -> IOPoint

-- | <b>3 Input:</b> Input bytes and its name.
IOPointText :: (Maybe String) -> Bytes -> IOPoint

-- | <b>4 Input:</b> Custom I/O.
IOPointCustom :: String -> Bz -> IOPoint

-- | <b>5 Input:</b> The sandard input.
IOPointStdin :: (Maybe String) -> IOPoint

-- | <b>6 Output:</b> The sandard output.
IOPointStdout :: (Maybe String) -> IOPoint

-- | <b>7 Output:</b> Output handler.
IOPointOutput :: NamedHandle -> IOPoint

-- | Name of I/O point, i.e., <tt>"file"</tt>, <tt>"uri"</tt>,
--   <tt>"text"</tt>, <tt>"stdin"</tt>, or <tt>"stdout"</tt>.
ioPointType :: IOPoint -> String

-- | Name of I/O point.
ioPointText :: IOPoint -> String

-- | Create I/O Point.
ioPoint :: IOPath -> IOPoint

-- | Add context directory.
ioPointDir :: FilePath -> Map IOPoint

-- | Create I/O points from using stdin, texts itself, filenames, and URIs.
ioPointTogether :: Bool -> [Bytes] -> [FilePath] -> [IOPoint]

-- | Indexed I/O point.
data IxIOPoint
IxIOPoint :: Ix -> IOPoint -> IxIOPoint

-- | Index (0 for unindexed, &gt; 0 for indexed)
[nioNumber] :: IxIOPoint -> Ix

-- | I/O point
[nioPoint] :: IxIOPoint -> IOPoint

-- | Create input point for given lazy bytestring.
--   
--   <pre>
--   &gt;&gt;&gt; codeIxIO "abc"
--   IxIOPoint {nioNumber = 0, nioPoint = IOPointText Nothing "abc"}
--   </pre>
codeIxIO :: (ToBytes code) => code -> IxIOPoint

-- | Create input point from file path.
pathIxIO :: FilePath -> IxIOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.IxIOPoint
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance Koshucode.Baala.Base.IO.IOPoint.ToBytes Koshucode.Baala.Overture.Shorthand.Bz
instance Koshucode.Baala.Base.IO.IOPoint.ToBytes GHC.Base.String
instance GHC.Show.Show Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.NamedHandle
instance Koshucode.Baala.Overture.Misc.GetIOPath Koshucode.Baala.Base.IO.IOPoint.IOPoint
instance GHC.Classes.Eq Koshucode.Baala.Base.IO.IOPoint.IxIOPoint
instance GHC.Classes.Ord Koshucode.Baala.Base.IO.IOPoint.IxIOPoint
instance Data.Default.Class.Default Koshucode.Baala.Base.IO.IOPoint.IxIOPoint
instance Koshucode.Baala.Overture.Index.GetIx Koshucode.Baala.Base.IO.IOPoint.IxIOPoint
instance Koshucode.Baala.Overture.Misc.GetIOPath Koshucode.Baala.Base.IO.IOPoint.IxIOPoint


-- | Dots pattern.
module Koshucode.Baala.Base.Text.Dots

-- | Divide dots-pattern string.
--   
--   <pre>
--   &gt;&gt;&gt; dotsStrings "abc ... xyz"
--   ["abc","...","xyz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dotsStrings "a ... h ... ... v ..."
--   ["a","...","h","...","v","..."]
--   </pre>
dotsStrings :: String -> [String]

-- | Concatenate dots-pattern strings, inserting one space between dots and
--   word.
--   
--   <pre>
--   &gt;&gt;&gt; undotsStrings ["abc", "...", "xyz"]
--   "abc ... xyz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; undotsStrings ["a", "...", "h", "...", "...", "v", "..."]
--   "a ... h ... v ..."
--   </pre>
undotsStrings :: [String] -> String

-- | Take dots-parts from string.
--   
--   <pre>
--   &gt;&gt;&gt; takeDots ["a", "...", "h", "...", "v", "..."] "abcdefghijklmnopqrstuvwxyz"
--   Just ["bcdefg","ijklmnopqrstu","wxyz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; takeDots ["a", "...", "h", "...", "v", "..."] "abcdefg"
--   Nothing
--   </pre>
takeDots :: [String] -> String -> Maybe [String]


-- | Bundle of text modules.
module Koshucode.Baala.Base.Text


-- | Report abort reasons.
--   
--   Abortable process returns <tt>Left</tt> <a>AbortReason</a> when
--   aborted. The <a>abortable</a> function adds code positions to the
--   reason. <a>abortPrint</a> outputs aborted message in the following
--   format.
--   
--   <pre>
--   **
--   ** ABORTED  {reason}
--   ** -------- ---------------------------------- ------
--   ** Detail   {description}
--   **          {description}
--   **
--   ** Source   {line}.{char} {path}
--   **            {before}
--   **                {after}                      {tag}
--   **
--   **          {line}.{char} {path}
--   **            {before}
--   **                {after}                      {tag}
--   **
--   ** Command  {program}
--   **          {arg}
--   **          {arg}
--   **
--   
--   === note
--   
--   {note}
--   {note}
--   
--   === rel
--   </pre>
module Koshucode.Baala.Base.Abort.Report

-- | Command name and its arguments.
type CommandLine = [String]

-- | Convert code position into message text: location, before code, after
--   code, and abort tag.
--   
--   <pre>
--   &gt;&gt;&gt; cpMessage $ B.CodePos 0 "&lt;stdin&gt;" 1 "abcdefg" "defg"
--   (Just (1,3,"&lt;stdin&gt;"), Just "abc", Just "defg")
--   </pre>
cpMessage :: CodePos -> (Maybe (Int, Int, FilePath), Maybe String, Maybe String)

-- | Create position and line information.
cpMessageLines :: CodePosInfo -> [(String, AbortTag)]

-- | Convert abort reason to message lines.
abortMessage :: CommandLine -> AbortReason -> [String]

-- | Print abort message.
--   
--   Prepare code position and abort reason.
--   
--   <pre>
--   &gt;&gt;&gt; let cp = B.CodePos 0 "&lt;stdin&gt;" 1 "abcdefg" "defg"
--   
--   &gt;&gt;&gt; let Left a = B.abortable "tag" cp $ Left $ B.abortBecause "Bad luck"
--   </pre>
--   
--   Print it.
--   
--   <pre>
--   &gt;&gt;&gt; abortPrint (words "prog x y") a
--   **
--   **  ABORTED  Bad luck
--   **  -------- ----------- ------
--   **  Source   1.3 &lt;stdin&gt;
--   **             abc
--   **                defg   .. tag
--   **
--   **  Command  prog
--   **           x
--   **           y
--   **
--   </pre>
abortPrint :: CommandLine -> AbortReason -> IO ()

-- | Stop program execution abnormally.
abort :: AbortReason -> IO x

-- | Abort with a command line.
abortCommand :: CommandLine -> AbortReason -> IO x

-- | Abort when getting abort reason.
abortLeft :: Ab b -> IO b

-- | Stop on error <tt>'BUG DISCOVERED'</tt>
bug :: String -> a


-- | Abort symbols
module Koshucode.Baala.Base.Abort


-- | Message list.
module Koshucode.Baala.Base.Abort.Message

-- | <i>reason</i>
adlib :: String -> Ab a

-- | BUG: <i>reason</i>
bug :: String -> Ab a

-- | Unsupported feature.
unsupported :: String -> Ab a


-- | Message list.
module Koshucode.Baala.Base.Code.Message

-- | Abortable scope for code.
abCode :: (GetCodePos cp) => Abortable cp b

-- | <ul>
--   <li><i>Extra close bracket</i></li>
--   </ul>
extraCloseBracket :: Ab a

-- | <ul>
--   <li><i>Extra closed brackets inserted</i></li>
--   </ul>
extraCloseBracketInserted :: Ab a

-- | <ul>
--   <li><i>Unclosed open bracket</i></li>
--   </ul>
extraOpenBracket :: Ab a

-- | <ul>
--   <li><i>Unmatched indent size</i></li>
--   </ul>
unmatchIndentSize :: Ab a


-- | Bundle of message modules.
module Koshucode.Baala.Base.Message


-- | Bracket type.
module Koshucode.Baala.Base.Code.Bracket

-- | Bracket type.
data Bracket b

-- | None bracket
BracketNone :: Bracket b

-- | Open bracket
BracketOpen :: b -> Bracket b

-- | Close bracket
BracketClose :: b -> Bracket b

-- | Get a bracket type.
type GetBracket b a = a -> Bracket b

-- | Create <a>GetBracket</a> functions from a type-open-close table.
--   
--   <i>Example</i>
--   
--   Create bracket/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let bracket n [a, b] = (n, ((== a), (== b)))
--   
--   &gt;&gt;&gt; let pt = bracketTable [ bracket 1 "()", bracket 2 "[]" ]
--   </pre>
--   
--   Get bracket types for each chars. Types of open brackets are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [BracketNone, BracketNone,
--    BracketOpen 1, BracketNone, BracketNone,
--     BracketOpen 2, BracketNone, BracketNone, BracketClose 2,
--    BracketClose 1, BracketNone]
--   </pre>
bracketTable :: (Eq a) => [(b, (Test a, Test a))] -> GetBracket b a

-- | Indent branching function. This inserts open/separator/close elements
--   by following indent.
--   
--   <pre>
--   &gt;&gt;&gt; let size s = if dropWhile (== '/') s == "" then Just (length s) else Nothing
--   
--   &gt;&gt;&gt; let test s = s `elem` ["&gt;", "-"]
--   
--   &gt;&gt;&gt; let toks s = takeWhile (== '/') s : words (dropWhile (== '/') s)
--   
--   &gt;&gt;&gt; let text = Right . unwords . concat
--   
--   &gt;&gt;&gt; let conv ls = text O.# indentBranch size test "(" "|" ")" (toks &lt;$&gt; ls)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toks "/&gt; bb"
--   ["/","&gt;","bb"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conv ["&gt; aa", "/&gt; bb", "//&gt; cc"]
--   Right "&gt; aa ( &gt; bb ( &gt; cc ) )"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conv ["&gt; aa", "/&gt; bb", "/&gt; cc"]
--   Right "&gt; aa ( &gt; bb | &gt; cc )"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conv ["&gt; aa", "/&gt; bb", "//- cc", "///cc", "//- dd", "//- ee", "/- ff"]
--   Right "&gt; aa ( &gt; bb ( - cc cc | - dd | - ee ) | - ff )"
--   </pre>
indentBranch :: (Eq a) => (a -> Maybe Int) -> Test a -> a -> a -> a -> [[a]] -> Ab [[a]]
instance GHC.Classes.Ord b => GHC.Classes.Ord (Koshucode.Baala.Base.Code.Bracket.Bracket b)
instance GHC.Classes.Eq b => GHC.Classes.Eq (Koshucode.Baala.Base.Code.Bracket.Bracket b)
instance GHC.Show.Show b => GHC.Show.Show (Koshucode.Baala.Base.Code.Bracket.Bracket b)


-- | Tree structure.
module Koshucode.Baala.Base.Code.Tree

-- | Tree of leaf and branch.
data RawTree b y z

-- | <b>Leaf:</b> Leaf element (<tt>z</tt>).
TreeL :: z -> RawTree b y z

-- | <b>Branch:</b> Branch type (<tt>b</tt>), branch element (<tt>y</tt>),
--   and subtrees.
TreeB :: b -> y -> [RawTree b y z] -> RawTree b y z

-- | Height of tree.
--   
--   <pre>
--   &gt;&gt;&gt; treeHeight $ TreeB () "Y1" [TreeL "Z1", TreeL "Z2", TreeB () "Y2" [TreeL "Z3"]]
--   3
--   </pre>
treeHeight :: RawTree b y z -> Int

-- | Collect branch elements.
--   
--   <pre>
--   &gt;&gt;&gt; treeListY $ TreeB () "Y1" [TreeL "Z1", TreeL "Z2", TreeB () "Y2" [TreeL "Z3"]]
--   ["Y1","Y2"]
--   </pre>
treeListY :: RawTree b y z -> [y]

-- | Collect leaf elements.
--   
--   <pre>
--   &gt;&gt;&gt; treeListZ $ TreeB () "Y1" [TreeL "Z1", TreeL "Z2", TreeB () "Y2" [TreeL "Z3"]]
--   ["Z1","Z2","Z3"]
--   </pre>
treeListZ :: RawTree b y z -> [z]

-- | Convert tree to path list.
--   
--   <pre>
--   &gt;&gt;&gt; treePaths $ TreeB () "Y1" [TreeL "Z1", TreeL "Z2", TreeB () "Y2" [TreeL "Z3"]]
--   [(["Y1"],"Z1"), (["Y1"],"Z2"), (["Y1","Y2"],"Z3")]
--   </pre>
treePaths :: RawTree b y z -> [([y], z)]

-- | Map function to tree elements.
treeMap :: (b1 -> b2) -> (y1 -> y2) -> (z1 -> z2) -> RawTree b1 y1 z1 -> RawTree b2 y2 z2

-- | Map function to branch element.
treeMapY :: (y1 -> y2) -> RawTree b y1 z -> RawTree b y2 z

-- | Map function to leaf element.
treeMapZ :: (z1 -> z2) -> RawTree b y z1 -> RawTree b y z2

-- | Simplify tree by removing double brackets, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Test b -> Map (RawTree b y z)

-- | Divide branch into leaves and branches.
partitionLB :: [RawTree b y z] -> ([RawTree b y z], [RawTree b y z])

-- | Convert single raw tree to printable lines.
ppRawTreeWith :: (b -> String) -> (y -> String) -> (z -> String) -> RawTree b y z -> [String]

-- | Convert single raw tree to printable lines. Branches are marked usign
--   right arrow (<tt>&gt;</tt>), and leaves are marked using hyphen
--   (<tt>-</tt>).
ppRawTree :: (Show b, Show y, Show z) => RawTree b y z -> [String]

-- | Convert multiple raw trees to printable lines.
ppRawTrees :: (Show b, Show y, Show z) => [RawTree b y z] -> [String]

-- | Pretty print raw tree.
--   
--   <pre>
--   &gt;&gt;&gt; printTree $ TreeB () "Y1" [TreeL "Z1", TreeB () "Y2" [TreeL "Z2", TreeL "Z3"]]
--   Height of tree      = 3
--   Number of branches  = 2
--   Number of leaves    = 3
--   .
--   &gt; () "Y1"
--     - "Z1"
--     &gt; () "Y2"
--       - "Z2"
--       - "Z3"
--   </pre>
printTree :: (Show b, Show y, Show z) => RawTree b y z -> IO ()

-- | Pretty print raw trees.
printTrees :: (Show b, Show y, Show z) => [RawTree b y z] -> IO ()

-- | Tree of bracket type (b), token type (k), and textual value (t).
type CodeTree b k t = CodeTree' b (k t)

-- | Tree with open/close brackets.
type CodeTree' b z = RawTree b (Maybe (z, z)) z

-- | Convert code elements to a single code tree.
codeTree :: (Ord b, GetCodePos (k t)) => GetBracket b (k t) -> Bracket b -> b -> [k t] -> Ab (CodeTree b k t)

-- | Convert code elements to code trees.
codeTrees :: (Ord b, GetCodePos (k t)) => GetBracket b (k t) -> Bracket b -> [k t] -> Ab [CodeTree b k t]

-- | Wrap trees into single tree.
codeTreeWrap :: b -> [CodeTree b k t] -> CodeTree b k t

-- | Mapping function for textual code tree.
codeTreeFmap :: (Functor k) => (t -> u) -> CodeTree b k t -> CodeTree b k u

-- | Mapping function for code tree.
codeTreeFmap' :: (x -> y) -> CodeTree' b x -> CodeTree' b y

-- | Convert tree to list of tokens.
untree :: CodeTree b k t -> [k t]

-- | Convert tree to list of tokens.
untrees :: [CodeTree b k t] -> [k t]
instance (GHC.Classes.Ord b, GHC.Classes.Ord y, GHC.Classes.Ord z) => GHC.Classes.Ord (Koshucode.Baala.Base.Code.Tree.RawTree b y z)
instance (GHC.Classes.Eq b, GHC.Classes.Eq y, GHC.Classes.Eq z) => GHC.Classes.Eq (Koshucode.Baala.Base.Code.Tree.RawTree b y z)
instance (GHC.Show.Show b, GHC.Show.Show y, GHC.Show.Show z) => GHC.Show.Show (Koshucode.Baala.Base.Code.Tree.RawTree b y z)
instance GHC.Base.Functor (Koshucode.Baala.Base.Code.Tree.RawTree p k)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (k t) => Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Tree.CodeTree b k t)


-- | Convert infixed-operator trees into prefixed-operator trees.
module Koshucode.Baala.Base.Code.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
--   
--   <pre>
--   &gt;&gt;&gt; infixHeight Just [('.', Right 3), (':', Right 5)] &lt;$&gt; "1.2:3"
--   [Left 0, Right 3, Left 0, Right 5, Left 0]
--   </pre>
infixHeight :: (Ord b) => (a -> Maybe b) -> [(b, InfixHeight)] -> (a -> InfixHeight)

-- | Split branches in a given tree at infixed binary operators.
infixToPrefix :: (Map a, Map a, Map a) -> (a -> InfixHeight) -> Collect (InfixTree p a) -> InfixMapper p a -> InfixConv a (CodeTree' p a)

-- | Intermediate infix-to-prefix conversion.
type InfixMapper p a = InfixConv a [InfixTree p a] -> InfixConv a (InfixTree p a)

-- | Infix-to-prefix conversion.

-- | <i>Warning: This is only used in defined module.</i>
type InfixConv a tree = tree -> InfixAmb a tree

-- | Code tree or ambiguous infix.

-- | <i>Warning: This is only used in defined module.</i>
type InfixAmb a tree = Either [(InfixHeight, a)] tree

-- | Code tree with infix height.

-- | <i>Warning: This is only used in defined module.</i>
type InfixTree b a = CodeTree' b (InfixHeight, a)


-- | File path and content in lazy bytestring.
module Koshucode.Baala.Base.IO.BzFile

-- | File path and content in lazy bytestring. The function
--   <a>readBzFile</a> creates:
--   
--   <ul>
--   <li><a>BzFile</a> with content and <a>Nothing</a>-exception on
--   success,</li>
--   <li><a>BzFile</a> with empty content and <a>Just</a>-exception on
--   failure.</li>
--   </ul>
data BzFile
BzFile :: FilePath -> Ab Bz -> Maybe SomeException -> BzFile

-- | Path of file.
[bzFilePath] :: BzFile -> FilePath

-- | File content as lazy bytestring.
[bzFileContent] :: BzFile -> Ab Bz

-- | Exception when reading file.
[bzFileException] :: BzFile -> Maybe SomeException

-- | Read file from given path.
readBzFile :: FilePath -> IO BzFile

-- | Read file content as lazy bytestring.
tryReadFile :: (Exception e) => FilePath -> IO (Either e Bz)
instance GHC.Show.Show Koshucode.Baala.Base.IO.BzFile.BzFile


-- | I/O related modules.
module Koshucode.Baala.Base.IO


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Code.Line

-- | Split input into textual lines.
--   
--   <pre>
--   &gt;&gt;&gt; toLines "aaa\nbbb\r\nccc\n\nddd\n" :: [String]
--   ["aaa", "bbb", "ccc", "", "ddd"]
--   </pre>
class ToLines i
toLines :: (ToLines i, Textual t) => i -> [t]

-- | Remove UTF-8 BOM (EF BB BF in hexadecimal) from lazy bytestring.
--   
--   <pre>
--   &gt;&gt;&gt; dropBom "\xEF\xBB\xBF|foo bar baz"
--   "|foo bar baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropBom "\xEF|foo bar baz"
--   "\239|foo bar baz"
--   </pre>
dropBom :: Bz -> Bz

-- | Split lazy bytestring by newline character sequence. If bytestring
--   begins with the UTF-8 BOM, this function drops it.
bzLines :: Bz -> [Bz]

-- | Split <i>textual-value-#1</i> into lines. The result texts do not
--   contain carriage returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; textualLines "aaa\nbbb\r\nccc\n\nddd\n"
--   ["aaa", "bbb", "ccc", "", "ddd"]
--   </pre>
textualLines :: (Textual t) => t -> [t]

-- | Split string into lines.

-- | <i>Deprecated: Consider <a>bzLines</a>.</i>
linesCrlf :: String -> [String]

-- | Split lazy bytestring by newline character sequence. This function
--   drops the BOM sequence.

-- | <i>Deprecated: Consider <a>bzLines</a>.</i>
linesCrlfBz :: (ToBytes code) => code -> [Bz]

-- | Line number and its content.

-- | <i>Deprecated: Consider <a>bzLines</a>.</i>
linesCrlfNumbered :: String -> [(LineNumber, String)]

-- | Line number.
type LineNumber = Int

-- | Tokens in line.
data CodeLine k t
CodeLine :: LineNumber -> t -> [k t] -> CodeLine k t

-- | Line number, from 1.
[lineNumber] :: CodeLine k t -> LineNumber

-- | Line content without newline.
[lineContent] :: CodeLine k t -> t

-- | Tokens in the line.
[lineTokens] :: CodeLine k t -> [k t]

-- | Type for indent size.
type IndentSize = Int

-- | Calculate indent of line and pairing it.
lineIndentPair :: (k t -> IndentSize) -> CodeLine k t -> (IndentSize, CodeLine k t)
instance (GHC.Classes.Ord t, GHC.Classes.Ord (k t)) => GHC.Classes.Ord (Koshucode.Baala.Base.Code.Line.CodeLine k t)
instance (GHC.Classes.Eq t, GHC.Classes.Eq (k t)) => GHC.Classes.Eq (Koshucode.Baala.Base.Code.Line.CodeLine k t)
instance (GHC.Show.Show t, GHC.Show.Show (k t)) => GHC.Show.Show (Koshucode.Baala.Base.Code.Line.CodeLine k t)
instance Koshucode.Baala.Base.Code.Line.ToLines Koshucode.Baala.Overture.Shorthand.Bz
instance Koshucode.Baala.Base.Code.Line.ToLines GHC.Base.String
instance GHC.Base.Functor k => GHC.Base.Functor (Koshucode.Baala.Base.Code.Line.CodeLine k)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (k t) => Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Line.CodeLine k t)


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <tt>CodeLine</tt> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <tt>CodeLine</tt>.
module Koshucode.Baala.Base.Code.Clause

-- | Tokens in clause.
data CodeClause k t
CodeClause :: [CodeLine k t] -> [k t] -> CodeClause k t

-- | Source lines of clause
[clauseLines] :: CodeClause k t -> [CodeLine k t]

-- | Source tokens of clause
[clauseTokens] :: CodeClause k t -> [k t]

-- | Split lines into clause based on indent size.
--   
--   <pre>
--   &gt;&gt;&gt; splitClause [(0, "a"), (2, "b"), (0, "c"), (1, "d")]
--   (["a","b"], [(0,"c"),(1,"d")])
--   </pre>
splitClause :: Gather [(IndentSize, a)] [a]
instance (GHC.Show.Show t, GHC.Show.Show (k t)) => GHC.Show.Show (Koshucode.Baala.Base.Code.Clause.CodeClause k t)
instance Koshucode.Baala.Base.Abort.CodePos.GetCodePos (k t) => Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Clause.CodeClause k t)
instance Data.Default.Class.Default (Koshucode.Baala.Base.Code.Clause.CodeClause t a)


-- | Code scanner.
module Koshucode.Baala.Base.Code.Scan

-- | Code scanner divides input text into output tokens.
data CodeScan k t
CodeScan :: [CodeScanMap k t] -> CodeScanMap k t -> TCodePos t -> t -> [k t] -> WordCache t -> CodeScan k t

-- | Saved updater
[scanMapSaved] :: CodeScan k t -> [CodeScanMap k t]

-- | Updater
[scanMap] :: CodeScan k t -> CodeScanMap k t

-- | Code position
[scanCp] :: CodeScan k t -> TCodePos t

-- | Input text
[scanInput] :: CodeScan k t -> t

-- | Output tokens
[scanOutput] :: CodeScan k t -> [k t]

-- | Cached words
[scanCache] :: CodeScan k t -> WordCache t

-- | Update code scanner.
type CodeScanMap k t = Map (CodeScan k t)

-- | Cached words.
type WordCache t = Cache t t

-- | Empty word cache.
emptyWordCache :: WordCache t

-- | Test scanner at the beginning of line, i.e., no output collected.
isBol :: Test (CodeScan k t)

-- | Save current updater.
codeScanSave :: CodeScanMap k t

-- | Restore saved updater.
codeScanRestore :: CodeScanMap k t

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><a>LineNumber</a><tt>,
--   </tt><a>Textual</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeScanUp :: (ToLines i, Textual t) => CodeScanMap k t -> IxIOPoint -> i -> [CodeLine k t]

-- | Update <a>scanInput</a> and push result element to <a>scanOutput</a>.
codeUpdate :: t -> k t -> CodeScanMap k t

-- | Update code scanner with word table.
codeUpdateWords :: WordCache t -> t -> k t -> CodeScanMap k t

-- | Multi-element version of <a>codeUpdate</a>.
codeUpdateList :: t -> [k t] -> CodeScanMap k t

-- | Multi-element and cached version of <a>codeUpdate</a>.
codeUpdateListWords :: WordCache t -> t -> [k t] -> CodeScanMap k t

-- | Change mapper of code sc.
codeChange :: Map (CodeScanMap k t)
instance Koshucode.Baala.Overture.Text.Textual.Textual t => Koshucode.Baala.Base.Abort.CodePos.GetCodePos (Koshucode.Baala.Base.Code.Scan.CodeScan k t)


-- | Syntactic functions.
module Koshucode.Baala.Base.Code


-- | Bundle of base modules.
module Koshucode.Baala.Base
