-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Relation-mapping operators in Koshucode
--   
--   An impelemntation of relation-mapping operators. Operators are used in
--   the <tt>koshu</tt> calculator that is contained in the
--   <tt>koshucode-baala-calculator</tt> package.
@package koshucode-baala-rop-flat
@version 0.200.0.0


-- | Fundamental operators in relational algebra.
--   
--   Tropashko's relational lattice is a kind of relational algebra.
--   Relational algebra is an algebraic formulation for relational model.
--   In constrast to Codd's original relational algebra, Tropashko lattice
--   is in more conventional and strict ways. The lattice has fundamental
--   operators from which other operators are derived.
module Koshucode.Baala.Rop.Flat.Lattice.Tropashko

-- | <ul>
--   <li><i>meet <i>R</i> [-share /P ...]</i> Meet input relation and
--   <i>R</i>.</li>
--   </ul>
consMeet :: (Ord c) => RopCons c

-- | Meet two relations.
relmapMeet :: (Ord c) => Intmed c -> SharedTerms -> Relmap c -> Relmap c

-- | Meet two relations.
relkitMeet :: (Ord c) => SharedTerms -> RelkitBinary c

-- | <ul>
--   <li><i>join <i>R</i> [-share /P ...]</i> Join input relation and
--   <i>R</i>.</li>
--   </ul>
consJoin :: (Ord c) => RopCons c

-- | Join two relations.
relmapJoin :: (Ord c) => Intmed c -> SharedTerms -> Relmap c -> Relmap c

-- | Join multiple relations.
relmapJoinList :: (Ord c) => Intmed c -> [Relmap c] -> Relmap c

-- | Join two relations.
relkitJoin :: SharedTerms -> RelkitBinary c

-- | Shared terms for composing check.
type SharedTerms = Maybe [TermName]

-- | Calculate unmatch shared terms.
unmatchShare :: SharedTerms -> TermPicker c -> Maybe ([TermName], [TermName])


-- | Operators on collection elements.
module Koshucode.Baala.Rop.Flat.Elem

-- | Implementation of relational operators.
ropsElem :: (CContent c) => [Rop c]

-- | Expand elements from collection.
consMember :: (Ord c, CSet c, CList c, CText c) => RopCons c

-- | Create <tt>member</tt> relmap.
relmapMember :: (Ord c, CSet c, CList c, CText c) => Intmed c -> TermName2 -> Relmap c

-- | Create <tt>member</tt> relkit.
relkitMember :: (Ord c, CSet c, CList c, CText c) => TermName2 -> RelkitFlow c

-- | Expand index and element from collection.
--   
--   <pre>
--   &gt;&gt;&gt; ix-elem /list -to /i /elem
--   
--   &gt;&gt;&gt; iz-elem /list -to /i /elem
--   </pre>
consIndexElem :: (Ord c, CContent c) => Int -> RopCons c

-- | Create <tt>ix-elem</tt> or <tt>iz-elem</tt> relmap.
relmapIndexElem :: (Ord c, CContent c) => Int -> Intmed c -> TermName3 -> Relmap c

-- | Create <tt>ix-elem</tt> or <tt>iz-elem</tt> relkit.
relkitIndexElem :: (Ord c, CContent c) => Int -> TermName3 -> RelkitFlow c

-- | Unroll (expand) terms to tuples.
--   
--   <pre>
--   &gt;&gt;&gt; unroll /term /content -from /1 /2 /3 /4
--   </pre>
consUnroll :: (CTerm c) => RopCons c

-- | Create <tt>unroll</tt> relmap.
relmapUnroll :: (CTerm c) => Intmed c -> (TermName, TermName, [TermName]) -> Relmap c

-- | Extract elements from collection.
--   
--   <pre>
--   &gt;&gt;&gt; elem-begin /list -to /a /b /c
--   </pre>
consElemBegin :: (Ord c, CContent c) => RopCons c

-- | Create <tt>elem-begin</tt> relmap.
relmapElemBegin :: (Ord c, CContent c) => Intmed c -> (TermName, [TermName]) -> Relmap c

-- | Extract end-side elements from collection.
--   
--   <pre>
--   &gt;&gt;&gt; elem-end /list -to /a /b /c
--   </pre>
consElemEnd :: (Ord c, CContent c) => RopCons c

-- | Create <tt>elem-end</tt> relmap.
relmapElemEnd :: (Ord c, CContent c) => Intmed c -> (TermName, [TermName]) -> Relmap c

-- | <b>uncollect /P -to /N ...</b>
consUncollect :: (Ord c, CSet c, CList c, CText c, CDec c, CEmpty c) => RopCons c

-- | Create <tt>uncollect</tt> relmap.
relmapUncollect :: (Ord c, CSet c, CList c, CText c, CDec c, CEmpty c) => Intmed c -> (TermName, [TermName]) -> Relmap c

-- | Create <tt>uncollect</tt> relkit.
relkitUncollect :: (Ord c, CSet c, CList c, CText c, CDec c, CEmpty c) => (TermName, [TermName]) -> RelkitFlow c


-- | Text decomposition by subtext.
module Koshucode.Baala.Rop.Flat.Applied.Subtext

-- | Implementation of relational operators.
ropsAppliedSubtext :: (CContent c) => [Rop c]

-- | Type of subtext parameters.
type SubtextPara = (TermName, [NameDepth], CharMatch, Bool)

-- | <b>subtext /P E</b>
--   
--   Construct <tt>subtext</tt> relmap. Decompose text content of /P by
--   matcing with subtext expression E. Terms contained in E are added to
--   output relation. Expression E is either single or bundle:
--   
--   <ul>
--   <li><i>( E1 )</i> Decompose text by single expression E.</li>
--   <li><i>{ N1 = E1 | N2 = E2 | ... }</i> Decompose text by bundle of
--   named expressions. Text decomposition starts from N1.</li>
--   </ul>
consSubtext :: (CContent c) => RopCons c

-- | Create <tt>subtext</tt> relmap.
relmapSubtext :: (CContent c) => Intmed c -> SubtextPara -> Relmap c

-- | Create <tt>subtext</tt> relkit.
relkitSubtext :: (CContent c) => SubtextPara -> Maybe Head -> Ab (Relkit c)


-- | Partial-order scale.
module Koshucode.Baala.Rop.Flat.Applied.PoScale

-- | Mapping from element to subelements and scale. Scale of element is
--   defined by 1 + the maximum scale of subelements. If elements are
--   cyclic, scales of these elements are -1.
type PoScale a = Map a ([a], Maybe Int)

-- | Calculate partial-order scale.
type PoScaleCalc a = [(a, a)] -> [(a, Int)]

-- | Extract partial-order scale.
poScale :: PoScale a -> [(a, Int)]

-- | Calculate upward partial-order scale.
--   
--   <pre>
--   &gt;&gt;&gt; poScaleHeight [("a","b"), ("a","c"), ("b","d"), ("c","d")]
--   [("a",0), ("b",1), ("c",1), ("d",2)]
--   </pre>
poScaleHeight :: (Ord a) => PoScaleCalc a

-- | Calculate downward partial-order scale.
--   
--   <pre>
--   &gt;&gt;&gt; poScaleDepth [("a","b"), ("a","c"), ("b","d"), ("c","d")]
--   [("a",2), ("b",1), ("c",1), ("d",0)]
--   </pre>
poScaleDepth :: (Ord a) => PoScaleCalc a

-- | Calculate partial-order height.
poHeight :: (Ord a) => [(a, a)] -> PoScale a

-- | Calculate partial-order depth.
poDepth :: (Ord a) => [(a, a)] -> PoScale a


-- | Gadgets.
module Koshucode.Baala.Rop.Flat.Applied.Gadget

-- | Gadgets
ropsAppliedGadget :: (CContent c) => [Rop c]

-- | <b>contents /N</b>
--   
--   Collect all contents in unary relation.
consContents :: (Ord c) => RopCons c

-- | Create <tt>contents</tt> relmap.
relmapContents :: (Ord c) => Intmed c -> TermName -> Relmap c

-- | <b>partial-order-height /P /P -to /N /N</b>
consPoHeight :: (Ord c, CDec c) => RopCons c

-- | <b>partial-order-depth /P /P -to /N /N</b>
consPoDepth :: (Ord c, CDec c) => RopCons c

-- | Create <tt>partial-order-height</tt> or <tt>partial-order-depth</tt>
--   relmap.
relmapPoScale :: (Ord c, CDec c) => PoScaleCalc c -> Intmed c -> TermName4 -> Relmap c

-- | Create <tt>partial-order-height</tt> or <tt>partial-order-depth</tt>
--   relkit.
relkitPoScale :: (Ord c, CDec c) => PoScaleCalc c -> TermName4 -> RelkitFlow c

-- | <b>visit-distance R -step /P ... -to /N -distance /N</b>
consVisitDistance :: (Ord c, CDec c, CRel c) => RopCons c

-- | Create <tt>visit-distance</tt> relmap.
relmapVisitDistance :: (Ord c, CDec c, CRel c) => Intmed c -> ([TermName], [TermName], TermName, TermName) -> Map (Relmap c)

-- | <b>size /N</b>
--   
--   Count number of tuples.
consSize :: (CDec c) => RopCons c

-- | Create <tt>size</tt> relmap.
relmapSize :: (CDec c) => Intmed c -> TermName -> Relmap c

-- | Create <tt>size</tt> relkit.
relkitSize :: (CDec c) => TermName -> RelkitFlow c

-- | <b>eqlize</b>
consEqlize :: (Ord c) => RopCons c

-- | Create <tt>eqlize</tt> relmap.
relmapEqlize :: (Ord c) => Intmed c -> Relmap c

-- | Create <tt>eqlize</tt> relkit.
relkitEqlize :: (Ord c) => RelkitFlow c

-- | <b>dump-tree E</b>
consDumpTree :: (CDec c) => RopCons c


-- | Relmap operators for manipulating term names.
module Koshucode.Baala.Rop.Flat.Term

-- | Relmap operators for manipulating term names.
ropsTerm :: (Ord c) => [Rop c]

-- | <ul>
--   <li><i>pick /P ...</i> Project relation to specified terms.</li>
--   </ul>
consPick :: RopCons c

-- | Create <tt>pick</tt> relmap.
relmapPick :: Intmed c -> [TermName] -> Relmap c

-- | Create <tt>pick</tt> relkit.
relkitPick :: [TermName] -> RelkitFlow c

-- | <ul>
--   <li><i>cut /P ...</i> Project relation to unspecified terms. This
--   operator is an inversion of <tt>pick</tt>.</li>
--   </ul>
consCut :: RopCons c

-- | Create <tt>cut</tt> relmap.
relmapCut :: Intmed c -> [TermName] -> Relmap c

-- | Create <tt>cut</tt> relkit.
relkitCut :: [TermName] -> RelkitFlow c

-- | <ul>
--   <li><i>pick-term <i>R</i></i></li>
--   </ul>
--   
--   Construct <tt>pick-term</tt> relmap operator. This operator is similar
--   to <tt>pick</tt> instead of given terms but relation terms.
consPickTerm :: RopCons c

-- | Create <tt>pick-term</tt> relmap.
relmapPickTerm :: Intmed c -> Relmap c -> Relmap c

-- | Create <tt>pick-term</tt> relkit.
relkitPickTerm :: RelkitBinary c

-- | <ul>
--   <li><i>cut-term <i>R</i></i></li>
--   </ul>
--   
--   Construct <tt>cut-term</tt> relmap operator. This operator is similar
--   to <tt>cut</tt> instead of given terms but relation terms.
consCutTerm :: RopCons c

-- | Create <tt>cut-term</tt> relmap.
relmapCutTerm :: Intmed c -> Relmap c -> Relmap c

-- | Create <tt>cut-term</tt> relkit.
relkitCutTerm :: RelkitBinary c

-- | <ul>
--   <li><i>move /P ... -to /N ...</i></li>
--   </ul>
--   
--   Rename term names. Terms /P ... of input relation are renamed
--   corresponding terms /N .... The <tt>move</tt> operator provides same
--   functionality as <tt>rename</tt>. Operator <tt>move</tt> is suitable
--   for renaming few terms, operator <tt>rename</tt> for many terms. The
--   following relmaps have same effect:
--   
--   <pre>
--   rename /N /P /N /P ...
--   move /P ... -to /N ...
--   </pre>
consMove :: RopCons c

-- | Create <tt>move</tt> relmap.
relmapMove :: Intmed c -> ([TermName], [TermName]) -> Relmap c

-- | Create <tt>move</tt> relkit.
relkitMove :: ([TermName], [TermName]) -> RelkitFlow c

-- | <ul>
--   <li><i>rename /N /P /N /P ...</i></li>
--   </ul>
--   
--   Rename term names. Term /P is renamed to term /N for each pair of
--   terms /N /P. The <tt>rename</tt> operator provides same functionality
--   as <tt>move</tt>.
consRename :: RopCons c

-- | Create <tt>rename</tt> relmap.
relmapRename :: Intmed c -> [TermName2] -> Relmap c


-- | Operation for term names.
module Koshucode.Baala.Rop.Flat.TermGadget

-- | Relmap operators for manipulating term names.
--   
--   <ul>
--   <li><i><tt>prefix /P /N ...</tt></i> Add prefix <tt>/P</tt> to terms
--   <tt>/N</tt> ...</li>
--   <li><i><tt>prefix-change /P /Q</tt></i> Change prefix from <tt>/P</tt>
--   to <tt>/Q</tt>.</li>
--   <li><i><tt>unprefix /P</tt></i> Remove prefix <tt>/P</tt> from term
--   name.</li>
--   <li><i><tt>wipe</tt></i> Cut working terms.</li>
--   </ul>
ropsTermGadget :: (Ord c) => [Rop c]

-- | Add prefix to specified terms.
consPrefix :: RopCons c

-- | Create <tt>prefix</tt> relmap.
relmapPrefix :: Intmed c -> TermName -> [TermName] -> Relmap c

-- | Create <tt>prefix</tt> relkit.
relkitPrefix :: TermName -> [TermName] -> RelkitFlow c

-- | Remove prefix.
consUnprefix :: RopCons c

-- | Create <tt>unprefix</tt> relmap.
relmapUnprefix :: Intmed c -> TermName -> Relmap c

-- | Create <tt>unprefix</tt> relkit.
relkitUnprefix :: TermName -> RelkitFlow c

-- | Change prefix.
consPrefixChange :: RopCons c

-- | Create <tt>prefix-change</tt> relmap.
relmapPrefixChange :: Intmed c -> TermName2 -> Relmap c

-- | Create <tt>prefix-change</tt> relkit.
relkitPrefixChange :: TermName2 -> RelkitFlow c

-- | <b>wipe</b>
consWipe :: RopCons c

-- | Create <tt>wipe</tt> relmap.
relmapWipe :: Intmed c -> Relmap c

-- | Create <tt>wipe</tt> relkit.
relkitWipe :: RelkitFlow c


-- | Type-specific operators.
module Koshucode.Baala.Rop.Flat.Applied.Peripheral

-- | Implementation of relational operators.
ropsAppliedPeripheral :: (CContent c) => [Rop c]

-- | <b>rdf P /S /O</b>
consRdf :: RopCons c

-- | <b>tie /P ... -to /N</b>
consTie :: (CTie c) => RopCons c

-- | Create <tt>tie</tt> relmap.
relmapTie :: (CTie c) => Intmed c -> ([TermName], TermName) -> Relmap c

-- | Create <tt>tie</tt> relkit.
relkitTie :: (CTie c) => ([TermName], TermName) -> RelkitFlow c

-- | <b>untie /P -to /N ...</b>
consUntie :: (CTie c) => RopCons c

-- | Create <tt>untie</tt> relmap.
relmapUntie :: (CTie c) => Intmed c -> (TermName, [TermName]) -> Relmap c

-- | Create <tt>untie</tt> relkit.
relkitUntie :: (CTie c) => (TermName, [TermName]) -> RelkitFlow c

-- | <b>term-name /N</b>
consTermName :: (CTerm c) => RopCons c

-- | Create <tt>term-name</tt> relmap.
relmapTermName :: (CTerm c) => Intmed c -> TermName -> Relmap c

-- | Create <tt>term-name</tt> relkit.
relkitTermName :: (CTerm c) => TermName -> RelkitFlow c

-- | <b>today /N</b>
--   
--   Get today's time at term /N.
consToday :: (CTime c) => RopCons c

-- | <ul>
--   <li><i>now /N</i> Get current local time without time zone at term
--   /N.</li>
--   <li><i>now /N -zoned</i> Get current local time with time zone at term
--   /N.</li>
--   <li><i>now /N -utc</i> Get current UTC.</li>
--   </ul>
consNow :: (CTime c) => RopCons c

-- | Add single constant term to each tuples.
consAdd1 :: Term c -> RopCons c

-- | Create term-adding relmap.
relmapAdd1 :: Term c -> Intmed c -> Relmap c

-- | Create term-adding relkit.
relkitAdd1 :: Term c -> Maybe Head -> Ab (Relkit c)


-- | Applied operators.
module Koshucode.Baala.Rop.Flat.Applied.Rops

-- | Applied operators.
ropsApplied :: (CContent c) => [Rop c]


-- | Restrict by relmap
module Koshucode.Baala.Rop.Flat.Lattice.Restrict

-- | <ul>
--   <li><i>some <i>R</i></i> Existential filter.</li>
--   </ul>
consSome :: (Ord c) => RopCons c

-- | Relmap of existential filter.
relmapSome :: (Ord c) => Intmed c -> Map (Relmap c)

-- | Calculate existential filter.
relkitSome :: (Ord c) => RelkitBinary c

-- | <ul>
--   <li><i>none <i>R</i></i> Non-existential filter.</li>
--   </ul>
consNone :: (Ord c) => RopCons c

-- | Relmap of non-existential filter.
relmapNone :: (Ord c) => Intmed c -> Map (Relmap c)

-- | Calculate non-existential filter.
relkitNone :: (Ord c) => RelkitBinary c

-- | Construct some-and-meet relmap.
consSomeMeet :: (Ord c) => RopCons c

-- | Some-and-meet relmap.
--   
--   <pre>
--   some-meet R == some ( meet R )
--   </pre>
relmapSomeMeet :: (Ord c) => Intmed c -> SharedTerms -> Relmap c -> Relmap c

-- | Construct none-and-meet relmap.
consNoneMeet :: (Ord c) => RopCons c

-- | None-and-meet relmap.
--   
--   <pre>
--   none-meet R == none ( meet R )
--   </pre>
relmapNoneMeet :: (Ord c) => Intmed c -> SharedTerms -> Relmap c -> Relmap c

-- | Construct relmap for subrelation filter.
consSub :: (Ord c) => RopCons c

-- | Relmap for subrelation filter.
relmapSub :: (Ord c) => Intmed c -> SharedTerms -> Map (Relmap c)

-- | Calculate subrelation filter.
relkitSub :: (Ord c) => SharedTerms -> RelkitBinary c

-- | Construct relmap for relational composition.
consCompose :: (Ord c) => RopCons c

-- | Relational composition.
relmapCompose :: (Ord c) => Intmed c -> SharedTerms -> Map (Relmap c)

-- | Calculate relational composition.
relkitCompose :: (Ord c) => (SharedTerms -> RelkitBinary c) -> SharedTerms -> RelkitBinary c


-- | Relmap operators on relational lattice.
module Koshucode.Baala.Rop.Flat.Lattice.Rop

-- | Lattice implementations of relmap operators.
--   
--   <ul>
--   <li><i><tt>join</tt></i> Join two relations.</li>
--   <li><i><tt>meet</tt></i> Meet two relations.</li>
--   <li><i><tt>none</tt></i> Restriction by relmaps.</li>
--   <li><i><tt>some</tt></i> Restriction by relmaps.</li>
--   <li><i><tt>sub</tt></i> Restriction to subrelation.</li>
--   </ul>
ropsLattice :: (Ord c) => [Rop c]


-- | Data source.
module Koshucode.Baala.Rop.Flat.Source

-- | Implementation of relational operators.
ropsSource :: (CContent c) => [Rop c]

-- | <b>dee</b>
--   
--   Output the nullary full relation.
consDee :: RopCons c

-- | <b>dum</b>
--   
--   Output the nullary empty relation.
consDum :: RopCons c

-- | <b>empty /N ...</b>
--   
--   Output an empty relation which has terms <i>/N ...</i>.
consEmpty :: RopCons c

-- | Create <tt>empty</tt> relmap.
relmapEmpty :: Intmed c -> [TermName] -> Relmap c

-- | <b>source C /N...</b>
--   
--   Read relation with terms <i>/N...</i> from judges of <i>C</i>.
consSource :: RopCons c

-- | <b>source-term C R</b>
consSourceTerm :: RopCons c

-- | Create <tt>source-term</tt> relmap.
relmapSourceTerm :: Intmed c -> String -> Map (Relmap c)


-- | Operators on data resources.
module Koshucode.Baala.Rop.Flat.Resource

-- | Relmap operators about resources.
ropsResource :: (CContent c) => [Rop c]

-- | <b>koshu-res-rop /N /N</b>
--   
--   Derived relmap operators in the current resource.
consKoshuResRop :: (CContent c) => RopCons c

-- | Create <tt>koshu-res-rop</tt> relkit.
relkitKoshuResRop :: (CContent c) => (TermName, TermName) -> RelkitHook c

-- | <b>koshu-res-sink /N /N</b>
--   
--   Judgement class of sinks in the current resource.
consKoshuResSink :: (CContent c) => RopCons c

-- | Create <tt>koshu-res-sink</tt> relkit.
relkitKoshuResSink :: (CContent c) => (TermName, TermName) -> RelkitHook c

-- | <b>koshu-res-article /N</b>
consKoshuResArticle :: (CContent c) => RopCons c

-- | Create <tt>koshu-res-article</tt> relkit.
relkitKoshuResArticle :: (CContent c) => TermName -> RelkitHook c


-- | Relmap operators which produce ordered relations.
module Koshucode.Baala.Rop.Flat.Order

-- | Pseudorelmap operators for term and tuple ordering.
ropsOrder :: (Ord c) => [Rop c]

-- | <b>forward /P ...</b>
--   
--   Move terms /P ... forward.
consForward :: RopCons c

-- | Create <tt>forward</tt> relmap.
relmapForward :: Intmed c -> [TermName] -> Relmap c

-- | <b>backward /P ...</b>
--   
--   Move terms /P ... backward.
consBackward :: RopCons c

-- | Create <tt>backward</tt> relmap.
relmapBackward :: Intmed c -> [TermName] -> Relmap c

-- | <b>lexical</b>
consLexical :: RopCons c

-- | Create <tt>lexical</tt> relmap.
relmapLexical :: Intmed c -> Relmap c

-- | <b>order /P ...</b>
consOrder :: (Ord c) => RopCons c

-- | Create <tt>order</tt> relmap.
relmapOrder :: (Ord c) => Intmed c -> [TermName] -> Relmap c

-- | Create <tt>order</tt> relkit.
relkitOrder :: (Ord c) => [TermName] -> RelkitFlow c


-- | Relmap operators for retrieving meta information.
module Koshucode.Baala.Rop.Flat.Meta

-- | Implementation of relational operators.
--   
--   <ul>
--   <li><i><tt>koshu-cop /N</tt></i> Retrieve list of content
--   operators.</li>
--   <li><i><tt>koshu-cop-infix /N [ -height /N ][ -dir /N ]</tt></i>
--   Retrieve list of infix specifications.</li>
--   <li><i><tt>koshu-rop /N</tt></i> Retrieve list of relmap
--   operators.</li>
--   <li><i><tt>koshu-version /N</tt></i> Get version number of the koshu
--   calculator.</li>
--   </ul>
ropsMeta :: (CContent c) => [Rop c]

-- | <b>koshu-cop /N</b>
consKoshuCop :: CContent c => RopCons c

-- | Create <tt>koshu-cop</tt> relkit.
relkitKoshuCop :: (CContent c) => TermName -> RelkitHook c

-- | <b>koshu-cop-infix /N [ -height /N ][ -dir /N ]</b>
consKoshuCopInfix :: (CContent c) => RopCons c

-- | Create <tt>koshu-cop-infix</tt> relkit.
relkitKoshuCopInfix :: (CContent c) => (TermName, Maybe TermName, Maybe TermName) -> RelkitHook c

-- | <b>koshu-source /N [ -type /N ][ -name /N ]</b>
consKoshuSource :: (CContent c) => RopCons c

-- | Create <tt>koshu-source</tt> relmap.
relmapKoshuSource :: (CContent c) => Intmed c -> (TermName, Maybe TermName, Maybe TermName) -> Relmap c

-- | <b>koshu-rop /N [ -group /N ][ -usage /N ]</b>
consKoshuRop :: (CContent c) => RopCons c

-- | Create <tt>koshu-rop</tt> relkit.
relkitKoshuRop :: (CContent c) => (Maybe TermName, Maybe TermName, Maybe TermName) -> RelkitHook c

-- | <b>koshu-proxy /N /N</b>
consKoshuProxy :: (CContent c) => RopCons c

-- | Create <tt>koshu-proxy</tt> relkit.
relkitKoshuProxy :: (CContent c) => (Maybe TermName, Maybe TermName) -> RelkitHook c

-- | <b>koshu-version /N</b>
consKoshuVersion :: (CContent c) => RopCons c

-- | Create <tt>koshu-version</tt> relkit.
relkitKoshuVersion :: (CContent c) => TermName -> RelkitHook c


-- | Lattice relmap operators.
module Koshucode.Baala.Rop.Flat.Lattice


-- | Conditional relmaps.
module Koshucode.Baala.Rop.Flat.Control

-- | Implementation of relational operators.
ropsControl :: (CContent c) => [Rop c]

-- | <b>if T A B</b>
consIf :: (Ord c) => RopCons c

-- | Create <tt>if</tt> relmap.
relmapIf :: (Ord c) => Intmed c -> Relmap3 c -> Relmap c

-- | Create <tt>if</tt> relkit.
relkitIf :: (Ord c) => RelkitConfl c

-- | <b>when T A</b>
consWhen :: (Ord c) => RopCons c

-- | <b>unless T B</b>
consUnless :: (Ord c) => RopCons c

-- | <b>fix R</b>
consFix :: (Ord c) => RopCons c

-- | <b>fix-join R</b>
consFixJoin :: (Ord c) => RopCons c

-- | <b>equal R</b>
consEqual :: (Ord c) => RopCons c

-- | Create <tt>equal</tt> relmap.
relmapEqual :: (Ord c) => Intmed c -> Map (Relmap c)

-- | Create <tt>equal</tt> relkit.
relkitEqual :: (Ord c) => RelkitBinary c


-- | Check data property.
module Koshucode.Baala.Rop.Flat.Check

-- | Implementation of relational operators.
ropsCheck :: (CContent c) => [Rop c]

-- | <ul>
--   <li><i>check-term -just /P ...</i></li>
--   <li><i>check-term -has /P ...</i></li>
--   <li><i>check-term -but /N ...</i></li>
--   </ul>
consCheckTerm :: RopCons c

-- | <b>duplicate /P ...</b>
--   
--   Output tuples duplicate on terms <i>/P ...</i>.
consDuplicate :: (Ord c) => RopCons c

-- | <b>exclude /N ... -from R</b>
consExclude :: (Ord c) => RopCons c

-- | <b>dump</b>
--   
--   Dump input relation and abort.
consDump :: (CRel c, MixEncode c) => RopCons c


-- | Applied relmap operators in Koshucode.
module Koshucode.Baala.Rop.Flat.Applied


-- | Basic relmap operators.
module Koshucode.Baala.Rop.Flat.Rops

-- | Basic relmap operators.
ropsFlat :: (CContent c) => [Rop c]


-- | Operators in Koshucode.
module Koshucode.Baala.Rop.Flat
