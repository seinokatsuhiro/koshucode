-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Relation-mapping operators with content calculations
--   
--   An impelemntation of relation-mapping operators that use term-content
--   calculations. These operators are used in the <tt>koshu</tt>
--   calculator that is contained in the
--   <tt>koshucode-baala-calculator</tt> package.
@package koshucode-baala-rop-cox
@version 0.200.0.0


-- | Relmap operators for dec type.
module Koshucode.Baala.Rop.Cox.Type.Dec

-- | Implementation of relational operators.
ropsTypeDec :: (CContent c) => [Rop c]

-- | <ul>
--   <li><i>of-dec <i>E</i> -fracle /N</i> Add term /N as fracle (fraction
--   length) of decimal number <i>E</i>.</li>
--   <li><i>of-dec <i>E</i> -num /N</i> Add term /N as numerator of decimal
--   number <i>E</i>.</li>
--   <li><i>of-dec <i>E</i> -denom /N</i> Add term /N as denominator of
--   decimal number <i>E</i>.</li>
--   <li><i>of-dec <i>E</i> -sign /N</i> Add term /N as sign of decimal
--   number <i>E</i>, i.e., -1, 0, or 1.</li>
--   </ul>
consOfDec :: (CContent c) => RopCons c

-- | Create <tt>of-dect</tt> relmap.
relmapOfDec :: (CContent c) => Intmed c -> (CopSet c, Cox c, [Maybe TermName]) -> Relmap c

-- | Create <tt>of-dec</tt> relkit.
relkitOfDec :: (CContent c) => (CopSet c, Cox c, [Maybe TermName]) -> RelkitFlow c

-- | <ul>
--   <li><i>alt-dec /P -fracle <i>F</i></i> Alter fracle of decimal number
--   to <i>F</i> in term /P.</li>
--   </ul>
consAltDec :: (CContent c) => RopCons c

-- | Create <tt>alt-dec</tt> relmap.
relmapAltDec :: (CContent c) => Intmed c -> (CopSet c, TermName, MaybeCox c) -> Relmap c

-- | Create <tt>alt-dec</tt> relkit.
relkitAltDec :: (CContent c) => (CopSet c, TermName, MaybeCox c) -> RelkitFlow c

-- | <ul>
--   <li><i>to-dec /P ...</i> Convert content of term /P ... to decimal
--   number.</li>
--   </ul>
consToDec :: (CContent c) => RopCons c

-- | Create <tt>to-dec</tt> relmap.
relmapToDec :: (CContent c) => Intmed c -> [TermName] -> Relmap c

-- | Create <tt>to-dec</tt> relkit.
relkitToDec :: (CContent c) => [TermName] -> RelkitFlow c


-- | Relmap operators for clock type.
module Koshucode.Baala.Rop.Cox.Type.Clock

-- | Implementation of relational operators.
ropsTypeClock :: (CContent c) => [Rop c]

-- | <ul>
--   <li><i>add-clock /c -day <i>D</i></i> Add term /c as a clock of
--   <i>D</i> days, i.e., <tt>|D'|</tt>.</li>
--   <li><i>add-clock /c -hour <i>H</i></i> Add term /c as a clock of
--   <i>H</i> hours, i.e., <tt>|H|</tt>.</li>
--   <li><i>add-clock /c -min <i>M</i></i> Add term /c as a clock of
--   <i>M</i> minutes, i.e., <tt>|00:M|</tt>.</li>
--   <li><i>add-clock /c -sec <i>S</i></i> Add term /c as a clock of
--   <i>S</i> seconds, i.e., <tt>|00:00:S|</tt>.</li>
--   </ul>
consAddClock :: (CContent c) => RopCons c

-- | Create <tt>clock</tt> relmap.
relmapAddClock :: (CContent c) => Intmed c -> (CopSet c, TermName, (Cox c, Cox c, (MaybeCox c, MaybeCox c, MaybeCox c))) -> Relmap c

-- | Create <tt>clock</tt> relkit.
relkitAddClock :: (CContent c) => (CopSet c, TermName, (Cox c, Cox c, (MaybeCox c, MaybeCox c, MaybeCox c))) -> RelkitFlow c

-- | <ul>
--   <li><i>of-clock <i>E</i> -day /N</i> Add term /N as decimal days of
--   clock.</li>
--   <li><i>of-clock <i>E</i> -hour /N</i> Add term /N as decimal hours of
--   clock.</li>
--   <li><i>of-clock <i>E</i> -min /N</i> Add term /N as decimal minutes of
--   clock.</li>
--   <li><i>of-clock <i>E</i> -sec /N</i> Add term /N as decimal seconds of
--   clock.</li>
--   <li><i>of-clock <i>E</i> -sign /N</i> Add term /N as decimal sign of
--   clock, i.e., -1, 0, or 1.</li>
--   </ul>
consOfClock :: (CContent c) => RopCons c

-- | Create <tt>of-clockt</tt> relmap.
relmapOfClock :: (CContent c) => Intmed c -> (CopSet c, Cox c, [Maybe TermName]) -> Relmap c

-- | Create <tt>of-clock</tt> relkit.
relkitOfClock :: (CContent c) => (CopSet c, Cox c, [Maybe TermName]) -> RelkitFlow c

-- | <ul>
--   <li><i>alt-clock /P ... -day <i>D</i></i> Alter days of clock to
--   <i>D</i> in term /P ....</li>
--   <li><i>alt-clock /P ... -hour <i>H</i></i> Alter hours of clock to
--   <i>H</i> in term /P ....</li>
--   <li><i>alt-clock /P ... -min <i>M</i></i> Alter minutes of clock to
--   <i>M</i> in term /P ....</li>
--   <li><i>alt-clock /P ... -sec <i>S</i></i> Alter seconds of clock to
--   <i>S</i> in term /P ....</li>
--   </ul>
consAltClock :: (CContent c) => RopCons c

-- | Create <tt>alt-clock</tt> relmap.
relmapAltClock :: (CContent c) => Intmed c -> (CopSet c, [TermName], (MaybeCox c, MaybeCox c, MaybeCox c, MaybeCox c)) -> Relmap c

-- | Create <tt>alt-clock</tt> relkit.
relkitAltClock :: (CContent c) => (CopSet c, [TermName], (MaybeCox c, MaybeCox c, MaybeCox c, MaybeCox c)) -> RelkitFlow c


-- | Conversion geographic point from the plane rectangular coordinates
--   <tt>/n</tt> <tt>/x</tt> <tt>/y</tt> to the geographic coordinates
--   <tt>/latitude</tt> <tt>/longtitude</tt>. This program is based on the
--   method described in <i>Kazushige KAWASE, 2011,</i> <i>A More Concise
--   Method of Calculation for the Coordinate</i> <i>Conversion between
--   Geographic and Plane Rectangular</i> <i>Coordinates on the
--   Gauss-KruÌˆger Projection,</i> <i>Bulletin of the Geospatial
--   Information Authority of Japan, 121</i>.
module Koshucode.Baala.Rop.Cox.GeoDatumJp

-- | Point in geographic coordinate system.
type GeoPoint = (Double, Double)

-- | Convert point in plane rectangular coordinates to degrees of latitude
--   and longitude.
--   
--   <pre>
--   &gt;&gt;&gt; convDegree 8 (0.0, 0.0)
--   (35.99999999999999, 138.5)
--   </pre>
convDegree :: Int -> GeoPoint -> GeoPoint

-- | Convert point in plane rectangular coordinates to geographic latitude
--   and longitude.
--   
--   <pre>
--   &gt;&gt;&gt; convRadian 8 (0.0, 0.0)
--   (0.6283185307179585, 498600.0)
--   </pre>
convRadian :: Int -> GeoPoint -> GeoPoint


-- | Generate range of contents.
module Koshucode.Baala.Rop.Cox.Range

-- | Implementation of relational operators.
ropsCoxRange :: (CContent c) => [Rop c]

-- | Attribute for range operators.
type RangeAttr c = (TermName, CopSet c, Cox c, Cox c)

-- | <b>range /N -from E -to E</b>
consRange :: (CContent c) => RopCons c

-- | Create <tt>range</tt> relmap.
relmapRange :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-year</tt> relmap.
relmapRangeYear :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-year</tt> relkit.
relkitRangeYear :: (CContent c) => RangeAttr c -> RelkitFlow c

-- | Create <tt>range-month</tt> relmap.
relmapRangeMonth :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-month</tt> relkit.
relkitRangeMonth :: (CContent c) => RangeAttr c -> RelkitFlow c

-- | Create <tt>range-day</tt> relmap.
relmapRangeDay :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-day</tt> relkit.
relkitRangeDay :: (CContent c) => RangeAttr c -> RelkitFlow c

-- | Create <tt>range-hour</tt> relmap.
relmapRangeHour :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-hour</tt> relkit.
relkitRangeHour :: (CContent c) => RangeAttr c -> RelkitFlow c

-- | Create <tt>range-minute</tt> relmap.
relmapRangeMinute :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-minute</tt> relkit.
relkitRangeMinute :: (CContent c) => RangeAttr c -> RelkitFlow c

-- | Create <tt>range-second</tt> relmap.
relmapRangeSecond :: (CContent c) => Intmed c -> RangeAttr c -> Relmap c

-- | Create <tt>range-second</tt> relkit.
relkitRangeSecond :: (CContent c) => RangeAttr c -> RelkitFlow c


-- | Gadgets with content calculation.
module Koshucode.Baala.Rop.Cox.Gadget

-- | Implementation of relational operators.
ropsCoxGadget :: (CContent c) => [Rop c]

-- | <ul>
--   <li><i>const <i>E</i></i> Output the constant relation E. Especially,
--   <tt>const {= [] =}</tt> is equivalent to <tt>dee</tt>, <tt>const {=
--   =}</tt> is equivalent to <tt>dum</tt>.</li>
--   </ul>
consConst :: (CContent c) => RopCons c

-- | Create <tt>const</tt> relmap.
relmapConst :: Intmed c -> Rel c -> Relmap c

-- | Create <tt>const</tt> relkit.
relkitConst :: Rel c -> RelkitFlow c

-- | <b>number /N -from I -order /P ...</b>
consNumber :: (Ord c, CContent c) => RopCons c

-- | Create <tt>number</tt> relmap.
relmapNumber :: (CDec c, Ord c) => Intmed c -> (TermName, [TermName], Int) -> Relmap c

-- | Create <tt>number</tt> relkit.
relkitNumber :: (Ord c, CDec c) => (TermName, [TermName], Int) -> RelkitFlow c

-- | <ul>
--   <li><i>rank /N -from I -order /P ...</i> Calculate standard
--   competition ranking (like 1224).</li>
--   <li><i>rank /N -dense -from I -order /P...</i> Calculate dense ranking
--   (like 1223).</li>
--   </ul>
consRank :: (Ord c, CContent c) => RopCons c

-- | Create <tt>rank</tt> relmap.
relmapGapRank :: (CDec c, Ord c) => Intmed c -> (TermName, [TermName], Int) -> Relmap c

-- | Create <tt>rank</tt> relkit.
relkitGapRank :: (Ord c, CDec c) => (TermName, [TermName], Int) -> RelkitFlow c

-- | Create <tt>rank -dense</tt> relmap.
relmapDenseRank :: (CDec c, Ord c) => Intmed c -> (TermName, [TermName], Int) -> Relmap c

-- | Create <tt>rank -dense</tt> relkit.
relkitDenseRank :: (Ord c, CDec c) => (TermName, [TermName], Int) -> RelkitFlow c

-- | <b>repeat I R</b>
consRepeat :: (Ord c, CContent c) => RopCons c

-- | <ul>
--   <li><i>array <i>/P /P</i> ... -to <i>/N E</i> ...</i> Convert discrete
--   tuples of <i>/P /P</i> ... to term array <i>/N</i> .... The first
--   <i>/P</i> of <i>/P /P</i> is a key term of which content is equal to
--   <i>E</i>, and the second is a value of the key. When <i>E</i> is
--   omitted, term name content is used, e.g., <tt>-to /1 /2</tt> means
--   <tt>-to /1 '/1 /2 '/2</tt>. The length of <i>/P /P</i> ... must be
--   even. Relmap like <tt>array /k /v /ka /va -to /1 /1a /2 /2a ...</tt>
--   works for multiple key-value pairs.</li>
--   </ul>
--   
--   <pre>
--   RELMAP
--     array /key /val  -to /1 1  /2 2  /3 3  /4 4
--                             :     :     :     :
--                             :.....:.....:.....:.... /key
--   
--   INPUT                    OUTPUT
--     /group  /key  /val       /group  /1    /2    /3    /4
--     ======= ===== -----      ======= ----- ----- ----- -----
--     'a      1     10         'a      10    20    30    ()
--     'a      2     20         'b      40    50    ()    ()
--     'a      3     30                 .                  .
--     'b      1     40                 :..................:
--     'b      2     50                 term array
--   </pre>
consArray :: (CContent c) => RopCons c

-- | Create <tt>array</tt> relmap.
relmapArray :: (CContent c) => Intmed c -> ([TermName2], Int, [[Term c]]) -> Relmap c

-- | Create <tt>array</tt> relkit.
relkitArray :: (CContent c) => ([TermName2], Int, [[Term c]]) -> RelkitFlow c

-- | <ul>
--   <li><i>unarray <i>/N /N</i> ... -from <i>/P E</i> ...</i> Convert term
--   array <i>/P</i> ... to discrete tuples of <i>/N /N</i> ....</li>
--   </ul>
--   
--   <pre>
--   RELMAP
--     unarray /key /val  -from /1 1  /2 2  /3 3  /4 4
--                                 :     :     :     :
--                                 :.....:.....:.....:.... /key
--   
--   INPUT                                 OUTPUT
--     /group  /1    /2    /3    /4          /group  /key  /val
--     ======= ----- ----- ----- -----       ======= ===== -----
--     'a      10    20    30    ()          'a      1     10
--     'b      40    50    ()    ()          'a      2     20
--             .                  .          'a      3     30
--             :..................:          'a      4     ()
--             term array                    'b      1     40
--                                           'b      2     50
--                                           'b      3     ()
--                                           'b      4     ()
--   </pre>
consUnarray :: (CContent c) => RopCons c

-- | Create <tt>unarray</tt> relmap.
relmapUnarray :: (CContent c) => Intmed c -> ([TermName2], Int, [[Term c]]) -> Relmap c

-- | Create <tt>unarray</tt> relkit.
relkitUnarray :: (CContent c) => ([TermName2], Int, [[Term c]]) -> RelkitFlow c


-- | Relation filter.
module Koshucode.Baala.Rop.Cox.Filter

-- | Implementation of relational operators.
ropsCoxFilter :: (CContent c) => [Rop c]

-- | <ul>
--   <li><i>keep <i>E</i> -let { <i>D</i> | ... }</i> Keep tuples which
--   expression <i>E</i> is true.</li>
--   <li><i>omit <i>E</i> -let { <i>D</i> | ... }</i> Omit tuples which
--   expression <i>E</i> is true.</li>
--   </ul>
--   
--   <tt>omit</tt> is the inverse operator of <tt>keep</tt>.
--   
--   <pre>
--   keep E = omit not E
--   </pre>
consFilter :: (CContent c) => Bool -> RopCons c

-- | Create <tt>keep</tt> and <tt>omit</tt> relmap.
relmapFilter :: (CContent c) => Intmed c -> (Bool, CopSet c, Cox c) -> Relmap c

-- | Create <tt>keep</tt> and <tt>omit</tt> relkit.
relkitFilter :: (CContent c) => (Bool, CopSet c, Cox c) -> RelkitFlow c

-- | <b>contain E</b>
--   
--   Keep tuples in which some terms has content E.
consContain :: (CContent c) => RopCons c

-- | Create <tt>contain</tt> relmap.
relmapContain :: (Eq c) => Intmed c -> c -> Relmap c

-- | Create <tt>contain</tt> relkit.
relkitContain :: (Eq c) => c -> RelkitFlow c

-- | <b>omit-all</b>
--   
--   Throw away all tuples.
consOmitAll :: RopCons c

-- | Create <tt>omit-all</tt> relmap.
relmapOmitAll :: Intmed c -> Relmap c


-- | Relational compositions whose contents are maybe the empty.
module Koshucode.Baala.Rop.Cox.Empty

-- | Relmap operators that handles empties.
ropsCoxEmpty :: (CContent c) => [Rop c]

-- | <b>both R -share /P ... -fill E</b>
consBoth :: (CContent c) => RopCons c

-- | Create <tt>both</tt> relmap.
relmapBoth :: (Ord c, CRel c) => Intmed c -> SharedTerms -> c -> Map (Relmap c)

-- | <ul>
--   <li><i>maybe <i>R</i> -share <i>/P</i> ... -fill <i>E</i></i> Meet
--   input and given relation <i>R</i>. It keeps input tuples of which
--   counterparts are totally negated.</li>
--   <li><i>maybe <i>R</i> -only <i>E</i> -order <i>/P</i> ... -top
--   <i>N</i> -mid <i>N</i> -bot <i>N</i></i> Maybe with restriction by
--   <i>E</i> and limit to <i>N</i> tuples.</li>
--   <li><i>maybe <i>R</i> -only <i>E</i> -order <i>/P</i> ... -part
--   <i>N</i> -of <i>N</i></i> Maybe with restriction by <i>E</i> and take
--   <i>N</i>'th part.</li>
--   </ul>
consMaybe :: (CContent c) => RopCons c

-- | Create <tt>maybe</tt> relmap.
relmapMaybe :: (Ord c, CRel c) => Intmed c -> SharedTerms -> c -> Map (Relmap c)

-- | Create <tt>maybe</tt> relkit.
relkitMaybe :: (Ord c, CRel c) => SharedTerms -> c -> RelkitBinary c

-- | Parameter for <tt>meet -only</tt>.
type MeetOnly c = (SharedTerms, CopSet c, Cox c, RelPortion)

-- | Create <tt>maybe</tt>-with-restriction relmap.
relmapMaybeOnly :: (CContent c) => Intmed c -> (MeetOnly c, c) -> Map (Relmap c)

-- | <b>compose-maybe R -share /P ... -fill E</b>
--   
--   Construct relmap for relational composition.
consComposeMaybe :: (CContent c) => RopCons c

-- | Create <tt>compose-maybe</tt> relmap.
relmapComposeMaybe :: (Ord c, CRel c) => Intmed c -> SharedTerms -> c -> Map (Relmap c)


-- | Relmap operator with content calculation.
module Koshucode.Baala.Rop.Cox.Calc

-- | Implementation of relational operators.
ropsCoxCalc :: (CContent c) => [Rop c]

-- | <ul>
--   <li><i>add <i>/N</i> <i>E</i> ... -let { <i>D</i> | ... } </i>
--   Calculate expression <i>E</i> of term <i>/N</i>, and add terms
--   <i>/N</i> ... to input relation.</li>
--   </ul>
consAdd :: (CContent c) => RopCons c

-- | Create <tt>add</tt> relmap.
relmapAdd :: (CContent c) => Intmed c -> (CopSet c, [TermCox c]) -> Relmap c

-- | <ul>
--   <li><i>alt <i>/P</i> <i>E</i> ... -let { <i>D</i> | ... }</i>
--   Calculate expression <i>E</i> of term <i>/P</i>, and alter the
--   contents of present terms <i>/P</i> ....</li>
--   </ul>
consAlt :: (CContent c) => RopCons c

-- | Create <tt>alt</tt> relmap.
relmapAlt :: (CContent c) => Intmed c -> (CopSet c, [TermCox c]) -> Relmap c

-- | <ul>
--   <li><i>fill <i>/P</i> ... -with <i>E</i></i> Fill contents of present
--   terms <i>/P</i> ... with the result of <i>E</i>.</li>
--   </ul>
consFill :: (CContent c) => RopCons c

-- | Create <tt>fill</tt> relmap.
relmapFill :: (CContent c) => Intmed c -> ([TermName], CopSet c, Cox c) -> Relmap c

-- | <b>map /P ... -by F</b>
consReplace :: (CContent c) => RopCons c

-- | <b>replace-all -from E -to E</b>
consReplaceAll :: (CContent c) => RopCons c

-- | Create <tt>replace-all</tt> relmap.
relmapReplaceAll :: (CContent c) => Intmed c -> (CopSet c, Cox c, Cox c) -> Relmap c

-- | <ul>
--   <li><i>split <i>/N E</i> ... -let { <i>D</i> | ... }</i> Split input
--   relation by the boolean functions <i>E</i> ..., and add terms
--   <i>/N</i> ... which has the splitted relations.</li>
--   </ul>
--   
--   <pre>
--   RELMAP
--     split /a ( /x = 1 )
--           /b ( /y = 10 )
--   
--   INPUT              OUTPUT
--      /x    /y          /a          /b
--      ----- -----       ----------- -----------
--      1     10          /x    /y    /x    /y
--      2     20          ----- ----- ----- -----
--      3     10          1     10    3     10
--      1     20          1     20
--      2     30
--   </pre>
consSplit :: (CContent c) => RopCons c

-- | Create <tt>split</tt> relmap.
relmapSplit :: (CContent c) => Intmed c -> (CopSet c, [TermCox c]) -> Relmap c

-- | Create <tt>split</tt> relkit.
relkitSplit :: (CContent c) => (CopSet c, [TermCox c]) -> RelkitFlow c

-- | <b>unary /N E : ...</b>
consUnary :: (CContent c) => RopCons c

-- | Create <tt>unary</tt> relmap.
relmapUnary :: (CContent c) => Intmed c -> (TermName, [c]) -> Relmap c

-- | <ul>
--   <li><i>dump-cox <i>E</i></i></li>
--   </ul>
consDumpCox :: (CContent c) => RopCons c


-- | Relational operators with content calculation.
module Koshucode.Baala.Rop.Cox.Rops

-- | Relational operators with content calculation.
ropsCox :: (CContent c) => [Rop c]


-- | Operators in Koshucode.
module Koshucode.Baala.Rop.Cox
