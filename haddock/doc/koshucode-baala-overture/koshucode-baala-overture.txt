-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Preliminary library for Koshucode
--   
--   Preliminary library for Koshucode.
@package koshucode-baala-overture
@version 0.210.0.0


-- | Exit process.
module Koshucode.Baala.System.Exit

-- | Exit process.
exit :: Int -> IO a

-- | Map integer value to exit code.
exitCode :: Int -> ExitCode

-- | Print message and exit on 0.
putSuccess :: String -> IO a

-- | Print message line and exit on 0.
putSuccessLn :: String -> IO a

-- | Print abort message and exit on 1.
--   
--   <pre>
--   &gt;&gt;&gt; putAbort
--   ABORT / &lt;interactive&gt; exits on 1
--   </pre>
putAbort :: IO a

-- | Print error and abort message and exit on 1.
putAbortWith :: String -> IO a

-- | Print error message and exit on 1.
putFailure :: String -> IO a

-- | Print error message line and exit on 1.
putFailureLn :: String -> IO a


-- | Parser for command-line interface parameter. This module is based on
--   <a>System.Console.GetOpt</a>.
module Koshucode.Baala.System.CliParser

-- | Option definition.
type Option = OptDescr Para

-- | Long name options, like <tt>help</tt> of <tt>--help</tt>.
type OptionName = String

-- | Single letter options, like <tt>h</tt> of <tt>-h</tt>.
type OptionLetter = Char

-- | Explanation of option.
type OptionExplain = String

-- | Option definition for flag (switch) type.
--   
--   <pre>
--   flag ['f'] ["foo"] "Echo foo"
--   </pre>
flag :: [OptionLetter] -> [OptionName] -> OptionExplain -> Option

-- | Option definition with required one parameter.
--   
--   <pre>
--   req [] ["baz"] "text" "Echo baz and text"
--   </pre>
req :: [OptionLetter] -> [OptionName] -> String -> OptionExplain -> Option

-- | Option definition with optional one parameter.
--   
--   <pre>
--   opt [] ["bar"] "text" "Echo bar or text"
--   </pre>
opt :: [OptionLetter] -> [OptionName] -> String -> OptionExplain -> Option

-- | Result of parsing command-line parameters, consist of (1) error
--   message or (2) options and non-option parameters.
type Parsed = Either [String] ([Para], [String])

-- | Parse command-line parameters.
parse :: [Option] -> [String] -> Parsed

-- | Parse command-line parameters of the current process.
parseCommand :: [Option] -> IO Parsed

-- | Program name and command-line arguments. This function removes carrige
--   returns from the arguments.
progAndArgs :: IO (String, [String])

-- | Actual optional parameter.
data Para

-- | Get flag of <a>flag</a>-type option.
--   
--   <pre>
--   &gt;&gt;&gt; let Right (o,p) = parse [help, version] ["-h", "foo", "bar"]
--   
--   &gt;&gt;&gt; getFlag o "help"
--   True
--   
--   &gt;&gt;&gt; p
--   ["foo","bar"]
--   </pre>
getFlag :: [Para] -> OptionName -> Bool

-- | Get parameter list of <a>req</a>-type option.
--   
--   <pre>
--   &gt;&gt;&gt; let Right (o,p) = parse [req [] ["a"] "text" "required text"] ["--a=foo", "bar"]
--   
--   &gt;&gt;&gt; getReq o "a"
--   ["foo"]
--   
--   &gt;&gt;&gt; p
--   ["bar"]
--   </pre>
getReq :: [Para] -> OptionName -> [String]

-- | Get last parameter of <a>req</a>-type option.
getReqLast :: [Para] -> OptionName -> Maybe String

-- | Get parameter list of <a>opt</a>-type option.
--   
--   <pre>
--   &gt;&gt;&gt; let Right (o,p) = parse [opt [] ["a"] "text" "optional text"] ["--a", "--a=foo", "bar"]
--   
--   &gt;&gt;&gt; getOpt o "a" "default"
--   ["default","foo"]
--   
--   &gt;&gt;&gt; p
--   ["bar"]
--   </pre>
getOpt :: [Para] -> OptionName -> String -> [String]

-- | Get last parameter of <a>opt</a>-type option.
getOptLast :: [Para] -> OptionName -> String -> Maybe String

-- | Predefined <tt>-h</tt> or <tt>--help</tt> option.
--   
--   <pre>
--   flag "h" ["help"] "Show help message"
--   </pre>
help :: Option

-- | Create help message.
helpMessage :: [String] -> [Option] -> String

-- | Print help message.
printHelp :: [String] -> [Option] -> IO ()

-- | Predefined <tt>-V</tt> or <tt>--version</tt> option.
--   
--   <pre>
--   flag "V" ["version"] "Show version number"
--   </pre>
version :: Option

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String
instance GHC.Classes.Ord Koshucode.Baala.System.CliParser.Para
instance GHC.Classes.Eq Koshucode.Baala.System.CliParser.Para
instance GHC.Show.Show Koshucode.Baala.System.CliParser.Para


-- | Bundle of system modules.
module Koshucode.Baala.System


-- | Unicode general categories.
module Koshucode.Baala.Overture.Text.Unicode

-- | Major category of the Unicode general categories.
data MajorGeneralCategory

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: MajorGeneralCategory

-- | Mn Mc Me
UnicodeMark :: MajorGeneralCategory

-- | Nd Nl No
UnicodeNumber :: MajorGeneralCategory

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: MajorGeneralCategory

-- | Sm Sc Sk So
UnicodeSymbol :: MajorGeneralCategory

-- | Zs Zl Zp
UnicodeSeperator :: MajorGeneralCategory

-- | Cc Cf Cs Co Cn
UnicodeOther :: MajorGeneralCategory

-- | Major general category of character.
majorGeneralCategory :: Char -> MajorGeneralCategory

-- | Convert general category to major category.
toMajorGeneralCategory :: GeneralCategory -> MajorGeneralCategory

-- | Name of general category. This function returns one of
--   <tt>letter</tt>, <tt>mark</tt>, <tt>number</tt>, <tt>punct</tt>,
--   <tt>symbol</tt>, <tt>sep</tt>, or <tt>other</tt>.
generalCategoryName :: MajorGeneralCategory -> String

-- | Major-minor category symbols like <tt>Lu</tt>.
generalCategoryLetter :: GeneralCategory -> String

-- | One-letter representation of general category. This function returns
--   one of <tt>L</tt> (letter), <tt>M</tt> (mark), <tt>N</tt> (number),
--   <tt>P</tt> (punctuation), <tt>S</tt> (symbol), <tt>Z</tt> (seperator),
--   or <tt>C</tt> (other).
generalCategoryMajorLetter :: MajorGeneralCategory -> Char

-- | One-letter representation of minor general category.
generalCategoryMinorLetter :: GeneralCategory -> Char
instance GHC.Enum.Bounded Koshucode.Baala.Overture.Text.Unicode.MajorGeneralCategory
instance GHC.Classes.Ord Koshucode.Baala.Overture.Text.Unicode.MajorGeneralCategory
instance GHC.Classes.Eq Koshucode.Baala.Overture.Text.Unicode.MajorGeneralCategory
instance GHC.Show.Show Koshucode.Baala.Overture.Text.Unicode.MajorGeneralCategory


-- | Unicode general category.
module Koshucode.Baala.Overture.Text.Category

-- | List of letter categories (L).
categoryLetter :: [GeneralCategory]

-- | List of mark categories (M).
categoryMark :: [GeneralCategory]

-- | List of number categories (N).
categoryNumber :: [GeneralCategory]

-- | List of punctuation categories (P).
categoryPunctuation :: [GeneralCategory]

-- | List of symbol categories (S).
categorySymbol :: [GeneralCategory]

-- | List of separator categories (Z).
categorySeparator :: [GeneralCategory]

-- | List of other categories (C).
categoryOther :: [GeneralCategory]

-- | List of alphabetic categories (L + M).
categoryAlpha :: [GeneralCategory]

-- | List of textual-sign categories (P + S).
categorySign :: [GeneralCategory]

-- | List of open brackets (Ps + Pi).
categoryOpen :: [GeneralCategory]

-- | List of close brackets (Pe + Pf).
categoryClose :: [GeneralCategory]

-- | Lookup unicode general categories by its short name. Short name means
--   two-letter category name (e.g., <tt>"lu"</tt> for upper case letter,
--   <tt>"zs"</tt> for space), or one-letter category group (e.g.,
--   <tt>"l"</tt> for letter, <tt>"z"</tt> for separator).
--   
--   <pre>
--   &gt;&gt;&gt; categoryLookup "lu"
--   Right (fromList [UppercaseLetter])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; categoryLookup "n"
--   Right (fromList [DecimalNumber, LetterNumber, OtherNumber])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; categoryLookup "lx"
--   Left "lx"
--   </pre>
categoryLookup :: String -> Either String (Set GeneralCategory)


-- | Text name.
module Koshucode.Baala.Overture.Name.Text

-- | Text name.
type Name = Text

-- | Class for types which has name.
class GetName a
getName :: GetName a => a -> Name


-- | Integer or string name.
module Koshucode.Baala.Overture.Name.IntString

-- | String or integer name.
data Name
NameI :: Int -> Name
NameS :: String -> Name

-- | Class for types which has name.
class GetName a
getName :: GetName a => a -> Name
instance GHC.Classes.Ord Koshucode.Baala.Overture.Name.IntString.Name
instance GHC.Classes.Eq Koshucode.Baala.Overture.Name.IntString.Name
instance GHC.Show.Show Koshucode.Baala.Overture.Name.IntString.Name


-- | String name.
module Koshucode.Baala.Overture.Name.String

-- | String name.
type Name = String

-- | Class for types which has name.
class GetName a
getName :: GetName a => a -> Name


-- | Named function.
module Koshucode.Baala.Overture.Fn

-- | String name.
type Name = String

-- | Named function.
data Fn a b
Fn :: Name -> (a -> b) -> Fn a b

-- | Two-argument named function.
data Fn2 a b c
Fn2 :: Name -> (a -> b -> c) -> Fn2 a b c
instance Koshucode.Baala.Overture.Name.String.GetName (Koshucode.Baala.Overture.Fn.Fn a b)
instance GHC.Show.Show (Koshucode.Baala.Overture.Fn.Fn a b)
instance GHC.Classes.Eq (Koshucode.Baala.Overture.Fn.Fn a b)
instance GHC.Classes.Ord (Koshucode.Baala.Overture.Fn.Fn a b)
instance Koshucode.Baala.Overture.Name.String.GetName (Koshucode.Baala.Overture.Fn.Fn2 a b c)
instance GHC.Show.Show (Koshucode.Baala.Overture.Fn.Fn2 a b c)
instance GHC.Classes.Eq (Koshucode.Baala.Overture.Fn.Fn2 a b c)
instance GHC.Classes.Ord (Koshucode.Baala.Overture.Fn.Fn2 a b c)


-- | Value of some types.
module Koshucode.Baala.Overture.Value

-- | Value of some types.
data Value

-- | Empty
VEmpty :: Value

-- | Boolean
VBool :: Bool -> Value

-- | Integer
VInt :: Int -> Value

-- | Integer
VInteger :: Integer -> Value

-- | Text
VStr :: String -> Value

-- | Strict text
VTx :: Text -> Value

-- | Lazy text
VTz :: Text -> Value

-- | List of values
VList :: [Value] -> Value
instance GHC.Classes.Ord Koshucode.Baala.Overture.Value.Value
instance GHC.Classes.Eq Koshucode.Baala.Overture.Value.Value
instance GHC.Show.Show Koshucode.Baala.Overture.Value.Value


-- | Derivied types.
module Koshucode.Baala.Overture.Type

-- | Homotype <a>Either</a>.
type Eith a = Either a a

-- | Extract <a>Eith</a> content.
--   
--   <pre>
--   &gt;&gt;&gt; uneith &lt;$&gt; [Left "L", Right "R"]
--   ["L", "R"]
--   </pre>
uneith :: Eith a -> a

-- | Map from something to same type.
type Map a = a -> a

-- | Map from something to list of something.
type ManyMap a = a -> [a]

-- | Map from string to string.
type StringMap = Map String

-- | Boolean-valued function, also called predicate.
type Test a = a -> Bool

-- | Boolean-valued function with 2 arguments.
type Test2 a b = a -> b -> Bool

-- | Type for binary operators.
type Bin a = a -> a -> a


-- | Something exists somewhere.
module Koshucode.Baala.Overture.Some

-- | Something exists.
class Some s where some = not . none none = not . some

-- | Test something exists.
--   
--   <pre>
--   &gt;&gt;&gt; some $ Just "foo"
--   True
--   </pre>
some :: Some s => s a -> Bool

-- | Test something does not exists.
--   
--   <pre>
--   &gt;&gt;&gt; none ["foo"]
--   False
--   </pre>
none :: Some s => s a -> Bool

-- | Extract something.
thing :: Some s => s a -> Maybe a

-- | Extract thing or return default thing.
--   
--   <pre>
--   &gt;&gt;&gt; ["foo", "bar"] |?| "baz"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] |?| "baz"
--   "baz"
--   </pre>
(|?|) :: (Some s) => s a -> a -> a

-- | Calculate alternatives if prior expression failed.
orElse :: (Some s) => s a -> s a -> s a

-- | Infix operator for <a>orElse</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &lt;||&gt; Just "foo" &lt;||&gt; Just "bar"
--     Just "foo"
--   </pre>
(<||>) :: (Some s) => s a -> s a -> s a
instance Koshucode.Baala.Overture.Some.Some GHC.Base.Maybe
instance Koshucode.Baala.Overture.Some.Some (Data.Either.Either a)
instance Koshucode.Baala.Overture.Some.Some []


-- | Shorthand types and functions.
module Koshucode.Baala.Overture.Shorthand

-- | Nominal pair type.
type Pair a b = (a, b)

-- | Twin pair.
type Twin a = (a, a)

-- | Strict bytestring.
type Bs = ByteString

-- | Lazy bytestring.
type Bz = ByteString

-- | Strict text.
type Tx = Text

-- | Lazy text.
type Tz = Text

-- | Just pair: <b>Jp <i>a b</i></b> is equal to <b>Just (<i>a</i>,
--   <i>b</i>)</b>.

-- | Double just pairs: <b>Jp2 <i>a b c</i></b> is equal to <b>Just
--   (<i>a</i>, Just (<i>b</i>, <i>c</i>))</b>.

-- | Triple just pairs: <b>Jp3 <i>a b c d</i></b> is equal to <b>Just
--   (<i>a</i>, Just (<i>b</i>, Just (<i>c</i>, <i>d</i>)))</b>.

-- | Test equality using <a>Ord</a> method. This function can be used for
--   implementing <a>Eq</a> instance.
--   
--   <pre>
--   instance Eq X where
--     (==) = ordEq
--   </pre>
ordEq :: (Ord a) => a -> a -> Bool

-- | <tt>compareOn</tt> <i>f</i> <i>x</i> <i>y</i> comapres <i>f x</i> and
--   <i>f y</i> instead of <i>x</i> and <i>y</i>.
--   
--   <pre>
--   &gt;&gt;&gt; compareOn length "foo" "bar"
--   EQ
--   </pre>
compareOn :: (Ord b) => (a -> b) -> a -> a -> Ordering

-- | <a>Int</a> shorthand.
--   
--   <pre>
--   &gt;&gt;&gt; int 12
--   12
--   </pre>
--   
--   This is same as:
--   
--   <pre>
--   &gt;&gt;&gt; 12 :: Int
--   12
--   </pre>
int :: Map Int

-- | <a>Integer</a> shorthand.
--   
--   <pre>
--   &gt;&gt;&gt; integer 12
--   12
--   </pre>
--   
--   This is same as:
--   
--   <pre>
--   &gt;&gt;&gt; 12 :: Integer
--   12
--   </pre>
integer :: Map Integer

-- | Function which always returns <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; nothing True :: Maybe String
--   Nothing
--   </pre>
nothing :: a -> Maybe b


-- | Miscellaneous functions.
module Koshucode.Baala.Overture.Misc

-- | URI, file path, etc.
type IOPath = String

-- | Type which has I/O path.
class GetIOPath a
getIOPath :: GetIOPath a => a -> IOPath

-- | Head and tail of list. This is a list version of text <a>uncons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; uncons "abcdefg"
--   Just ('a', "bcdefg")
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | Keep elements.
keepOn :: (a -> Maybe b) -> Test b -> Map [a]

-- | Omit elements.
omitOn :: (a -> Maybe b) -> Test b -> Map [a]

-- | 0 of type <a>Int</a>.
zero :: Int

-- | Inteeger list start with given integer.
--   
--   <pre>
--   &gt;&gt;&gt; take 4 $ ints 1
--   [1,2,3,4]
--   </pre>
ints :: Int -> [Int]

-- | Print list.
--   
--   <pre>
--   &gt;&gt;&gt; printList ["foo", "bar", "baz"]
--   "foo"
--   "bar"
--   "baz"
--   </pre>
printList :: (Show a) => [a] -> IO ()

-- | Truncate end of long string.
--   
--   <pre>
--   &gt;&gt;&gt; truncateString 10 "abcdefg"
--   "abcdefg"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truncateString 10 "abcdefg hijklmn"
--   "abcdefg..."
--   </pre>
truncateString :: Int -> StringMap
instance Koshucode.Baala.Overture.Misc.GetIOPath GHC.Base.String


-- | Infix operators.
module Koshucode.Baala.Overture.Infix

-- | Pairing operator.
--   
--   <pre>
--   &gt;&gt;&gt; "a" &amp; "b"
--   ("a", "b")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "a" &amp; "b" &amp; "c"
--   ("a", ("b", "c"))
--   </pre>
(&) :: a -> b -> (a, b)

-- | Associative operator of monoid, same as <a>mappend</a> or infix
--   <tt>&lt;&gt;</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Just "abc" ++ Nothing ++ Just "def"
--   Just "abcdef"
--   </pre>
(++) :: (Monoid a) => a -> a -> a

-- | Apply function to reversed list, and reverse back.
--   
--   <pre>
--   &gt;&gt;&gt; take 3 $ "abcdefg"
--   "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 3 /$/ "abcdefg"
--   "efg"
--   </pre>
(/$/) :: Map [a] -> Map [a]

-- | Same as <a>concatMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; words &lt;++&gt; ["foo bar", "baz quux"]
--   ["foo","bar","baz","quux"]
--   </pre>
(<++>) :: (a -> [b]) -> [a] -> [b]

-- | Same as <a>mapMaybe</a>.
(<?>) :: (a -> Maybe b) -> [a] -> [b]

-- | Double fmap.
--   
--   <pre>
--   &gt;&gt;&gt; length &lt;$$&gt; [("a", "apple"), ("b", "banana"), ("c", "cocoa")]
--   [("a",5), ("b",6), ("c",5)]
--   </pre>
(<$$>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | Monadic application, same as <a>=&lt;&lt;</a>.
(#) :: (Monad m) => (a -> m b) -> m a -> m b

-- | Composition of monadic functions, same as <a>&lt;=&lt;</a>.
(#.) :: (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c

-- | Monadic mapping, same as <a>mapM</a>.
(<#>) :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)

-- | Execution by monadic mapping, same as <a>mapM_</a>.
(<#!>) :: (Monad m, Traversable t) => (a -> m b) -> t a -> m ()

-- | Monadic concat mappping.
(<#++>) :: (Monad m) => (a -> m [b]) -> [a] -> m [b]


-- | Textual class.
module Koshucode.Baala.Overture.Text.Textual

-- | Text-like value.
class (Show t, Eq t, Ord t, Monoid t, IsString t) => Textual t where tEmpty = mempty tIsEmpty = (== tEmpty) tJoin = mappend tJoinAll = mconcat tJoinWith tw = first where first (t : ts) = t `tJoin` loop ts first [] = tEmpty loop (t : ts) = tw `tJoin` t `tJoin` loop ts loop [] = tEmpty tUnwords = tJoinWith " " tAdd2 c d = tAdd c . tAdd d tAdd3 c d e = tAdd c . tAdd2 d e tCut2 a = tCut <$$> tCut a tCut3 a = tCut2 <$$> tCut a tDropPrefix (tCut -> Just (c, cs)) (tCut -> Just (a, as)) | c == a = tDropPrefix cs as | otherwise = Nothing tDropPrefix cs as | tIsEmpty cs = Just as | otherwise = Nothing tMap f = loop where loop (tCut -> Just (c, cs)) = f c `tAdd` loop cs loop _ = tEmpty tList f = loop where loop (tCut -> Just (c, cs)) = f c : loop cs loop _ = [] tAll f = and . tList f tLength (tCut -> Just (_, t)) = 1 + tLength t tLength _ = 0 tWhile f t0 = loop 0 t0 where loop n (tCut -> Just (c, t)) | f c = loop (n + 1) t loop n t = (tTake n t0, t) tWhileNot f = tWhile (not . f) tDivide f t0 = loop (0 :: Int) t0 where loop n (tCut -> Just (c, t)) | f c = tTake n t0 : tDivide f t | otherwise = loop (n + 1) t loop n _ = [tTake n t0] tWords = tWordsBy isSpace tWordsBy f t0 = loop (0 :: Int) t0 where loop n (tCut -> Just (c, t)) | f c = tTake n t0 : (tWordsBy f $ snd $ tWhile f t) | otherwise = loop (n + 1) t loop 0 _ = [] loop n _ = [tTake n t0] charT c = tAdd c tEmpty char2T c d = tAdd2 c d tEmpty char3T c d e = tAdd3 c d e tEmpty charsT n c | n > 0 = tAdd c $ charsT (n - 1) c | otherwise = tEmpty showT = stringT . show bsT = bzT . fromStrict bzT = bsT . toStrict

-- | Empty text.
--   
--   <pre>
--   &gt;&gt;&gt; tEmpty :: String
--   ""
--   </pre>
tEmpty :: Textual t => t

-- | Test text is empty.
--   
--   <pre>
--   &gt;&gt;&gt; tIsEmpty ""
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tIsEmpty "foo"
--   False
--   </pre>
tIsEmpty :: Textual t => t -> Bool

-- | Append two texts.
--   
--   <pre>
--   &gt;&gt;&gt; tJoin "foo" "bar"
--   "foobar"
--   </pre>
tJoin :: Textual t => t -> t -> t

-- | Append multiple texts.
--   
--   <pre>
--   &gt;&gt;&gt; tJoinAll ["foo", "bar", "baz"]
--   "foobarbaz"
--   </pre>
tJoinAll :: Textual t => [t] -> t

-- | Append multiple texts with separator.
--   
--   <pre>
--   &gt;&gt;&gt; tJoinWith " | " ["foo", "bar", "baz"]
--   "foo | bar | baz"
--   </pre>
tJoinWith :: Textual t => t -> [t] -> t

-- | Append multiple texts with space.
--   
--   <pre>
--   &gt;&gt;&gt; tUnwords ["foo", "bar", "baz"]
--   "foo bar baz"
--   </pre>
tUnwords :: Textual t => [t] -> t

-- | Preppend character to text.
--   
--   <pre>
--   &gt;&gt;&gt; tAdd 'g' "foo"
--   "gfoo"
--   </pre>
tAdd :: Textual t => Char -> t -> t

-- | Preppend two characters to text.
--   
--   <pre>
--   &gt;&gt;&gt; tAdd2 'b' 'a' "foo"
--   "bafoo"
--   </pre>
tAdd2 :: Textual t => Char -> Char -> t -> t

-- | Preppend two characters to text.
--   
--   <pre>
--   &gt;&gt;&gt; tAdd3 'b' 'a' 'r' "foo"
--   "barfoo"
--   </pre>
tAdd3 :: Textual t => Char -> Char -> Char -> t -> t

-- | Split text into first character and rest of text.
--   
--   <pre>
--   &gt;&gt;&gt; tCut "foo"
--   Just ('f',"oo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tCut ""
--   Nothing
--   </pre>
tCut :: Textual t => t -> Maybe (Char, t)

-- | Split one or two characters.
--   
--   <pre>
--   &gt;&gt;&gt; tCut2 "bar"
--   Just ('b', Just ('a', "r"))
--   </pre>
tCut2 :: Textual t => t -> Maybe (Char, Maybe (Char, t))

-- | Split one, two, or three characters.
--   
--   <pre>
--   &gt;&gt;&gt; tCut3 "bar"
--   Just ('b', Just ('a', Just ('r', "")))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tCut3 "b"
--   Just ('b', Nothing)
--   </pre>
tCut3 :: Textual t => t -> Maybe (Char, Maybe (Char, Maybe (Char, t)))

-- | Take <i>N-#1</i> characters from <i>text-#2</i>.
--   
--   <pre>
--   &gt;&gt;&gt; tTake 3 "foobar"
--   "foo"
--   </pre>
tTake :: Textual t => Int -> t -> t

-- | Drop <i>N-#1</i> characters from <i>text-#2</i>.
--   
--   <pre>
--   &gt;&gt;&gt; tDrop 3 "foobar"
--   "bar"
--   </pre>
tDrop :: Textual t => Int -> t -> t

-- | Drop <i>prefix-#1</i> from <i>text-#2</i>.
--   
--   <pre>
--   &gt;&gt;&gt; tDropPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tDropPrefix "bar" "foobar"
--   Nothing
--   </pre>
tDropPrefix :: (Textual t, Textual a) => a -> t -> Maybe t

-- | Map <i>function-#1</i> to characters of <i>text-value-#2</i>.
tMap :: Textual t => (Char -> Char) -> t -> t

-- | Map <i>function-#1</i> to characters of <i>text-value-#2</i>.
--   
--   <pre>
--   &gt;&gt;&gt; tList fromEnum "bar"
--   [98,97,114]
--   </pre>
tList :: Textual t => (Char -> a) -> t -> [a]

-- | Test all characters of text value.
--   
--   <pre>
--   &gt;&gt;&gt; tAll (`elem` "0123456789.") "120.5"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tAll (`elem` "0123456789.") "120,000"
--   False
--   </pre>
tAll :: Textual t => (Char -> Bool) -> t -> Bool

-- | Length of <i>textual-value-#1</i>.
--   
--   <pre>
--   &gt;&gt;&gt; tLength "foo" :: Int
--   3
--   </pre>
tLength :: (Textual t, Integral n) => t -> n

-- | Take subtext from <i>textual-value-#2</i> while <i>tester-#1</i>
--   holds, and pairing the subtext with after.
--   
--   <pre>
--   &gt;&gt;&gt; tWhile (/= ' ') "foo bar baz"
--   ("foo", " bar baz")
--   </pre>
tWhile :: Textual t => (Char -> Bool) -> t -> (t, t)

-- | Take subtext from <i>textual-value-#2</i> while <i>tester-#1</i> do
--   not holds.
--   
--   <pre>
--   tWhileNot f t = tWhile (not . f) t
--   </pre>
tWhileNot :: Textual t => (Char -> Bool) -> t -> (t, t)

-- | Divide <i>textual-value-#2</i> to textual list by
--   <i>delimiter-tester-#1</i>.
--   
--   <pre>
--   &gt;&gt;&gt; tDivide (== '/') "foo/bar/baz"
--   ["foo","bar","baz"]
--   </pre>
tDivide :: Textual t => (Char -> Bool) -> t -> [t]

-- | Divide text into words.
--   
--   <pre>
--   &gt;&gt;&gt; tWords "a bb  ccc "
--   ["a", "bb", "ccc"]
--   </pre>
tWords :: Textual t => t -> [t]

-- | Divide text into words by character tester.
--   
--   <pre>
--   &gt;&gt;&gt; tWordsBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "ccc"]
--   </pre>
tWordsBy :: Textual t => (Char -> Bool) -> t -> [t]

-- | Create text from single character.
--   
--   <pre>
--   &gt;&gt;&gt; charT 'b' :: String
--   "b"
--   </pre>
charT :: Textual t => Char -> t

-- | Create text from two characters.
--   
--   <pre>
--   &gt;&gt;&gt; char2T 'b' 'a' :: String
--   "ba"
--   </pre>
char2T :: Textual t => Char -> Char -> t

-- | Create text from three characters.
--   
--   <pre>
--   &gt;&gt;&gt; char3T 'b' 'a' 'r' :: String
--   "bar"
--   </pre>
char3T :: Textual t => Char -> Char -> Char -> t

-- | <i>N</i>-length textual value.
--   
--   <pre>
--   &gt;&gt;&gt; charsT 4 '+' :: String
--   "++++"
--   </pre>
charsT :: Textual t => Int -> Char -> t

-- | Convert textual value to string.
--   
--   <pre>
--   &gt;&gt;&gt; tString "foo"
--   "foo"
--   </pre>
tString :: Textual t => t -> String

-- | Convert string to textual value.
--   
--   <pre>
--   &gt;&gt;&gt; stringT "foo" :: String
--   "foo"
--   </pre>
stringT :: Textual t => String -> t

-- | Convert textual value to strict text.
tTx :: Textual t => t -> Tx

-- | Convert strict text to textual value.
txT :: Textual t => Tx -> t

-- | Convert show instance to textual value.
--   
--   <pre>
--   &gt;&gt;&gt; showT (120 :: Int) :: String
--   "120"
--   </pre>
showT :: (Textual t, Show a) => a -> t

-- | Convert strict bytestring to textual value.
bsT :: Textual t => Bs -> t

-- | Convert lazy bytestring to textual value.
bzT :: Textual t => Bz -> t

-- | Add charactor to the top of textual value, same as <a>tAdd</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 'b' &lt;:&gt; "ar" :: String
--   "bar"
--   </pre>
(<:>) :: (Textual t) => Char -> t -> t

-- | Convert textual something to string something.
stringify :: (Functor f, Textual t) => f t -> f String
instance Koshucode.Baala.Overture.Text.Textual.Textual GHC.Base.String
instance Koshucode.Baala.Overture.Text.Textual.Textual Koshucode.Baala.Overture.Shorthand.Tx
instance Koshucode.Baala.Overture.Text.Textual.Textual Koshucode.Baala.Overture.Shorthand.Tz


-- | Encode and decode integers.
module Koshucode.Baala.Overture.Text.Integer

-- | Decode decimal integer.
tDec :: (Textual t, Eq n, Num n) => t -> Maybe n

-- | Decode decimal integer as <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tInt &lt;$&gt; ["12", "+12", "-12"]
--   [Just 12,Just 12,Just (-12)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tInt "12.3"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tInt "12345678901234567890"
--   Just (-6101065172474983726)
--   </pre>
tInt :: (Textual t) => t -> Maybe Int

-- | Decode decimal integer as <a>Integer</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tInteger "12345678901234567890"
--   Just 12345678901234567890
--   </pre>
tInteger :: (Textual t) => t -> Maybe Integer

-- | Decode hexadecimal digits.
tHex :: (Textual t, Eq n, Num n) => t -> Maybe n

-- | Decode hexadecimal digits as <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tHexInt "0F"
--   Just 15
--   </pre>
tHexInt :: (Textual t) => t -> Maybe Int

-- | Decode hexadecimal digits as <a>Integer</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tHexInteger "0F"
--   Just 15
--   </pre>
tHexInteger :: (Textual t) => t -> Maybe Integer

-- | Decode custom digits to integer.
--   
--   <pre>
--   &gt;&gt;&gt; tCustomInteger "01234567" "144"
--   Just 100
--   </pre>
tCustomInteger :: (Textual t) => String -> t -> Maybe Integer

-- | Decode counting digits to integer.
--   
--   <pre>
--   &gt;&gt;&gt; tCountInteger ['A'..'Z'] &lt;$&gt; ["", "A", "B", "Y", "Z", "AA", "AZ", "BA", "CV", "ALL", "KOSHU"]
--   [Just 0, Just 1, Just 2, Just 25, Just 26, Just 27, Just 52, Just 53, Just 100, Just 1000, Just 5303449]
--   </pre>
tCountInteger :: (Textual t) => String -> t -> Maybe Integer

-- | Decode decimal integer.

-- | <i>Deprecated: Use <a>tDec</a> instead.</i>
stringDec :: (Textual t, Eq n, Num n) => t -> Maybe n

-- | Decode decimal integer as <a>Int</a>.

-- | <i>Deprecated: Use <a>tInt</a> instead.</i>
stringInt :: (Textual t, Eq n, Num n) => t -> Maybe n

-- | Decode decimal integer as <a>Integer</a>.

-- | <i>Deprecated: Use <a>tInteger</a> instead.</i>
stringInteger :: (Textual t) => t -> Maybe Integer

-- | Decode hexadecimal digits.

-- | <i>Deprecated: Use <a>tHex</a> instead.</i>
stringHex :: (Textual t, Eq n, Num n) => t -> Maybe n

-- | Decode hexadecimal digits as <a>Int</a>.

-- | <i>Deprecated: Use <a>tHexInt</a> instead.</i>
stringHexInt :: (Textual t) => t -> Maybe Int

-- | Decode hexadecimal digits as <a>Integer</a>.

-- | <i>Deprecated: Use <a>tHexInteger</a> instead.</i>
stringHexInteger :: (Textual t) => t -> Maybe Integer

-- | Decode custom digits to integer.

-- | <i>Deprecated: Use <a>tCustomInteger</a> instead.</i>
stringCustomInteger :: (Textual t) => String -> t -> Maybe Integer

-- | Decode counting digits to integer.

-- | <i>Deprecated: Use <a>tCountInteger</a> instead.</i>
stringCountInteger :: (Textual t) => String -> t -> Maybe Integer

-- | Encode integer to hexadecimal string.
--   
--   <pre>
--   &gt;&gt;&gt; intHexString 15
--   "f"
--   </pre>
intLowerHexString :: (Textual t) => Int -> t

-- | Encode integer to hexadecimal string.
--   
--   <pre>
--   &gt;&gt;&gt; intUpperHexString 15
--   "F"
--   </pre>
intUpperHexString :: (Textual t) => Int -> t

-- | Encode integer to custome-digit string.
--   
--   <pre>
--   &gt;&gt;&gt; integralCustomString "OI" &lt;$&gt; [0..8 :: Int]
--   ["O", "I", "IO", "II", "IOO", "IOI", "IIO", "III", "IOOO"]
--   </pre>
integralCustomString :: (Integral n) => String -> n -> String

-- | Encode integer to counting string.
--   
--   <pre>
--   &gt;&gt;&gt; intReckonString ['A'..'Z'] &lt;$&gt; [0, 1, 2, 25, 26, 27, 52, 53, 100, 1000, 5303449]
--   ["", "A", "B", "Y", "Z", "AA", "AZ", "BA", "CV", "ALL", "KOSHU"]
--   </pre>
integralCountString :: (Integral n) => String -> n -> String

-- | Length of digits of integer.
--   
--   <pre>
--   &gt;&gt;&gt; digitsLength 10 12000
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; digitsLength 10 (-500)
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; digitsLength 2 15
--   4
--   </pre>
digitsLength :: Int -> Int -> Int


-- | Text utility.
module Koshucode.Baala.Overture.Text.Utility

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Remove space and space-like characters from the beginning of string.
--   
--   <pre>
--   &gt;&gt;&gt; trimBegin "  abc  "
--   "abc  "
--   </pre>
trimBegin :: (Textual t) => t -> t

-- | Remove space and space-like characters from the end of string.
--   
--   <pre>
--   &gt;&gt;&gt; trimEnd "  abc  "
--   "  abc"
--   </pre>
trimEnd :: (Textual t) => t -> t

-- | Remove space and space-like characters from the beginning and end of
--   string.
--   
--   <pre>
--   &gt;&gt;&gt; trimBoth "  abc  "
--   "abc"
--   </pre>
trimBoth :: (Textual t) => t -> t

-- | Trim and shorten consecutive spaces.
--   
--   <pre>
--   &gt;&gt;&gt; sweep "  foo  bar   baz "
--   "foo bar baz"
--   </pre>
sweep :: (Textual t) => t -> t

-- | Delete space characters.
--   
--   <pre>
--   &gt;&gt;&gt; sweepAll "  foo  bar   baz "
--   "foobarbaz"
--   </pre>
sweepAll :: (Textual t) => t -> t

-- | Add spaces to the left.
--   
--   <pre>
--   &gt;&gt;&gt; padBegin 10 "abc"
--   "       abc"
--   </pre>
padBegin :: Int -> StringMap

-- | Add spaces to the right.
--   
--   <pre>
--   &gt;&gt;&gt; padEnd 10 "abc"
--   "abc       "
--   </pre>
padEnd :: Int -> StringMap

-- | Add given character to the left.
--   
--   <pre>
--   &gt;&gt;&gt; padBeginWith '.' 10 "abc"
--   ".......abc"
--   </pre>
padBeginWith :: Char -> Int -> StringMap

-- | Add given character to the right.
padEndWith :: Char -> Int -> StringMap

-- | Calculate width of string.
stringWidth :: String -> Int

-- | Add space character if first character is non-space.
--   
--   <pre>
--   &gt;&gt;&gt; addSpace "aaa"
--   " aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; addSpace " bbb"
--   " bbb"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; addSpace ""
--   ""
--   </pre>
addSpace :: (Textual t) => t -> t

-- | Test ASCII code point (0 .. 127).
isAsciiCode :: (Integral n) => n -> Bool

-- | Test ASCII control code point (0 .. 31, 127).
isControlCode :: (Integral n) => n -> Bool

-- | Test format code point (9 .. 13).
isFormatCode :: (Integral n) => n -> Bool

-- | Test newline code point (10, 13).
isNewlineCode :: (Integral n) => n -> Bool

-- | Generic code point (9) of horizontal tab character (<tt>'\t'</tt>).
integralHT :: (Integral n) => n

-- | Generic code point (10) of line feed character (<tt>'\n'</tt>).
integralLF :: (Integral n) => n

-- | Generic code point (11) of vertical tab character (<tt>'\v'</tt>).
integralVT :: (Integral n) => n

-- | Generic code point (12) of form feed character (<tt>'\f'</tt>).
integralFF :: (Integral n) => n

-- | Generic code point (13) of carriage return character (<tt>'\r'</tt>).
integralCR :: (Integral n) => n

-- | Generic code point (32) of space character (<tt>' '</tt>).
integralSpace :: (Integral n) => n

-- | Print newline.
putLn :: IO ()

-- | Print newline.
hPutLn :: Handle -> IO ()

-- | Print showing value.
putShow :: (Show a) => a -> IO ()

-- | Print showing value with newline.
putShowLn :: (Show a) => a -> IO ()

-- | Print multiple lines.
putLines :: [String] -> IO ()

-- | Print multiple lines.
hPutLines :: Handle -> [String] -> IO ()

-- | Print prompt (<tt>&gt;&gt;</tt>) and read user input. It returns
--   trimmed input string. Reread when input is empty.
prompt :: IO String

-- | Print prompt with give string and read user input.
promptWith :: String -> IO String


-- | Bundle of text modules.
module Koshucode.Baala.Overture.Text


-- | Indexed value.
module Koshucode.Baala.Overture.Index

-- | Numerical index.
type Ix = Int

-- | <a>Int</a>-indexed type.
class GetIx a
getIx :: GetIx a => a -> Ix

-- | Numerical index.
type Index = Int

-- | <a>Integer</a>-indexed type.
class GetIndex a
getIndex :: GetIndex a => a -> Index


-- | Cache.
module Koshucode.Baala.Overture.Cache

-- | Cache data.
data Cache k v

-- | String cache.
type CacheS v = Cache String v

-- | Create empty cache of given limits and value function.
cache :: [Int] -> (k -> v) -> Cache k v

-- | Get cached value.
cacheGet :: (Ord k) => Cache k v -> k -> (Cache k v, v)

-- | Get cached values.
--   
--   <pre>
--   &gt;&gt;&gt; cacheGetList (cache [] id :: Cache Char Char) ['A' .. 'Z']
--   (Cache 27 "ABCDEFGHIJKLMNOPQR" "STUVWXYZ", "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
--   </pre>
cacheGetList :: (Ord k) => Cache k v -> [k] -> (Cache k v, [v])
instance GHC.Show.Show k => GHC.Show.Show (Koshucode.Baala.Overture.Cache.Cache k v)


-- | Bundle of overture modules.
module Koshucode.Baala.Overture
