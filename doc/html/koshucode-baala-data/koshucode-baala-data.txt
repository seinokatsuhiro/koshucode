-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-data
@version 0.119.0.0

module Koshucode.Baala.Data.Type.Para
type Para a = ParaBody String a
data ParaBody n a
ParaBody :: [a] -> [a] -> ParaMap n a -> ParaBody n a
paraAll :: ParaBody n a -> [a]
paraPos :: ParaBody n a -> [a]
paraName :: ParaBody n a -> ParaMap n a
type ParaMap n a = Map n [[a]]

-- | Parse list into parameter.
para :: Ord n => (a -> Maybe n) -> [a] -> ParaBody n a
paraEmpty :: ParaBody n a

-- | Association list of named parameters.
paraNameList :: ParaBody n a -> [(n, [[a]])]

-- | Add named parameter.
paraNameAdd :: Ord n => n -> [a] -> Map (ParaBody n a)

-- | Give names to positional parameters.
paraPosName :: (Ord n, Monad m) => ([a] -> m [(n, [a])]) -> ParaBody n a -> m (ParaBody n a)

-- | List of names which appear more than once.
paraMultipleNames :: ParaBody n a -> [n]

-- | Map names of named parameters.
paraNameMapKeys :: Ord n2 => (n1 -> n2) -> ParaBody n1 a -> ParaBody n2 a
paraLookupSingle :: Ord n => n -> ParaBody n a -> Maybe [a]
data ParaType n
ParaType :: ParaPosType -> [n] -> [n] -> [n] -> ParaType n
paraTypePos :: ParaType n -> ParaPosType
paraTypeReq :: ParaType n -> [n]
paraTypeOpt :: ParaType n -> [n]
paraTypeMult :: ParaType n -> [n]
data ParaPosType
ParaPosJust :: Int -> ParaPosType
ParaPosMin :: Int -> ParaPosType
ParaPosMax :: Int -> ParaPosType
ParaPosRange :: Int -> Int -> ParaPosType
paraType :: ParaType n
paraJust :: (Show n, Ord n) => ParaType n -> Int -> ParaType n
paraMin :: (Show n, Ord n) => ParaType n -> Int -> ParaType n
paraMax :: (Show n, Ord n) => ParaType n -> Int -> ParaType n
paraRange :: (Show n, Ord n) => ParaType n -> (Int, Int) -> ParaType n
paraReq :: (Show n, Ord n) => ParaType n -> [n] -> ParaType n
paraOpt :: (Show n, Ord n) => ParaType n -> [n] -> ParaType n
paraMult :: (Show n, Ord n) => ParaType n -> [n] -> ParaType n
data ParaUnmatch n
ParaOutOfRange :: Int -> ParaPosType -> ParaUnmatch n
ParaUnknown :: [n] -> ParaUnmatch n
ParaMissing :: [n] -> ParaUnmatch n
ParaMultiple :: [n] -> ParaUnmatch n
paraSelect :: Eq n => b -> [(ParaBody n a -> b, ParaType n)] -> ParaBody n a -> b
paraMatch :: Eq n => ParaBody n a -> ParaType n -> Bool
paraUnmatch :: Eq n => ParaBody n a -> ParaType n -> Maybe (ParaUnmatch n)
paraGet :: Ord n => ParaBody n a -> n -> Ab [a]
paraGetOpt :: Ord n => [a] -> ParaBody n a -> n -> Ab [a]
paraGetList :: Ord n => ParaBody n a -> n -> Ab [[a]]
paraGetSwitch :: Ord n => ParaBody n a -> n -> Ab Bool
paraGetPos :: ParaBody n a -> Ab [a]
paraGetFst :: ParaBody n a -> Ab a
paraGetSnd :: ParaBody n a -> Ab a
paraGetTrd :: ParaBody n a -> Ab a
paraGetRest :: ParaBody n a -> Ab [a]
paraGetRRest :: ParaBody n a -> Ab [a]
instance Typeable ParaBody
instance (Show n, Show a) => Show (ParaBody n a)
instance (Eq n, Eq a) => Eq (ParaBody n a)
instance (Ord n, Ord a) => Ord (ParaBody n a)
instance (Data n, Data a, Ord n) => Data (ParaBody n a)
instance Show ParaPosType
instance Eq ParaPosType
instance Ord ParaPosType
instance Show n => Show (ParaType n)
instance Eq n => Eq (ParaType n)
instance Ord n => Ord (ParaType n)
instance Show n => Show (ParaUnmatch n)
instance Eq n => Eq (ParaUnmatch n)
instance Ord n => Ord (ParaUnmatch n)
instance Ord n => Monoid (ParaBody n a)

module Koshucode.Baala.Data.Type.Decimal
data Decimal
Decimal :: (DecimalInteger, DecimalInteger) -> Int -> Bool -> Decimal
decimalRatio :: Decimal -> (DecimalInteger, DecimalInteger)
decimalLength :: Decimal -> Int
decimalApprox :: Decimal -> Bool
type DecimalInteger = Integer

-- | Test decimal is zero.
isDecimalZero :: Decimal -> Bool

-- | Numerator part of decimal number.
decimalNum :: Decimal -> DecimalInteger

-- | Denominator part of decimal number.
decimalDenom :: Decimal -> DecimalInteger

-- | Change precision.
decimalSetPoint :: Int -> AbMap Decimal

-- | Convert integral number to decimal number.
intDecimal :: DecimalInteger -> Decimal

-- | Convert real-float number to decimal number.
decimalFromRealFloat :: RealFloat n => Int -> n -> Decimal

-- | Convert decimal number to read-float number.
decimalToRealFloat :: RealFloat n => Decimal -> n

-- | Make <tt>a</tt> from a string.
type LitString a = String -> Ab a
type LitDecimal = LitString Decimal
litDecimal :: LitDecimal
decimalString :: Decimal -> String
type DecimalBinary = Decimal -> Decimal -> Ab Decimal
decimalAdd :: DecimalBinary
decimalSub :: DecimalBinary
decimalMul :: DecimalBinary
decimalDiv :: DecimalBinary
decimalQuo :: DecimalBinary
decimalRem :: DecimalBinary
decimalRevsign :: Map Decimal
decimalRevratio :: Map Decimal
decimalAbs :: Map Decimal
decimalSum :: [Decimal] -> Ab Decimal
instance Show Decimal
instance Eq Decimal
instance Ord Decimal

module Koshucode.Baala.Data.Type.Date
data Date

-- | Date in <i>YYYY-MM-DD</i>
Monthly :: MJDay -> Date

-- | Date in <i>YYYY-#W-D</i>
Weekly :: MJDay -> Date

-- | Date in <i>YYYY-##D</i>
Yearly :: MJDay -> Date
type MJDay = Day
type YmdTuple = (Year, Month, Day)
type Year = Integer
type Month = Int
type Week = Int
type Day = Int

-- | Create date from year, month, and day.
dateFromYmdAb :: Year -> Month -> Day -> Ab Date

-- | Create date from year, week, and day.
dateFromYwdAb :: Year -> Week -> Day -> Ab Date

-- | Create date from year and day.
dateFromYdAb :: Year -> Day -> Ab Date

-- | Get the internal Modified Julian Day.
dateDay :: Date -> MJDay
dateMapDay :: Map MJDay -> Map Date

-- | Convert into monthly date.
dateAdd :: Integral n => n -> Map Date

-- | Convert into weekly date.
monthly :: Map Date

-- | Convert into yearly date.
weekly :: Map Date
yearly :: Map Date
instance Show Date
instance Write Date
instance Ord Date
instance Eq Date

module Koshucode.Baala.Data.Type.Clock
data Clock

-- | Clock represented by multiple of second
ClockDhms :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of minute
ClockDhm :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of hour
ClockDh :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of day
ClockD :: DayCount -> Clock
type DayCount = Integer
type Hour = Int
type Min = Int
type Sec = Int

-- | Type for abortable binary operator.
type AbBin a = a -> a -> Ab a
writeClock :: Clock -> Doc
writeClockBody :: Clock -> Doc
clockFromDhms :: DayCount -> Hour -> Min -> Sec -> Clock
clockFromDhm :: DayCount -> Hour -> Min -> Clock
clockFromDh :: DayCount -> Hour -> Clock
clockFromD :: DayCount -> Clock
clockFromHms :: Hour -> Min -> Maybe Sec -> Clock

-- | Decompose second into day-count, hour, minute and second parts.
dhmsFromSec :: Sec -> (DayCount, Hour, Min, Sec)

-- | Aggregate hour, minute, and second into single second.
secFromHms :: (Hour, Min, Sec) -> Sec

-- | Sign of clock as <tt>-1</tt>, <tt>0</tt>, <tt>1</tt>.
clockSign :: Clock -> Int

-- | Day-count part of clock.
clockDayCount :: Clock -> DayCount

-- | Second part of clock.
clockSec :: Clock -> Sec
clockPrecision :: Clock -> String
clockDhms :: Clock -> (DayCount, Maybe Hour, Maybe Min, Maybe Sec)
clockAlter :: Maybe DayCount -> Maybe Hour -> Maybe Min -> Maybe Sec -> Map Clock

-- | Convert clock to positive clock.
clockPos :: Map Clock

-- | Convert clock to negative clock.
clockNeg :: Map Clock

-- | Set day-count to zero.
clockCutDay :: Map Clock

-- | Add day-count.
clockAddDay :: DayCount -> Map Clock

-- | Add second.
clockAddSec :: Sec -> Map Clock

-- | Calculation of clock plus clock.
clockAdd :: AbBin Clock

-- | Calculation of clock minus clock.
clockSub :: AbBin Clock
clockTimes :: Int -> Map Clock
clockRangeBy :: Map (DayCount, Sec) -> RangeBy Clock
clockStep :: Sec -> Map (DayCount, Sec)
instance Show Clock
instance Eq Clock
instance Ord Clock
instance Write Clock

module Koshucode.Baala.Data.Type.Time
data Time

-- | Date and time with time zone
TimeYmdcz :: Date -> Clock -> Sec -> Time

-- | Date and time
TimeYmdc :: Date -> Clock -> Time

-- | Year, month, and day
TimeYmd :: Date -> Time

-- | Year and week
TimeYw :: MJDay -> Time

-- | Year and month
TimeYm :: MJDay -> Time
timeYmd :: MJDay -> Time
timeYmdc :: MJDay -> Clock -> Time

-- | Create time data from year and month.
timeFromYmAb :: Year -> Month -> Ab Time

-- | Create time data from year and week.
timeFromYwAb :: Year -> Week -> Ab Time

-- | Create time data from date, clock, and time zone.
timeFromDczAb :: Date -> Clock -> Maybe Sec -> Ab Time

-- | Create time data form modified Julian date.
timeFromMjd :: DayCount -> Time
timeMjd :: Time -> DayCount
timeMapDate :: Map Date -> Map Time
timeMapMjd :: Map DayCount -> Map Time
timePrecision :: Time -> String
timeFloorMonth :: Map Time
timeFloorYear :: Map Time
timeCeilMonth :: Map Time
timeCeilYaer :: Map Time
timeRangeDay :: RangeBy Time
timeRangeMonth :: RangeBy Time
timeRangeYear :: RangeBy Time

-- | Add days to time.
timeAddDay :: DayCount -> Map Time

-- | Add weeks to time.
timeAddWeek :: Integer -> Map Time

-- | Add months to time.
timeAddMonth :: Integer -> Map Time

-- | Add years to time.
timeAddYear :: Year -> Map Time

-- | Add clock to time.
timeAddClock :: Clock -> AbMap Time

-- | Calculate clock from time to time.
timeDiff :: Time -> Time -> Ab Clock
instance Show Time
instance Eq Time
instance Ord Time
instance Write Time

module Koshucode.Baala.Data.Token.Term

-- | Name of term, e.g., <tt>"file"</tt> for the term name <tt>/file</tt>.
type TermName = String
type TermName2 = (String, String)
type TermName3 = (String, String, String)
type TermName4 = (String, String, String, String)
type TermName5 = (String, String, String, String, String)
type TermName6 = (String, String, String, String, String, String)

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]
showTermName :: TermName -> String
showTermPath :: TermPath -> String
type Term c = (TermName, c)
term :: TermName -> c -> Term c

-- | Check present term.
termP :: Int -> Bool

-- | Check new term.
termN :: Int -> Bool
termPN :: Int -> Int -> Bool
termsP :: [Int] -> Bool
termsN :: [Int] -> Bool
termsPN :: [Int] -> [Int] -> Bool


-- | Tokens in Koshucode.
module Koshucode.Baala.Data.Token.Token

-- | There are nine types of tokens.
data Token

-- | Text.
TText :: CodePt -> TextForm -> String -> Token

-- | Blank name.
TName :: CodePt -> BlankName -> Token

-- | Slot name. <a>Int</a> represents slot level, i.e., 0 for local
--   positional slots, 1 for local named slots, 2 for global slots.
TSlot :: CodePt -> Int -> String -> Token

-- | Prefixed shorten text.
TShort :: CodePt -> String -> String -> Token

-- | Term name.
TTermN :: CodePt -> TermName -> Token

-- | Term path.
TTerm :: CodePt -> TermType -> TermPath -> Token

-- | Local name.
TLocal :: CodePt -> (Local String) -> Int -> [Token] -> Token

-- | Opening bracket.
TOpen :: CodePt -> String -> Token

-- | Closing bracket.
TClose :: CodePt -> String -> Token

-- | <i>N</i> space characters.
TSpace :: CodePt -> Int -> Token

-- | Comment.
TComment :: CodePt -> String -> Token
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName
textToken :: String -> Token
nameToken :: String -> Token
data Local a
LocalSymbol :: a -> Local a
LocalNest :: a -> Local a
unlocal :: Local a -> a
data TextForm

-- | Unknown keyword
TextUnk :: TextForm

-- | Naked text
TextRaw :: TextForm

-- | Single-quoted text
TextQ :: TextForm

-- | Double-quoted text
TextQQ :: TextForm

-- | Keyword literal
TextKey :: TextForm

-- | Text enclosed in bars
TextBar :: TextForm

-- | Text used as name
TextName :: TextForm

-- | Text ins license section
TextLicense :: TextForm
data TermType

-- | Normal term path
TermTypePath :: TermType

-- | Quoted term name
TermTypeQuoted :: TermType

-- | Get the content of token.
tokenContent :: Token -> String
untoken :: Token -> String

-- | Text of token type, e.g., <tt>"text"</tt>, <tt>"open"</tt>.
tokenTypeText :: Token -> String
tokenSubtypeText :: Token -> Maybe String
tokenParents :: Token -> [Token]

-- | Test the token is blank, i.e., comment or space.
isBlankToken :: Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]
isShortToken :: Pred Token
isTermToken :: Pred Token
isOpenToken :: Pred Token
isCloseToken :: Pred Token

-- | Check token is a <a>TOpen</a> of the specific bracket.
isOpenTokenOf :: String -> Pred Token

-- | Check token is a <a>TClose</a> of the specific bracket.
isCloseTokenOf :: String -> Pred Token
instance Typeable Local
instance Typeable TextForm
instance Typeable TermType
instance Typeable BlankName
instance Typeable Token
instance Show a => Show (Local a)
instance Eq a => Eq (Local a)
instance Ord a => Ord (Local a)
instance Data a => Data (Local a)
instance Show TextForm
instance Eq TextForm
instance Ord TextForm
instance Data TextForm
instance Show TermType
instance Eq TermType
instance Ord TermType
instance Data TermType
instance Show BlankName
instance Eq BlankName
instance Ord BlankName
instance Data BlankName
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance Write BlankName
instance Name BlankName
instance CodePtr Token
instance Write Token
instance Name Token


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Data.Token.AngleText

-- | Convert string into double-quoted and angle-quoted form.
angleQuote :: Map String

-- | Table of coresspondences of angle text and its replacement.
angleTexts :: [(String, String)]

module Koshucode.Baala.Data.Token.Short

-- | Something with short definition.
data Short a
Short :: [CodePt] -> [ShortDef] -> a -> Short a
shortSource :: Short a -> [CodePt]
shortHead :: Short a -> [ShortDef]
shortBody :: Short a -> a

-- | Short prefix and replacement.
type ShortDef = Named String
shortTrim :: Map [Short [a]]
shortM :: Monad m => Short (m a) -> m (Short a)
shortListM :: Monad m => [Short (m a)] -> m [Short a]
shortGroup :: [Short a] -> [Short [a]]

-- | String shortener with no short definition.
shortEmpty :: StringMap

-- | String shortener.
shortText :: [ShortDef] -> StringMap
isCodeText :: Pred String
isCodeChar :: Pred Char
instance Show a => Show (Short a)
instance Ord a => Ord (Short a)
instance Eq a => Eq (Short a)
instance Functor Short


-- | Tokenizer of koshucode.
module Koshucode.Baala.Data.Token.TokenLine

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Tokenize text.
tokenLines :: CodePiece -> String -> Ab [TokenLine]

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: CodePiece -> String -> Ab [Token]
isShortPrefix :: Pred String

module Koshucode.Baala.Data.Token.TokenClause
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]
instance Write TokenClause


-- | Tree of tokens
module Koshucode.Baala.Data.Token.TokenTree

-- | Tree of tokens.
type TTree = CodeTree BracketType Token

-- | Pair of token tree and its name.
type NamedTree = Named TTree

-- | Pair of token trees and its name.
type NamedTrees = Named [TTree]

-- | Convert token tree to something.
type TTreeTo a = TTree -> a

-- | Convert list of token tree to sometning.
type TTreesTo a = [TTree] -> a

-- | Convert token tree to something, abortable.
type TTreeToAb a = TTree -> Ab a

-- | Convert list of token tree to sometning, abortable.
type TTreesToAb a = [TTree] -> Ab a

-- | Parse tokens with brackets into trees. Blank tokens and comments are
--   excluded.
ttrees :: [Token] -> Ab [TTree]

-- | Wrap trees in group.
ttreeGroup :: TTreesTo TTree

-- | There are six types of brackets
data BracketType

-- | Round brackets for grouping: <tt>( E ... )</tt>
BracketGroup :: BracketType

-- | Round-bar brackets for form with blanks: <tt>(| V ... | E ... |)</tt>
BracketForm :: BracketType

-- | Square brackets for lists: <tt>[ C : ... ]</tt>
BracketList :: BracketType

-- | Curely braces for sets: <tt>{ C : .... }</tt>
BracketSet :: BracketType

-- | Curely-bar braces for relations: <tt>{| /N : ... | C : ... | C : ...
--   |}</tt>
BracketRel :: BracketType

-- | Double-angle brackets for associations etc.: <tt>&lt;&lt; /N C ....
--   &gt;&gt;</tt>
BracketAssn :: BracketType

-- | Triple-angle brackets for data interpretation: <tt>&lt;&lt;&lt; ... /N
--   ... &gt;&gt;&gt;</tt>
BracketInterp :: BracketType

-- | Square-hyphen brackets for data type: <tt>[- ... -]</tt>
BracketType :: BracketType

-- | Unknown bracket
BracketUnknown :: BracketType

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "b c"
--   Left [ TText 1 0 "b", TSpace 2 1, TText 3 0 "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "a | b | c"
--   Right ( [ TText 1 0 "a", TSpace 2 1 ]
--           , TText 3 0 "|"
--           , [ TSpace 4 1, TText 5 0 "b", TSpace 6 1
--             , TText 7 0 "|", TSpace 8 1, TText 9 0 "c" ] )
--   </pre>
splitTokensBy :: Pred String -> [Token] -> Either [Token] ([Token], Token, [Token])

-- | Divide token trees by quoteless token of given string.
divideTreesBy :: String -> TTreesTo [[TTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
divideTreesByBar :: TTreesTo [[TTree]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: TTreesTo [[TTree]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: TTreesTo [[TTree]]

-- | Same as <tt>abortable</tt> except for using <a>TTree</a> instead of
--   list of <a>Token</a>.
abortableTree :: String -> TTreeTo (Map (Ab b))

-- | Same as <tt>abortable</tt> except for using list of <a>TTree</a>
--   instead of list of <a>Token</a>.
abortableTrees :: String -> TTreesTo (Map (Ab b))

-- | Convert text to token trees.
tt :: String -> Ab [TTree]
tt1 :: String -> Ab TTree

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: TTreesTo Doc
ttPrint :: String -> IO ()
instance Typeable BracketType
instance Show BracketType
instance Eq BracketType
instance Ord BracketType
instance Data BracketType


-- | Tokens in Koshucode.
module Koshucode.Baala.Data.Token

module Koshucode.Baala.Data.Type.Interp
data Interp
Interp :: [InterpWord] -> [TermName] -> Interp
interpWords :: Interp -> [InterpWord]
interpTerms :: Interp -> [TermName]
data InterpWord
InterpText :: String -> InterpWord
InterpTerm :: TermName -> InterpWord
interp :: [InterpWord] -> Interp
instance Show InterpWord
instance Eq InterpWord
instance Ord InterpWord
instance Show Interp
instance Eq Interp
instance Ord Interp
instance Write InterpWord
instance Write Interp


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Data.Type.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of pattern, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement pattern represents certain sentence pattern
--   that gives intepretation of data. Sentence pattern has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c

-- | <pre>
--   |-- P /x 10 /y 20
--   </pre>
JudgeAffirm :: JudgePat -> [Term c] -> Judge c

-- | <pre>
--   |-x P /x 10 /y 20
--   </pre>
JudgeDeny :: JudgePat -> [Term c] -> Judge c

-- | <pre>
--   |-xx P /x 10 /y 20
--   </pre>
JudgeMultiDeny :: JudgePat -> [Term c] -> Judge c

-- | <pre>
--   |-c P /x 10 +/y 20
--   </pre>
JudgeChange :: JudgePat -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-cc P /x 10 +/y 20
--   </pre>
JudgeMultiChange :: JudgePat -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-v P /x 10 /y 20
--   </pre>
JudgeViolate :: JudgePat -> [Term c] -> Judge c

-- | Name of judgement pattern, in other words, name of propositional
--   function.
type JudgePat = String

-- | Return pattern of judgement.
judgePat :: Judge c -> JudgePat

-- | Return term list of judgement.
judgeTerms :: Judge c -> [Term c]
judgeTermsMap :: ([Term a] -> [Term b]) -> Judge a -> Judge b

-- | Prepend a term into judgement.
judgeCons :: Term c -> Map (Judge c)

-- | Sort terms in alphabetical order.
sortJudgeTerms :: Ord c => Map (Judge c)

-- | Construct judgement from its pattern and terms.
type JudgeOf c = JudgePat -> [Term c] -> Judge c

-- | Construct affirmative judgement.
affirm :: JudgeOf c

-- | Construct denial judgement.
deny :: JudgeOf c

-- | Affirm judgement, i.e., change logical quality to affirmative.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to denial.
denyJudge :: Map (Judge c)

-- | Test which judgement is affirmed.
isAffirmative :: Judge c -> Bool

-- | Test which judgement is denied.
isDenial :: Judge c -> Bool

-- | Test which judgement is for violation.
isViolative :: Judge c -> Bool
writeDownJudge :: Write c => StringMap -> Judge c -> String
writeDownTerms :: Write c => StringMap -> [Term c] -> String
textualjudge :: Write c => StringMap -> Judge c -> Judge String
judgeText :: Judge String -> String
termText :: TermName -> String -> String
termsText :: [Term String] -> String
putJudge :: Write c => Judge c -> IO ()
hPutJudge :: Write c => Handle -> Judge c -> IO ()
instance Show c => Show (Judge c)
instance Functor Judge
instance Ord c => Ord (Judge c)
instance Ord c => Eq (Judge c)

module Koshucode.Baala.Data.Type.About
data About c
About :: [Term c] -> About c
type AboutJudges c = (Maybe (About c), [Judge c])
instance Show c => Show (About c)
instance Write c => Write (About c)

module Koshucode.Baala.Data.Type.Type

-- | Type for types.
data Type

-- | Everything
TypeAny :: Type

-- | Type of types
TypeType :: Type

-- | Term name
TypeTerm :: Type

-- | Data interpreation
TypeInterp :: Type

-- | Empty
TypeEmpty :: Type

-- | Boolean
TypeBool :: Type

-- | Text
TypeText :: Type

-- | Code
TypeCode :: Type

-- | Decimal
TypeDec :: Type

-- | Clock
TypeClock :: (Maybe String) -> Type

-- | Time
TypeTime :: (Maybe String) -> Type

-- | Binary data
TypeBin :: Type

-- | List
TypeList :: Type -> Type

-- | Set
TypeSet :: Type -> Type

-- | Tagged type
TypeTag :: String -> Type -> Type

-- | Association
TypeAssn :: [NamedType] -> Type

-- | Relation
TypeRel :: [NamedType] -> Type

-- | Tuple (Product type)
TypeTuple :: [Type] -> Type

-- | Sum type
TypeSum :: [Type] -> Type
type NamedType = Named Type

-- | Print type as tree.
typeExplain :: Type -> Doc
typeFlatRel :: [TermName] -> Type
typeConsRel :: TermName -> Map Type
typeConsNest :: TermName -> Type -> Map Type
typeAppendRel :: [TermName] -> Map Type
typeRelTermNames :: Type -> [TermName]
typeRelDegree :: Type -> Int

-- | Term index
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeConsNest "r" (typeFlatRel ["a", "b"]) (typeFlatRel [])) ["r", "b"]
--   [0, 1]
--   </pre>
typeRelIndex :: Type -> TermPath -> [Int]
typeRelIndexList :: Type -> [TermPath] -> [[Int]]
typeTermDoc :: Type -> Doc
typeTerms :: Type -> [NamedType]
isTypeRel :: Type -> Bool
typeRelMapTerms :: Map [NamedType] -> Map Type
typeRelMapTerm :: Map NamedType -> Map Type
typeRelMapName :: Map TermName -> Map Type
instance Show Type
instance Eq Type
instance Ord Type
instance Write Type


-- | Heading of relations
module Koshucode.Baala.Data.Type.Head

-- | Heading of relations.
data Head
Head :: Type -> Head
headType :: Head -> Type
headExplain :: Head -> Doc

-- | Make head of given type..
headOf :: Type -> Head

-- | Make head from term names.
headFrom :: [TermName] -> Head

-- | Empty heading, i.e., no terms in heading.
headEmpty :: Head
headEquiv :: Head -> Head -> Bool
isSubhead :: Head -> Head -> Bool
isSuperhead :: Head -> Head -> Bool

-- | List of term names.
headNames :: Head -> [TermName]

-- | Degree of relation, i.e., number of terms.
headDegree :: Head -> Int

-- | Select nested terms.
headNested :: Head -> [(TermName, Head)]

-- | Index of a term.
headIndex1 :: Head -> TermPath -> [Int]
headTypes :: Head -> [Type]

-- | Add term name to head.
headCons :: TermName -> Map Head

-- | Add term names to head.
headAppend :: [TermName] -> Map Head
headConsNest :: TermName -> Head -> Map Head
headNests :: [TermName] -> Map Head

-- | Reconstruct head.
headMap :: Map [NamedType] -> Map Head
headMapName :: Map TermName -> Map Head
headUp :: Map Head
headAlign :: Head -> Head -> Map [c]
bodyAlign :: Head -> Head -> Map [[c]]
data HeadLR c
HeadLR :: [Int] -> [Int] -> Bool -> [TermName] -> [TermName] -> [TermName] -> [TermName] -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> ([c], [c])) -> ([c] -> ([c], [c])) -> HeadLR c

-- | Indicies of right-shared part
headLShareIndex :: HeadLR c -> [Int]

-- | Indicies of left-shared part
headRShareIndex :: HeadLR c -> [Int]

-- | Whether shared part is empty
headDisjoint :: HeadLR c -> Bool

-- | Left-side term names
headLSideNames :: HeadLR c -> [TermName]

-- | Left-shared term names
headLShareNames :: HeadLR c -> [TermName]

-- | Right-shared term names
headRShareNames :: HeadLR c -> [TermName]

-- | Right-side term names
headRSideNames :: HeadLR c -> [TermName]

-- | Pick left-side part from left contents
headLSide :: HeadLR c -> [c] -> [c]

-- | Pick left-shared part from left contents
headLShare :: HeadLR c -> [c] -> [c]

-- | Pick right-shared part from right contents
headRShare :: HeadLR c -> [c] -> [c]

-- | Pick right-side part from right contents
headRSide :: HeadLR c -> [c] -> [c]
headRForward :: HeadLR c -> [c] -> [c]
headRBackward :: HeadLR c -> [c] -> [c]

-- | Pick right-shared and right-side part
headRSplit :: HeadLR c -> [c] -> ([c], [c])

-- | Pick right-shared part and right contents
headRAssoc :: HeadLR c -> [c] -> ([c], [c])
type HeadLRMap c = HeadLR c -> [c] -> [c]
type HeadLRMap2 a b = (HeadLRMap a, HeadLRMap b)
headLR :: [TermName] -> [TermName] -> HeadLR a
headLROrd :: [TermName] -> [TermName] -> HeadLR a
instance Show Head
instance Eq Head
instance Ord Head
instance Write Head
instance Monoid Head


-- | Relation type
module Koshucode.Baala.Data.Type.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Head -> Body c -> Rel c

-- | Heading of relation
relHead :: Rel c -> Head

-- | Body of relation
relBody :: Rel c -> Body c

-- | Body of relation, i.e., a list of tuples. Tuple is a list of contents.
type Body c = [[c]]
relSort :: Ord c => Map (Rel c)

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c
class SelectRel r
selectRel :: SelectRel r => r c -> JudgePat -> [TermName] -> Rel c

-- | Convert relation to list of judges.
judgesFromRel :: JudgeOf c -> JudgePat -> Rel c -> [Judge c]
instance Show c => Show (Rel c)
instance Write c => Write (Rel c)
instance Functor Rel
instance Ord c => Eq (Rel c)
instance Ord c => Ord (Rel c)


-- | Content type for nested relations.
module Koshucode.Baala.Data.Type.Mono

-- | Monotype relation.
data Mono c

-- | Terminal content
MonoTerm :: c -> Mono c

-- | Nested relation
MonoNest :: (RelMono c) -> Mono c
type RelMono c = Rel (Mono c)

-- | Text relation.
type RelText = RelMono String

-- | Test terminal content.
isMonoTerm :: Mono c -> Bool

-- | Test nested relation.
isMonoNest :: Mono c -> Bool

-- | Get terminal content.
gMonoTerm :: Mono c -> c

-- | Get nested relation.
gMonoNest :: Mono c -> RelMono c

-- | Put terminal content.
pMonoTerm :: c -> Mono c

-- | Put nested relation.
pMonoNest :: RelMono c -> Mono c
instance Show c => Show (Mono c)
instance Ord c => Eq (Mono c)
instance Ord c => Ord (Mono c)


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Data.Type

module Koshucode.Baala.Data.Message
abCoxBuild :: TTreeTo (Map (Ab b))
abCoxCalc :: CodePtr cp => [cp] -> Map (Ab b)
abCoxFill :: CodePtr cp => [cp] -> Map (Ab b)
abCoxIrrep :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPosition :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPrefix :: TTreeTo (Map (Ab b))
abCoxReduce :: CodePtr cp => [cp] -> Map (Ab b)
abCoxSyntax :: TTreeTo (Map (Ab b))
abLiteral :: TTreeTo (Map (Ab b))

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Int -> Int -> Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require tuple in list
reqRelTuple :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown object
unkShow :: Show x => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Head -> Ab a

-- | Unknown type name
unkType :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a
unmatchType :: String -> Ab a
detailTermRel :: String -> [String] -> Head -> [String]
expectActual :: String -> String -> [String]
expect2Actual :: String -> String -> String -> [String]


-- | Term-content expression.
module Koshucode.Baala.Data.Church.Cox

-- | Term-content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Content calculator
CoxCalc :: [CodePt] -> BlankName -> (CopCalc c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> CoxTag -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c
type Cox2 c = (Cox c, Cox c)
type Cox3 c = (Cox c, Cox c, Cox c)
type Cox4 c = (Cox c, Cox c, Cox c, Cox c)
type MaybeCox c = Maybe (Cox c)
type NamedCox c = Named (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c
type CoxTag = Maybe String
coxLit :: c -> Cox c
coxSyntacticArity :: Cox c -> Int
coxMap :: Map (Map (Cox c))
coxCall :: Cox c -> (Map (Cox c)) -> Cox c
checkIrreducible :: AbMap (Cox c)
instance Write c => Write (Cox c)
instance Write c => Show (Cox c)
instance CodePtr (Cox c)


-- | Term-content operator.
module Koshucode.Baala.Data.Church.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TTree] -> Ab TTree
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
copsetCopList :: CopSet c -> [Cop c]
copsetInfixList :: CopSet c -> [Named InfixHeight]
copsetCalcList :: CopSet c -> [Named (Cop c)]
copsetCoxList :: CopSet c -> [Named (Cop c)]
copsetTreeList :: CopSet c -> [Named (Cop c)]
copsetFindCalc :: CopSet c -> CopFind (Cox c)
copsetFindCox :: CopSet c -> CopFind (CopCox c)
copsetFindTree :: CopSet c -> CopFind CopTree
copsetDerived :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Empty operator set.
copset :: CopSet c
copsetFill :: Map (CopSet c)
instance Name (Cop c)
instance Show (Cop c)

module Koshucode.Baala.Data.Content.Class
class (Ord c, Write c, CTypeOf c, CEmpty c, CBool c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CAssn c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
class (Show c, Write c) => CTypeOf c
typeOf :: CTypeOf c => c -> Type
class CTypeOf c => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: CBool c => c
false :: CBool c => c
putTrue :: CBool c => Ab c
putFalse :: CBool c => Ab c
class CTypeOf c => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pMaybeText :: (CText c, CEmpty c) => String -> c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
class CTypeOf c => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Types that can be empty
class CTypeOf c => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c
maybeEmpty :: CEmpty c => (a -> c) -> Maybe a -> c
omitEmpty :: CEmpty c => Map [(a, c)]
class CTypeOf c => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pInt :: CDec c => Int -> c
pInteger :: CDec c => Integer -> c
pDecFromInt :: CDec c => Int -> c
pDecFromInteger :: CDec c => Integer -> c
class CTypeOf c => CClock c where getClock = getAbAb isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => Ab c -> Ab Clock
putClock :: CClock c => Clock -> Ab c
class CTypeOf c => CTime c where getTime = getAbAb isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => Ab c -> Ab Time
putTime :: CTime c => Time -> Ab c
class CTypeOf c => CTerm c where getTerm = getAbAb isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c
pTermSet :: (CTerm c, CSet c) => [String] -> c
class CTypeOf c => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
gSetSort :: (Ord c, CSet c) => c -> [c]
class CTypeOf c => CAssn c where getAssn = getAbAb isAssn gAssn putAssn = Right . pAssn
isAssn :: CAssn c => c -> Bool
gAssn :: CAssn c => c -> [Term c]
pAssn :: CAssn c => [Term c] -> c
getAssn :: CAssn c => Ab c -> Ab [Term c]
putAssn :: CAssn c => [Term c] -> Ab c
class CTypeOf c => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool
dee :: CRel c => c
dum :: CRel c => c
class CTypeOf c => CInterp c where getInterp = getAbAb isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => Ab c -> Ab Interp
putInterp :: CInterp c => Interp -> Ab c
class CTypeOf c => CType c where getType = getAbAb isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => Ab c -> Ab Type
putType :: CType c => Type -> Ab c
contAp :: (c -> a) -> (b -> d) -> (a -> b) -> c -> d
contMap :: (c -> [a]) -> ([b] -> d) -> (a -> b) -> c -> d
contApTextToText :: CText c => Map String -> AbMap c
contMapTextToList :: (CList c, CText c) => (Char -> c) -> AbMap c
type CGetPut a c = (c -> a, a -> c)
gpText :: CText c => CGetPut [Char] c
gpList :: CList c => CGetPut [c] c
gpSet :: CSet c => CGetPut [c] c
gpSetSort :: (Ord c, CSet c) => CGetPut [c] c


-- | Utilities for token trees.
module Koshucode.Baala.Data.Content.Tree
treesToTokens :: TTreesToAb [Token]
treesToTexts :: Bool -> TTreesToAb [String]
treeToText :: Bool -> TTreeToAb String
treesToDigits :: TTreesToAb String
tokenClock :: Token -> Ab Clock
treesToTime :: TTreesToAb Time

-- | Get flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
treeToFlatTerm :: TTreeToAb TermName

-- | Convert token trees into a list of named token trees.
treesToTerms :: TTreesToAb [NamedTrees]
treesToTerms1 :: TTreesToAb [NamedTree]
treesToInterp :: TTreesToAb Interp


-- | Make literal contents from token tree.
module Koshucode.Baala.Data.Content.Literal

-- | Content constructor.
type ContentCons c = TTreeToAb c

-- | Content calculator.
type ContentCalc c = TTreeToAb c

-- | Convert token tree into internal form of content.
contentCons :: CContent c => ContentCalc c -> ContentCons c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of resources.
treesToJudge :: CContent c => ContentCalc c -> AssertType -> JudgePat -> TTreesToAb (Judge c)
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=x</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=xx</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertMultiDeny :: AssertType

-- | <tt>|=c</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertChange :: AssertType

-- | <tt>|=cc</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertMultiChange :: AssertType

-- | <tt>|=v</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertAs :: AssertType -> JudgeOf c
assertSymbol :: AssertType -> String
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType


-- | Content of term in judgement.
module Koshucode.Baala.Data.Content


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Build

-- | Construct content expression from token tree
coxBuild :: CContent c => ContentCalc c -> CopSet c -> TTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Run
type RunCox c = Cox c -> Ab c
type RunList c = [c] -> Ab c
coxRunCox :: (Write c, CRel c, CList c) => CopSet c -> Head -> [c] -> RunCox c
coxRunList :: (Write c, CRel c, CList c) => CopSet c -> Head -> Cox c -> RunList c
calcContent :: CContent c => CopSet c -> ContentCalc c
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)
getRightArg1 :: [Ab c] -> Ab c
getRightArg2 :: [Ab c] -> Ab (c, c)
getRightArg3 :: [Ab c] -> Ab (c, c, c)
instance CodePtr (Beta c)

module Koshucode.Baala.Data.Church

module Koshucode.Baala.Data
