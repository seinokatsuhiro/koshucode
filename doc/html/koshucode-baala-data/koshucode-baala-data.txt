-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-data
@version 0.133.0.0

module Koshucode.Baala.Data.Type.Time.Clock
data Clock

-- | Clock represented by multiple of second
ClockDhms :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of minute
ClockDhm :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of hour
ClockDh :: DayCount -> Sec -> Clock

-- | Clock represented by multiple of day
ClockD :: DayCount -> Clock
type DayCount = Integer
type Hour = Int
type Min = Int
type Sec = Int

-- | Type for abortable binary operator.
type AbBin a = a -> a -> Ab a
writeClock :: Clock -> Doc
writeClockBody :: Clock -> Doc
clockFromDhms :: DayCount -> Hour -> Min -> Sec -> Clock
clockFromDhm :: DayCount -> Hour -> Min -> Clock
clockFromDh :: DayCount -> Hour -> Clock
clockFromD :: DayCount -> Clock
clockFromHms :: Hour -> Min -> Maybe Sec -> Clock

-- | Decompose second into day-count, hour, minute and second parts.
dhmsFromSec :: Sec -> (DayCount, Hour, Min, Sec)

-- | Aggregate hour, minute, and second into single second.
secFromHms :: (Hour, Min, Sec) -> Sec

-- | Sign of clock as <tt>-1</tt>, <tt>0</tt>, <tt>1</tt>.
clockSign :: Clock -> Int

-- | Day-count part of clock.
clockDayCount :: Clock -> DayCount

-- | Second part of clock.
clockSec :: Clock -> Sec
clockPrecision :: Clock -> String
clockDhms :: Clock -> (DayCount, Maybe Hour, Maybe Min, Maybe Sec)
clockAlter :: Maybe DayCount -> Maybe Hour -> Maybe Min -> Maybe Sec -> Map Clock

-- | Convert clock to positive clock.
clockPos :: Map Clock

-- | Convert clock to negative clock.
clockNeg :: Map Clock

-- | Set day-count to zero.
clockCutDay :: Map Clock

-- | Add day-count.
clockAddDay :: DayCount -> Map Clock

-- | Add second.
clockAddSec :: Sec -> Map Clock

-- | Calculation of clock plus clock.
clockAdd :: AbBin Clock

-- | Calculation of clock minus clock.
clockSub :: AbBin Clock
clockTimes :: Int -> Map Clock
clockRangeBy :: Map (DayCount, Sec) -> RangeBy Clock
clockStep :: Sec -> Map (DayCount, Sec)
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Clock.Clock
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Clock.Clock
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Clock.Clock
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Time.Clock.Clock


-- | Extra functions for rational numbers.
module Koshucode.Baala.Data.Type.Decimal.Rational

-- | <a>Rational</a> version of <a>%</a>.
(%%) :: Integer -> Integer -> Rational

-- | Integer part and proper fraction part of ratio of two numbers, i.e.,
--   <i>x</i> <a>//.</a> <i>y</i> == (<i>integer</i>,
--   <i>proper-fraction</i>) of <i>x</i> <a>%</a> <i>y</i>.
(//.) :: (Integral n) => n -> n -> (n, Ratio n)

-- | Synonym of <a>quotRem</a>.
(//) :: (Integral n) => n -> n -> (n, n)

-- | 1 <a>%</a> 2
ratioHalf :: (Integral n) => Ratio n

-- | Unit rational number for decimal fractional length.
ratioFracl :: (Integral i, Integral n) => i -> Ratio n

-- | Round rational number at decimal fractional length.
ratioRoundAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round-to-even rational number at decimal fractional length.
ratioRoundEvenAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round rational number per unit rational number.
ratioRoundPer :: (Integral n) => Bin (Ratio n)

-- | Round-to-even rational number per unit rational number.
ratioRoundEvenPer :: (Integral n) => Bin (Ratio n)

-- | Truncate rational number at decimal fractional length.
ratioTruncAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Truncate rational number per unit rational number.
ratioTruncPer :: (Integral n) => Bin (Ratio n)

-- | Round out (toward infinity) rational number at decimal fractional
--   length.
ratioRoundOutAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Round out (toward infinity) rational number per unit rational number.
ratioRoundOutPer :: (Integral n) => Bin (Ratio n)

-- | Floor rational number at decimal fractional length.
ratioFloorAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Floor rational number per unit rational number.
ratioFloorPer :: (Integral n) => Bin (Ratio n)

-- | Ceiling rational number at decimal fractional length.
ratioCeilAt :: (Integral l, Integral n) => l -> Map (Ratio n)

-- | Ceiling rational number per unit rational number.
ratioCeilPer :: (Integral n) => Bin (Ratio n)
ratioQuo :: (Integral n) => Bin (Ratio n)
ratioRem :: (Integral n) => Bin (Ratio n)
ratioQuoRem :: (Integral n) => Ratio n -> Ratio n -> (Ratio n, Ratio n)


-- | Decimal number.
--   
--   A decimal number in Koshucode is internally represented using a
--   rational number (<a>decimalRatio</a>) with a length of fractional part
--   (<a>decimalFracl</a>) . For example, the decimal number 11.250
--   correnponds to the rational number 45/4 with the fraction length 3.
--   
--   <ul>
--   <li><i>Decimal number</i> Number represented using 10 digits and the
--   decimal separator.</li>
--   <li><i>Decimal separator</i> Symbol between integer part and
--   fractional part.</li>
--   <li><i>Fractional part</i> The right part of decimal numbers, e.g.,
--   250 for 11.250.</li>
--   <li><i>Integer part</i> The left part of decimal numbers, e.g., 11 for
--   11.250.</li>
--   <li><i>Integral decimal</i> Decimal number without fractional
--   part.</li>
--   </ul>
module Koshucode.Baala.Data.Type.Decimal.Decimal

-- | Type for numerator or denominator for decimal numbers.
type DecimalInteger = Integer

-- | Rational number of decimal type.
type DecimalRatio = Ratio DecimalInteger

-- | Length of fractional part.
type DecimalFracl = Int

-- | Decimal number.
data Decimal
Decimal :: DecimalFracl -> DecimalRatio -> Decimal

-- | Length of the fractional part
[decimalFracl] :: Decimal -> DecimalFracl

-- | Rational number for the decimal number
[decimalRatio] :: Decimal -> DecimalRatio

-- | Change decimal fracl.
decimalFraclSet :: DecimalFracl -> AbMap Decimal

-- | Map function to rational number in decimal.
decimalRatioMap :: Map DecimalRatio -> Map Decimal

-- | Binary operation for two decimals.
type BinDecimal = Bin Decimal

-- | Abortable binary operation for two decimals.
type BinAbDecimal = BinAb Decimal

-- | Combinate fracl.
type BinFracl = Bin DecimalFracl

-- | Combinate rational number.
type BinRatio = Bin DecimalRatio

-- | Binary operation for two decimals.
decimalBin :: BinFracl -> BinRatio -> BinDecimal

-- | Abortable binary operation for two decimals.
decimalBinAb :: BinFracl -> BinRatio -> BinAbDecimal

-- | Convert integral number to integral decimal number.
integralDecimal :: (Integral n) => n -> Decimal

-- | Convert real number to decimal number.
realDecimal :: (Real n) => DecimalFracl -> n -> Decimal

-- | Convert decimal number to fractional number.
decimalFractional :: (Fractional n) => Decimal -> n
instance GHC.Show.Show Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Enum.Enum Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Num.Num Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.Real Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.Fractional Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal
instance GHC.Real.RealFrac Koshucode.Baala.Data.Type.Decimal.Decimal.Decimal


-- | Decimal functions.
module Koshucode.Baala.Data.Type.Decimal.Fraction

-- | Integer part of decimals.
decimalIntPart :: Map Decimal

-- | Fractional part of decimals.
decimalFracPart :: Map Decimal
decimalIntFrac :: Decimal -> (Decimal, Decimal)

-- | Numerator part of decimal number.
decimalNum :: Decimal -> DecimalInteger

-- | Denominator part of decimal number.
decimalDenom :: Decimal -> DecimalInteger

-- | Round decimal per self fractional length.
decimalRound :: Map Decimal

-- | Round decimal per fractional length.
decimalRoundAt :: Bin Decimal

-- | Round decimal per unit decimal.
decimalRoundPer :: Bin Decimal

-- | Round decimal to even per self fractional length.
decimalRoundEven :: Map Decimal

-- | Round decimal to even per fractional length.
decimalRoundEvenAt :: Bin Decimal

-- | Round decimal to even per unit decimal.
decimalRoundEvenPer :: Bin Decimal

-- | Truncate decimal per self fractional length.
decimalTrunc :: Map Decimal

-- | Truncate decimal per fractional length.
decimalTruncAt :: Bin Decimal

-- | Truncate decimal per unit decimal.
decimalTruncPer :: Bin Decimal

-- | Truncation error of decimal.
decimalTruncError :: Map Decimal

-- | Round out (toward infinity) decimal to even per self fractional
--   length.
decimalRoundOut :: Map Decimal

-- | Round out (toward infinity) decimal to even per fractional length.
decimalRoundOutAt :: Bin Decimal

-- | Round out (toward infinity) decimal to even per unit decimal.
decimalRoundOutPer :: Bin Decimal

-- | Floor decimal per self fractional length.
decimalFloor :: Map Decimal

-- | Floor decimal per fractional length.
decimalFloorAt :: Bin Decimal

-- | Floor decimal per unit decimal.
decimalFloorPer :: Bin Decimal

-- | Ceiling decimal per self fractional length.
decimalCeil :: Map Decimal

-- | Ceiling decimal per fractional length.
decimalCeilAt :: Bin Decimal

-- | Ceiling decimal per unit decimal.
decimalCeilPer :: Bin Decimal

-- | <tt>chopDigitsTrancate</tt> <i>d</i> <i>n</i> returns a number which
--   does not have the tailing <i>d</i> digits. If <i>d</i> is zero or
--   negative, it returns just <i>n</i>.
chopDigitsTrancate :: (Integral d, Integral n) => d -> n -> n

-- | <tt>chopDigitsRound</tt> is similar to <a>chopDigitsTrancate</a>, but
--   rounds chopped digit.
chopDigitsRound :: (Integral d, Integral n) => d -> n -> n

-- | Round the last (least significant) digit.
roundLastDigit :: (Integral n) => n -> n

module Koshucode.Baala.Data.Type.Type

-- | Type for types.
data Type

-- | Everything
TypeAny :: Type

-- | Type of types
TypeType :: Type

-- | Term name
TypeTerm :: Type

-- | Data interpreation
TypeInterp :: Type

-- | Empty
TypeEmpty :: Type

-- | Full
TypeFull :: Type

-- | Boolean
TypeBool :: Type

-- | Text
TypeText :: Type

-- | Code
TypeCode :: Type

-- | Decimal
TypeDec :: Type

-- | Clock
TypeClock :: (Maybe String) -> Type

-- | Time
TypeTime :: (Maybe String) -> Type

-- | Binary data
TypeBin :: Type

-- | List
TypeList :: Type -> Type

-- | Set
TypeSet :: Type -> Type

-- | Tagged type
TypeTag :: String -> Type -> Type

-- | Tie
TypeTie :: [NamedType] -> Type

-- | Relation
TypeRel :: [NamedType] -> Type

-- | Tuple (Product type)
TypeTuple :: [Type] -> Type

-- | Sum type
TypeSum :: [Type] -> Type
type NamedType = Named Type

-- | Print type as tree.
typeExplain :: Type -> Doc
typeFlatRel :: [TermName] -> Type
typeConsRel :: TermName -> Map Type
typeConsNest :: TermName -> Type -> Map Type
typeAppendRel :: [TermName] -> Map Type
typeRelTermNames :: Type -> [TermName]
typeRelDegree :: Type -> Int

-- | Term index
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeFlatRel ["a", "b", "c"]) ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeRelIndex (typeConsNest "r" (typeFlatRel ["a", "b"]) (typeFlatRel [])) ["r", "b"]
--   [0, 1]
--   </pre>
typeRelIndex :: Type -> TermPath -> [Int]
typeRelIndexList :: Type -> [TermPath] -> [[Int]]
typeTermDoc :: Type -> Doc
typeTerms :: Type -> [NamedType]
isTypeRel :: Type -> Bool
typeRelMapTerms :: Map [NamedType] -> Map Type
typeRelMapTerm :: Map NamedType -> Map Type
typeRelMapName :: Map TermName -> Map Type
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Type.Type
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Type.Type
instance GHC.Show.Show Koshucode.Baala.Data.Type.Type.Type
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Type.Type


-- | Heading of relations
module Koshucode.Baala.Data.Type.Rel.Head

-- | Heading of relations.
data Head
Head :: Type -> Head
[headType] :: Head -> Type
headExplain :: Head -> Doc

-- | Make head of given type..
headOf :: Type -> Head

-- | Make head from term names.
headFrom :: [TermName] -> Head

-- | Empty heading, i.e., no terms in heading.
headEmpty :: Head
headEquiv :: Head -> Head -> Bool
isSubhead :: Head -> Head -> Bool
isSuperhead :: Head -> Head -> Bool

-- | List of term names.
headNames :: Head -> [TermName]

-- | Degree of relation, i.e., number of terms.
headDegree :: Head -> Int

-- | Select nested terms.
headNested :: Head -> [(TermName, Head)]

-- | Index of a term.
headIndex1 :: Head -> TermPath -> [Int]
headTypes :: Head -> [Type]

-- | Add term name to head.
headCons :: TermName -> Map Head

-- | Add term names to head.
headAppend :: [TermName] -> Map Head
headConsNest :: TermName -> Head -> Map Head
headNests :: [TermName] -> Map Head

-- | Reconstruct head.
headMap :: Map [NamedType] -> Map Head
headMapName :: Map TermName -> Map Head
headUp :: Map Head
headAlign :: Head -> Head -> Map [c]
bodyAlign :: Head -> Head -> Map [[c]]
data HeadLR c
HeadLR :: [Int] -> [Int] -> Bool -> [TermName] -> [TermName] -> [TermName] -> [TermName] -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> [c]) -> ([c] -> ([c], [c])) -> ([c] -> ([c], [c])) -> HeadLR c

-- | Indicies of right-shared part
[headLShareIndex] :: HeadLR c -> [Int]

-- | Indicies of left-shared part
[headRShareIndex] :: HeadLR c -> [Int]

-- | Whether shared part is empty
[headDisjoint] :: HeadLR c -> Bool

-- | Left-side term names
[headLSideNames] :: HeadLR c -> [TermName]

-- | Left-shared term names
[headLShareNames] :: HeadLR c -> [TermName]

-- | Right-shared term names
[headRShareNames] :: HeadLR c -> [TermName]

-- | Right-side term names
[headRSideNames] :: HeadLR c -> [TermName]

-- | Pick left-side part from left contents
[headLSide] :: HeadLR c -> [c] -> [c]

-- | Pick left-shared part from left contents
[headLShare] :: HeadLR c -> [c] -> [c]

-- | Pick right-shared part from right contents
[headRShare] :: HeadLR c -> [c] -> [c]

-- | Pick right-side part from right contents
[headRSide] :: HeadLR c -> [c] -> [c]
[headRForward] :: HeadLR c -> [c] -> [c]
[headRBackward] :: HeadLR c -> [c] -> [c]

-- | Pick right-shared and right-side part
[headRSplit] :: HeadLR c -> [c] -> ([c], [c])

-- | Pick right-shared part and right contents
[headRAssoc] :: HeadLR c -> [c] -> ([c], [c])
type HeadLRMap c = HeadLR c -> [c] -> [c]
type HeadLRMap2 a b = (HeadLRMap a, HeadLRMap b)
headLR :: [TermName] -> [TermName] -> HeadLR a
headLROrd :: [TermName] -> [TermName] -> HeadLR a
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Show.Show Koshucode.Baala.Data.Type.Rel.Head.Head
instance GHC.Base.Monoid Koshucode.Baala.Data.Type.Rel.Head.Head
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Rel.Head.Head


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Data.Type.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of pattern, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement pattern represents certain sentence pattern
--   that gives intepretation of data. Sentence pattern has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c

-- | <pre>
--   |-- P /x 10 /y 20
--   </pre>
JudgeAffirm :: JudgePat -> [Term c] -> Judge c

-- | <pre>
--   |-x P /x 10 /y 20
--   </pre>
JudgeDeny :: JudgePat -> [Term c] -> Judge c

-- | <pre>
--   |-xx P /x 10 /y 20
--   </pre>
JudgeMultiDeny :: JudgePat -> [Term c] -> Judge c

-- | <pre>
--   |-c P /x 10 +/y 20
--   </pre>
JudgeChange :: JudgePat -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-cc P /x 10 +/y 20
--   </pre>
JudgeMultiChange :: JudgePat -> [Term c] -> [Term c] -> Judge c

-- | <pre>
--   |-v P /x 10 /y 20
--   </pre>
JudgeViolate :: JudgePat -> [Term c] -> Judge c

-- | Name of judgement pattern, in other words, name of propositional
--   function.
type JudgePat = String

-- | Return pattern of judgement.
judgePat :: Judge c -> JudgePat

-- | Return term list of judgement.
judgeTerms :: Judge c -> [Term c]
judgeTermsMap :: ([Term a] -> [Term b]) -> Judge a -> Judge b

-- | Prepend a term into judgement.
judgeCons :: Term c -> Map (Judge c)

-- | Sort terms in alphabetical order.
sortJudgeTerms :: (Ord c) => Map (Judge c)

-- | Construct judgement from its pattern and terms.
type JudgeOf c = JudgePat -> [Term c] -> Judge c

-- | Construct affirmative judgement.
affirm :: JudgeOf c

-- | Construct denial judgement.
deny :: JudgeOf c

-- | Affirm judgement, i.e., change logical quality to affirmative.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to denial.
denyJudge :: Map (Judge c)

-- | Test which judgement is affirmed.
isAffirmative :: Judge c -> Bool

-- | Test which judgement is denied.
isDenial :: Judge c -> Bool

-- | Test which judgement is for violation.
isViolative :: Judge c -> Bool
writeDownJudge :: (Write c) => Shortener -> Judge c -> String
writeDownTerms :: (Write c) => Shortener -> [Term c] -> String
textualjudge :: (Write c) => Shortener -> Judge c -> Judge String
judgeText :: Judge String -> String
termText :: TermName -> String -> String
termsText :: [Term String] -> String
putJudge :: (Write c) => Judge c -> IO ()
hPutJudge :: (Write c) => Handle -> Judge c -> IO ()
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Judge.Judge c)
instance GHC.Base.Functor Koshucode.Baala.Data.Type.Judge.Judge


-- | Relation type
module Koshucode.Baala.Data.Type.Rel.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Head -> Body c -> Rel c

-- | Heading of relation
[relHead] :: Rel c -> Head

-- | Body of relation
[relBody] :: Rel c -> Body c

-- | Body of relation, i.e., a list of tuples. Tuple is a list of contents.
type Body c = [[c]]
relSort :: (Ord c) => Map (Rel c)
relBodyOrder :: (Ord c) => [SignedTermName] -> Head -> Map [[c]]

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c
class SelectRel r

-- | Convert judges to relation.
selectRel :: SelectRel r => r c -> JudgePat -> [TermName] -> Rel c

-- | Convert relation to list of judges.
judgesFromRel :: JudgeOf c -> JudgePat -> Rel c -> [Judge c]
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)
instance GHC.Base.Functor Koshucode.Baala.Data.Type.Rel.Rel.Rel
instance Koshucode.Baala.Base.Text.Write.Write c => Koshucode.Baala.Base.Text.Write.Write (Koshucode.Baala.Data.Type.Rel.Rel.Rel c)


-- | Content type for nested relations.
module Koshucode.Baala.Data.Type.Rel.Mono

-- | Monotype relation.
data Mono c

-- | Terminal content
MonoTerm :: c -> Mono c

-- | Nested relation
MonoNest :: (RelMono c) -> Mono c
type RelMono c = Rel (Mono c)

-- | Text relation.
type RelText = RelMono String

-- | Test terminal content.
isMonoTerm :: Mono c -> Bool

-- | Test nested relation.
isMonoNest :: Mono c -> Bool

-- | Get terminal content.
gMonoTerm :: Mono c -> c

-- | Get nested relation.
gMonoNest :: Mono c -> RelMono c

-- | Put terminal content.
pMonoTerm :: c -> Mono c

-- | Put nested relation.
pMonoNest :: RelMono c -> Mono c
instance GHC.Classes.Ord c => GHC.Classes.Ord (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)
instance GHC.Classes.Ord c => GHC.Classes.Eq (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)
instance GHC.Show.Show c => GHC.Show.Show (Koshucode.Baala.Data.Type.Rel.Mono.Mono c)

module Koshucode.Baala.Data.Type.Rel

module Koshucode.Baala.Data.Type.Interp
data Interp
Interp :: [InterpWord] -> [TermName] -> Interp
[interpWords] :: Interp -> [InterpWord]
[interpTerms] :: Interp -> [TermName]
data InterpWord
InterpText :: String -> InterpWord
InterpTerm :: TermName -> InterpWord
interp :: [InterpWord] -> Interp
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Show.Show Koshucode.Baala.Data.Type.Interp.Interp
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Interp.InterpWord
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Interp.InterpWord
instance GHC.Show.Show Koshucode.Baala.Data.Type.Interp.InterpWord
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Interp.Interp
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Interp.InterpWord

module Koshucode.Baala.Data.Type.Message

-- | Divide by zero
divideByZero :: Ab a

-- | Different decimal length
heteroDecimal :: String -> String -> Ab a

-- | Can't read as date
notDate :: Integer -> Int -> Int -> Ab a

-- | Too large digit
tooLargeDigit :: String -> Ab a

-- | Can't read as number
notNumber :: String -> Ab a


-- | Decode and encode of decimals.
--   
--   <ul>
--   <li><i>Decimal</i> Head Int Frac ? Tail</li>
--   <li><i>Head</i> Sign ...</li>
--   <li><i>Int</i> Digit ...</li>
--   <li><i>Frac</i> Separator Digit ...</li>
--   <li><i>Tail</i> Sign ...</li>
--   <li><i>Sign</i> Space | <tt>"-"</tt> | <tt>"+"</tt></li>
--   <li><i>Digit</i> Space | <tt>"0"</tt> | ... | <tt>"9"</tt> |
--   <tt>"a"</tt> | ... | <tt>"z"</tt> | <tt>"A"</tt> | ... |
--   <tt>"Z"</tt></li>
--   <li><i>Separator</i> <tt>"."</tt></li>
--   <li><i>Space</i> <tt>" "</tt></li>
--   </ul>
module Koshucode.Baala.Data.Type.Decimal.Coder

-- | Decode to <tt>a</tt>.
type DecodeAb a = String -> Ab a

-- | Decode base-2 digits to decimal.
decodeBinary :: DecodeAb Decimal

-- | Decode base-8 digits to decimal.
decodeOctal :: DecodeAb Decimal

-- | Decode decimals.
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11"
--   Right (Decimal { ratio = 11 % 1, fracl = 0 })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "-12 345.00"
--   Right (Decimal { ratio = -12345 % 1, fracl = 2 })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeDecimal "11.250 +"
--   Right (Decimal { ratio = 45 % 4, fracl = 3 })
--   </pre>
decodeDecimal :: DecodeAb Decimal

-- | Decode base-16 digits to decimal.
decodeHex :: DecodeAb Decimal

-- | Decode digits to number.
decodeBase :: Integer -> DecodeAb Decimal

-- | Encode decimals.
encodeDecimal :: Decimal -> String

-- | Encode decimals without spaces.
encodeDecimalCompact :: Decimal -> String


-- | Arithmetics on decimals.
module Koshucode.Baala.Data.Type.Decimal.BinaryAb
data FraclSide

-- | Select longer fracl
FraclLong :: FraclSide

-- | Select left fracl
FraclLeft :: FraclSide

-- | Select right fracl
FraclRight :: FraclSide

-- | Check same fracls
FraclStrict :: FraclSide

-- | Addition: <i>x</i> + <i>y</i>
decimalAdd :: FraclSide -> BinAbDecimal

-- | Add all decimals.
decimalSum :: [Decimal] -> Ab Decimal

-- | Subtruction: <i>x</i> - <i>y</i>
decimalSub :: FraclSide -> BinAbDecimal

-- | Multiplication: <i>x</i> × <i>y</i>
decimalMul :: BinAbDecimal

-- | Division: <i>x</i> ÷ <i>y</i>
decimalDiv :: BinAbDecimal

-- | Quotient: integral part of <i>x</i> ÷ <i>y</i>
decimalQuo :: BinAbDecimal

-- | Remainder: <i>y</i> × fractional part of <i>x</i> ÷ <i>y</i>
decimalRem :: BinAbDecimal
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Decimal.BinaryAb.FraclSide
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Decimal.BinaryAb.FraclSide
instance GHC.Show.Show Koshucode.Baala.Data.Type.Decimal.BinaryAb.FraclSide

module Koshucode.Baala.Data.Type.Decimal

module Koshucode.Baala.Data.Type.Time.Date
data Date

-- | Date in <i>YYYY-MM-DD</i>
Monthly :: MJDay -> Date

-- | Date in <i>YYYY-#W-D</i>
Weekly :: MJDay -> Date

-- | Date in <i>YYYY-##D</i>
Yearly :: MJDay -> Date
type MJDay = Day  The Modified Julian Day
type YmdTuple = (Year, Month, Day)
type Year = Integer
type Month = Int
type Week = Int
type Day = Int

-- | Create date from year, month, and day.
dateFromYmdAb :: Year -> Month -> Day -> Ab Date

-- | Create date from year, week, and day.
dateFromYwdAb :: Year -> Week -> Day -> Ab Date

-- | Create date from year and day.
dateFromYdAb :: Year -> Day -> Ab Date

-- | Get the internal Modified Julian Day.
dateDay :: Date -> MJDay
dateMapDay :: Map MJDay -> Map Date

-- | Convert into monthly date.
dateAdd :: (Integral n) => n -> Map Date

-- | Convert into weekly date.
monthly :: Map Date

-- | Convert into yearly date.
weekly :: Map Date
yearly :: Map Date
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Date.Date
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Date.Date
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Date.Date
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Time.Date.Date

module Koshucode.Baala.Data.Type.Time.Time
data Time

-- | Date and time with time zone
TimeYmdcz :: Date -> Clock -> Sec -> Time

-- | Date and time
TimeYmdc :: Date -> Clock -> Time

-- | Year, month, and day
TimeYmd :: Date -> Time

-- | Year and week
TimeYw :: MJDay -> Time

-- | Year and month
TimeYm :: MJDay -> Time
timeYmd :: MJDay -> Time
timeYmdc :: MJDay -> Clock -> Time

-- | Create time data from year and month.
timeFromYmAb :: Year -> Month -> Ab Time

-- | Create time data from year and week.
timeFromYwAb :: Year -> Week -> Ab Time

-- | Create time data from date, clock, and time zone.
timeFromDczAb :: Date -> Clock -> Maybe Sec -> Ab Time

-- | Create time data form modified Julian date.
timeFromMjd :: DayCount -> Time
timeMjd :: Time -> DayCount
timeMapDate :: Map Date -> Map Time
timeMapMjd :: Map DayCount -> Map Time
timePrecision :: Time -> String
timeFloorMonth :: Map Time
timeFloorYear :: Map Time
timeCeilMonth :: Map Time
timeCeilYaer :: Map Time
timeRangeDay :: RangeBy Time
timeRangeMonth :: RangeBy Time
timeRangeYear :: RangeBy Time

-- | Add days to time.
timeAddDay :: DayCount -> Map Time

-- | Add weeks to time.
timeAddWeek :: Integer -> Map Time

-- | Add months to time.
timeAddMonth :: Integer -> Map Time

-- | Add years to time.
timeAddYear :: Year -> Map Time

-- | Add clock to time.
timeAddClock :: Clock -> AbMap Time

-- | Calculate clock from time to time.
timeDiff :: Time -> Time -> Ab Clock
instance GHC.Classes.Ord Koshucode.Baala.Data.Type.Time.Time.Time
instance GHC.Classes.Eq Koshucode.Baala.Data.Type.Time.Time.Time
instance GHC.Show.Show Koshucode.Baala.Data.Type.Time.Time.Time
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Type.Time.Time.Time

module Koshucode.Baala.Data.Type.Time

module Koshucode.Baala.Data.Content.Message
abLiteral :: TTreeTo (Map (Ab b))

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Int -> Int -> Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require tuple in list
reqRelTuple :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown type name
unkType :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a
unmatchType :: String -> Ab a
expectActual :: String -> String -> [String]
expect2Actual :: String -> String -> String -> [String]


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Data.Type

module Koshucode.Baala.Data.Church.Message
abCoxBuild :: TTreeTo (Map (Ab b))
abCoxCalc :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxFill :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxIrrep :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxPosition :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxPrefix :: TTreeTo (Map (Ab b))
abCoxReduce :: (CodePtr cp) => [cp] -> Map (Ab b)
abCoxSyntax :: TTreeTo (Map (Ab b))

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown object
unkShow :: (Show x) => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Head -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a
detailTermRel :: String -> [String] -> Head -> [String]

module Koshucode.Baala.Data.Message


-- | Term-content expression.
module Koshucode.Baala.Data.Church.Cox

-- | Term-content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Content calculator
CoxCalc :: [CodePt] -> BlankName -> (CopCalc c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> CoxTag -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c
type Cox2 c = (Cox c, Cox c)
type Cox3 c = (Cox c, Cox c, Cox c)
type Cox4 c = (Cox c, Cox c, Cox c, Cox c)
type MaybeCox c = Maybe (Cox c)
type NamedCox c = Named (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c
type CoxTag = Maybe String
coxLit :: c -> Cox c
coxSyntacticArity :: Cox c -> Int
coxMap :: Map (Map (Cox c))
coxCall :: Cox c -> (Map (Cox c)) -> Cox c
checkIrreducible :: AbMap (Cox c)
instance Koshucode.Baala.Base.Text.CodePt.CodePtr (Koshucode.Baala.Data.Church.Cox.Cox c)
instance Koshucode.Baala.Base.Text.Write.Write c => GHC.Show.Show (Koshucode.Baala.Data.Church.Cox.Cox c)
instance Koshucode.Baala.Base.Text.Write.Write c => Koshucode.Baala.Base.Text.Write.Write (Koshucode.Baala.Data.Church.Cox.Cox c)


-- | Term-content operator.
module Koshucode.Baala.Data.Church.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TTree] -> Ab TTree
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
[copsetCopList] :: CopSet c -> [Cop c]
[copsetInfixList] :: CopSet c -> [Named InfixHeight]
[copsetCalcList] :: CopSet c -> [Named (Cop c)]
[copsetCoxList] :: CopSet c -> [Named (Cop c)]
[copsetTreeList] :: CopSet c -> [Named (Cop c)]
[copsetFindCalc] :: CopSet c -> CopFind (Cox c)
[copsetFindCox] :: CopSet c -> CopFind (CopCox c)
[copsetFindTree] :: CopSet c -> CopFind CopTree
[copsetDerived] :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Empty operator set.
copset :: CopSet c
copsetFill :: Map (CopSet c)
instance GHC.Show.Show (Koshucode.Baala.Data.Church.Cop.Cop c)
instance Koshucode.Baala.Base.Prelude.Class.Name (Koshucode.Baala.Data.Church.Cop.Cop c)

module Koshucode.Baala.Data.Content.Class
class (Ord c, Write c, CTypeOf c, CEmpty c, CFull c, CBool c, CCode c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CTie c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
class (Show c, Write c) => CTypeOf c
typeOf :: CTypeOf c => c -> Type

-- | Types that can be empty.
class (CTypeOf c) => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c
maybeEmpty :: (CEmpty c) => (a -> c) -> Maybe a -> c
omitEmpty :: (CEmpty c) => Map [(a, c)]

-- | The maximum content.
class (CTypeOf c) => CFull c
isFull :: CFull c => c -> Bool
full :: CFull c => c

-- | True or false, affirmed or denied.
class (CTypeOf c) => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: (CBool c) => c
false :: (CBool c) => c
putTrue :: (CBool c) => Ab c
putFalse :: (CBool c) => Ab c

-- | Decimal number.
class (CTypeOf c) => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pInt :: (CDec c) => Int -> c
pInteger :: (CDec c) => Integer -> c
pDecFromInt :: (CDec c) => Int -> c
pDecFromInteger :: (CDec c) => Integer -> c

-- | Distance between two points in timeline.
class (CTypeOf c) => CClock c where getClock = getAbAb isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => Ab c -> Ab Clock
putClock :: CClock c => Clock -> Ab c

-- | Point in timeline.
class (CTypeOf c) => CTime c where getTime = getAbAb isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => Ab c -> Ab Time
putTime :: CTime c => Time -> Ab c

-- | Code.
class (CTypeOf c) => CCode c where getCode = getAbAb isCode gCode putCode = Right . pCode
isCode :: CCode c => c -> Bool
gCode :: CCode c => c -> String
pCode :: CCode c => String -> c
getCode :: CCode c => Ab c -> Ab String
putCode :: CCode c => String -> Ab c

-- | Term name.
class (CTypeOf c) => CTerm c where getTerm = getAbAb isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c
pTermSet :: (CTerm c, CSet c) => [String] -> c

-- | Double-quoted text content.
class (CTypeOf c) => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pMaybeText :: (CText c, CEmpty c) => String -> c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c

-- | List of contents.
class (CTypeOf c) => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Set of contents.
class (CTypeOf c) => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
gSetSort :: (Ord c, CSet c) => c -> [c]

-- | Tie of terms.
class (CTypeOf c) => CTie c where getTie = getAbAb isTie gTie putTie = Right . pTie
isTie :: CTie c => c -> Bool
gTie :: CTie c => c -> [Term c]
pTie :: CTie c => [Term c] -> c
getTie :: CTie c => Ab c -> Ab [Term c]
putTie :: CTie c => [Term c] -> Ab c

-- | Relation of terms.
class (CTypeOf c) => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool

-- | Nullary full relation.
dee :: (CRel c) => c

-- | Nullary empty relation.
dum :: (CRel c) => c

-- | Data intepretation.
class (CTypeOf c) => CInterp c where getInterp = getAbAb isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => Ab c -> Ab Interp
putInterp :: CInterp c => Interp -> Ab c

-- | Type of content.
class (CTypeOf c) => CType c where getType = getAbAb isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => Ab c -> Ab Type
putType :: CType c => Type -> Ab c
contAp :: (c -> a) -> (b -> d) -> (a -> b) -> c -> d
contMap :: (c -> [a]) -> ([b] -> d) -> (a -> b) -> c -> d
contApTextToText :: (CText c) => Map String -> AbMap c
contMapTextToList :: (CList c, CText c) => (Char -> c) -> AbMap c
type CGetPut a c = (c -> a, a -> c)
gpText :: (CText c) => CGetPut [Char] c
gpList :: (CList c) => CGetPut [c] c
gpSet :: (CSet c) => CGetPut [c] c
gpSetSort :: (Ord c, CSet c) => CGetPut [c] c


-- | Baala content type.
module Koshucode.Baala.Data.Content.BaalaC

-- | Vanilla content type
data BaalaC

-- | Boolean type
VBool :: Bool -> BaalaC

-- | Code type
VCode :: String -> BaalaC

-- | String type
VText :: String -> BaalaC

-- | Term name type
VTerm :: String -> BaalaC

-- | Decimal number type
VDec :: Decimal -> BaalaC

-- | Clock type
VClock :: Clock -> BaalaC

-- | Time type
VTime :: Time -> BaalaC

-- | Sign of no ordinary type
VEmpty :: BaalaC

-- | The maximum content
VFull :: BaalaC

-- | Interpretation type
VInterp :: Interp -> BaalaC

-- | Type for type
VType :: Type -> BaalaC

-- | List type (objective collection)
VList :: [BaalaC] -> BaalaC

-- | Set type (informative collection)
VSet :: [BaalaC] -> BaalaC

-- | Tie type (set of terms)
VTie :: [Named BaalaC] -> BaalaC

-- | Relation type
VRel :: (Rel BaalaC) -> BaalaC
instance GHC.Show.Show Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CTypeOf Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CContent Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CBool Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CDec Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CClock Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CTime Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CCode Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CText Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CList Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CEmpty Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CFull Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CTerm Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CInterp Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CType Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CSet Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CTie Koshucode.Baala.Data.Content.BaalaC.BaalaC
instance Koshucode.Baala.Data.Content.Class.CRel Koshucode.Baala.Data.Content.BaalaC.BaalaC


-- | Utilities for token trees.
module Koshucode.Baala.Data.Content.Tree
treesToTokens :: TTreesToAb [Token]
treesToTexts :: Bool -> TTreesToAb [String]
treeToText :: Bool -> TTreeToAb String
treesToDigits :: TTreesToAb String
tokenClock :: Token -> Ab Clock
treesToTime :: TTreesToAb Time

-- | Get flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
treeToFlatTerm :: TTreeToAb TermName

-- | Convert token trees into a list of named token trees.
treesToTerms :: TTreesToAb [NamedTrees]
treesToTerms1 :: TTreesToAb [NamedTree]
treesToInterp :: TTreesToAb Interp


-- | Decode token trees to contents.
module Koshucode.Baala.Data.Content.Decode

-- | Content constructor.
type ContentCons c = TTreeToAb c

-- | Content calculator.
type ContentCalc c = TTreeToAb c

-- | Convert token tree into internal form of content.
contentCons :: (CContent c) => ContentCalc c -> ContentCons c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of resources.
treesToJudge :: (CContent c) => ContentCalc c -> AssertType -> JudgePat -> TTreesToAb (Judge c)
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=x</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=xx</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertMultiDeny :: AssertType

-- | <tt>|=c</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertChange :: AssertType

-- | <tt>|=cc</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertMultiChange :: AssertType

-- | <tt>|=v</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertAs :: AssertType -> JudgeOf c
assertSymbol :: AssertType -> String
instance Data.Data.Data Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Classes.Ord Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Classes.Eq Koshucode.Baala.Data.Content.Decode.AssertType
instance GHC.Show.Show Koshucode.Baala.Data.Content.Decode.AssertType


-- | Content of term in judgement.
module Koshucode.Baala.Data.Content


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Build

-- | Construct content expression from token tree
coxBuild :: (CContent c) => ContentCalc c -> CopSet c -> TTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calcutation.
module Koshucode.Baala.Data.Church.Run
type RunCox c = Cox c -> Ab c
type RunList c = [c] -> Ab c
coxRunCox :: (Write c, CRel c, CList c) => CopSet c -> Head -> [c] -> RunCox c
coxRunList :: (Write c, CRel c, CList c) => CopSet c -> Head -> Cox c -> RunList c
calcContent :: (CContent c) => CopSet c -> ContentCalc c
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)
getRightArg1 :: [Ab c] -> Ab c
getRightArg2 :: [Ab c] -> Ab (c, c)
getRightArg3 :: [Ab c] -> Ab (c, c, c)
instance Koshucode.Baala.Base.Text.CodePt.CodePtr (Koshucode.Baala.Data.Church.Run.Beta c)

module Koshucode.Baala.Data.Church

module Koshucode.Baala.Data
