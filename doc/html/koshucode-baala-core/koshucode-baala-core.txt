-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.42.0.0

module Koshucode.Baala.Core.Relmap.Operand
type RopOperand = (RopSorter, [String], [String])
type RopSorter = RopAssoc -> Ab RopAssoc

-- | Sorter for operand of relational operator. This soters docompose
--   operand trees, and give a name to suboperand.
type RopFullSorter = [TokenTree] -> Ab RopAssoc
type RopAssoc = [Named [TokenTree]]

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; sortOperand $ B.tt "a b -x /c 'd -y e"
--   [ ("",   [TreeL (TWord 1 0 "a"), TreeL (TWord 3 0 "b")])
--   , ("-x", [TreeL (TTerm 7 ["/c"]), TreeL (TWord 9 1 "d")])
--   , ("-y", [TreeL (TWord 14 0 "e")]) ]
--   </pre>
sortOperand :: [TokenTree] -> RopAssoc
sortUpOperand :: [TokenTree] -> [Named (OnceMore [TokenTree])]

-- | No-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandNone []
--   </pre>
operandNone :: [String] -> RopOperand

-- | Enumerating trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandEnum ["-1", "-2"] []
--   </pre>
operandEnum :: [String] -> [String] -> RopOperand

-- | Multiple-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandList "-term" []
--   </pre>
operandList :: String -> [String] -> RopOperand

-- | One-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandOne "-relmap" []
--   </pre>
operandOne :: String -> [String] -> RopOperand

-- | Two-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandTwo "-term" "-relmap" []
--   </pre>
operandTwo :: String -> String -> [String] -> RopOperand
operandThree :: String -> String -> String -> [String] -> RopOperand

-- | One-and-multiple-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandOneList "-pattern" "-term" []
--   </pre>
operandOneList :: String -> String -> [String] -> RopOperand

module Koshucode.Baala.Core.Relmap.Relkit
data Relkit c
Relkit :: Relhead -> RelkitBody c -> Relkit c
relkitHead :: Relkit c -> Relhead
relkitBody :: Relkit c -> RelkitBody c
type RelkitBody c = Sourced (RelkitCore c)
data RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([c] -> Ab [[c]]) -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([c] -> Ab [c]) -> RelkitCore c
RelkitAbFull :: Bool -> ([[c]] -> Ab [[c]]) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitId :: RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitUnion :: Bool -> [RelkitBody c] -> RelkitCore c
type RelmapCalcRelkit c = Relhead -> Ab (Relkit c)
type RelmapConflRelkit c = [(Relkit c)] -> RelmapCalcRelkit c
relkit :: Relhead -> RelkitCore c -> Relkit c
relkitId :: Relhead -> Relkit c
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [Termname] -> Relkit c
relkitConstSingleton :: [Termname] -> [c] -> Relkit c
relkitConstBody :: [Termname] -> [[c]] -> Relkit c
relkitSetSource :: TokenListing a => a -> Map (Relkit c)
relkitRun :: Ord c => RelkitBody c -> AbMap [[c]]
instance Show (RelkitCore c)
instance Monoid (Relkit c)

module Koshucode.Baala.Core.Relmap.HalfRelmap

-- | Intermediate data that represents use of relational operator.
--   
--   <a>HalfRelmap</a> is constructed from list of <tt>TokenTree</tt>, and
--   (full) <tt>Relmap</tt> is constructed from <a>HalfRelmap</a>.
data HalfRelmap
HalfRelmap :: String -> Token -> RopAssoc -> [HalfRelmap] -> HalfRelmap

-- | Usages description
halfUsage :: HalfRelmap -> String

-- | Operator name
halfOpToken :: HalfRelmap -> Token

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> RopAssoc

-- | Subrelmaps in the operand
halfSubrelmap :: HalfRelmap -> [HalfRelmap]
halfOpText :: HalfRelmap -> String
instance Typeable HalfRelmap
instance Show HalfRelmap
instance Data HalfRelmap
instance TokenListing HalfRelmap
instance Pretty HalfRelmap

module Koshucode.Baala.Core.Content.Literal.HashWord

-- | Table of coresspondences of hashed sequence and its text.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" hashWordTable
--   Just "\n"  
--   </pre>
hashWordTable :: [(String, String)]

-- | Convert string into hashed form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa\nbbb"
--   "aaa" #lf "bbb"
--   </pre>
hashWord :: Map String

module Koshucode.Baala.Core.Content.Literal.Class
class Show c => PrimContent c
typename :: PrimContent c => c -> String
class (Ord c, Pretty c, PrimContent c, CBool c, CText c, CDec c, CList c, CNil c, CSet c, CTermset c, CRel c) => CContent c where joinContent = foldM appendContent nil
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c

-- | Delete empty list (<a>null</a>) from content list.
nonNullFilter :: Map [[a]]

-- | Delete <a>nil</a> from content list.
nonNilFilter :: CNil c => Map [c]
class PrimContent c => CBool c where needBool = need isBool getBool
isBool :: CBool c => c -> Bool
putBool :: CBool c => Bool -> c
getBool :: CBool c => c -> Bool
needBool :: CBool c => c -> Ab Bool
class PrimContent c => CText c where needText = need isText getText
isText :: CText c => c -> Bool
getText :: CText c => c -> String
putText :: CText c => String -> c
needText :: CText c => c -> Ab String
class PrimContent c => CList c where needList = need isList getList
isList :: CList c => c -> Bool
getList :: CList c => c -> [c]
putList :: CList c => [c] -> c
needList :: CList c => c -> Ab [c]

-- | Types that can be nil
class PrimContent c => CNil c
isNil :: CNil c => c -> Bool
nil :: CNil c => c
class PrimContent c => CDec c where needDec = need isDec getDec
isDec :: CDec c => c -> Bool
getDec :: CDec c => c -> Decimal
putDec :: CDec c => Decimal -> c
needDec :: CDec c => c -> Ab Decimal
putDecFromInt :: CDec c => Int -> c
class PrimContent c => CSet c where needSet = need isSet getSet
isSet :: CSet c => c -> Bool
getSet :: CSet c => c -> [c]
putSet :: CSet c => [c] -> c
needSet :: CSet c => c -> Ab [c]
class PrimContent c => CTermset c where needTermset = need isTermset getTermset
isTermset :: CTermset c => c -> Bool
getTermset :: CTermset c => c -> [Named c]
putTermset :: CTermset c => [Named c] -> c
needTermset :: CTermset c => c -> Ab [Named c]
class PrimContent c => CRel c where needRel = need isRel getRel
isRel :: CRel c => c -> Bool
getRel :: CRel c => c -> Rel c
putRel :: CRel c => Rel c -> c
needRel :: CRel c => c -> Ab (Rel c)
putTextList :: (CText c, CList c) => [String] -> c
putTextSet :: (CText c, CSet c) => [String] -> c


-- | Literalizer: Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal.Literal

-- | Transform <a>TokenTree</a> to something.
type Literalize a = TokenTree -> Ab a

-- | Transform list of <a>TokenTree</a> to something.
type LitTrees a = [TokenTree] -> Ab a
type LitOperators c = [Named (Literalize c -> LitTrees c)]

-- | Transform <a>TokenTree</a> into internal form of content.
litContentBy :: CContent c => LitOperators c -> Literalize c

-- | Collect term name and content.
litTermset :: CContent c => Literalize c -> LitTrees [Named c]

-- | Read list of termname and its content.
--   
--   <pre>
--   &gt;&gt;&gt; litNamedTrees . B.tokenTrees . B.tokens $ "/a 'A3 /b 10"
--   Right [("/a", TreeB 1 [TreeL (TWord 3 0 "'"), TreeL (TWord 4 0 "A3")]),
--          ("/b", TreeL (TWord 8 0 "10"))]
--   </pre>
litNamedTrees :: LitTrees [Named TokenTree]


-- | Extensions of literalizer
module Koshucode.Baala.Core.Content.Literal.Extension
litContent :: CContent c => Literalize c
litOperators :: CContent c => LitOperators c
litJudge :: CContent c => Bool -> JudgePattern -> LitTrees (Judge c)


-- | Term content
module Koshucode.Baala.Core.Content.Literal


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Cox

-- | Content expressions with source code.
type Cox c = Sourced (CoxCore c)

-- | Content expressions.
data CoxCore c

-- | Literal content
CoxLit :: c -> CoxCore c

-- | Operator invocation
CoxApp :: (Cop c) -> [Cox c] -> CoxCore c

-- | Term reference
CoxTerm :: [Termname] -> [Int] -> CoxCore c

-- | Term-content operator.
data Cop c
CopLit :: String -> (CopLit c) -> Cop c
CopMacro :: String -> (CopMacro c) -> Cop c
CopFun :: String -> (CopFun c) -> Cop c
type CopLit c = [TokenTree] -> Ab c
type CopFun c = [c] -> Ab c
type CopMacro c = [Cox c] -> Ab (Cox c)
type CoxCons c = Relhead -> Ab (Cox c)

-- | Construct content expression.
coxCons :: CContent c => ([Cop c], [Named InfixHeight]) -> TokenTree -> Ab (CoxCons c)

-- | Calculate content expression.
coxRun :: (CRel c, CList c) => Relhead -> [c] -> (CoxCons c) -> Ab c
instance Show c => Show (CoxCore c)
instance Name (Cop c)
instance Show (Cop c)


-- | Term content
module Koshucode.Baala.Core.Content


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Rop
data Global c
Global :: Version -> [Rop c] -> ([Cop c], [Named InfixHeight]) -> (TokenTree -> Ab (CoxCons c)) -> String -> [String] -> [Judge c] -> RelSelect c -> Global c
globalVersion :: Global c -> Version
globalRops :: Global c -> [Rop c]
globalCops :: Global c -> ([Cop c], [Named InfixHeight])
globalCoxCons :: Global c -> TokenTree -> Ab (CoxCons c)
globalProgram :: Global c -> String
globalArgs :: Global c -> [String]
globalJudges :: Global c -> [Judge c]
globalSelect :: Global c -> RelSelect c

-- | Relation selector
type RelSelect c = JudgePattern -> [String] -> Rel c
globalCommandLine :: Global c -> [String]
globalFill :: CContent c => Map (Global c)
global :: Global c

-- | Implementation of relmap operator
data Rop c
Rop :: String -> String -> RopFullSorter -> RopCons c -> String -> Rop c

-- | Operator name
ropName :: Rop c -> String

-- | Operator group
ropGroup :: Rop c -> String

-- | Operand sorter
ropFullSorter :: Rop c -> RopFullSorter

-- | Constructor of operator
ropCons :: Rop c -> RopCons c

-- | Usage of operator
ropUsage :: Rop c -> String

-- | Use of relmap operator
data RopUse c
RopUse :: Global c -> HalfRelmap -> [Relmap c] -> RopUse c
ropGlobal :: RopUse c -> Global c

-- | Syntactic data of operator use
ropHalf :: RopUse c -> HalfRelmap

-- | Subrelmaps
ropSubrelmap :: RopUse c -> [Relmap c]

-- | Constructor of relmap operator
type RopCons c = RopUse c -> Ab (Relmap c)

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator.
data Relmap c

-- | Retrieve a relation from a dataset
RelmapSource :: HalfRelmap -> JudgePattern -> [Termname] -> Relmap c

-- | Constant relation
RelmapConst :: HalfRelmap -> (Rel c) -> Relmap c

-- | Equavalent relmap
RelmapAlias :: HalfRelmap -> (Relmap c) -> Relmap c

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> (RelmapConflRelkit c) -> [Relmap c] -> Relmap c

-- | Relmap that maps relations to a relation
RelmapGlobal :: HalfRelmap -> (Global c -> RelmapCalcRelkit c) -> Relmap c

-- | Connect two relmaps
RelmapAppend :: (Relmap c) -> (Relmap c) -> Relmap c

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap c
instance Show (RopUse c)
instance TokenListing (Relmap c)
instance Pretty (Relmap c)
instance Name (Relmap c)
instance Monoid (Relmap c)
instance Show (Relmap c)
instance Show (Rop c)
instance Show (Global c)


-- | Data structures for relation-to-relation mappings
module Koshucode.Baala.Core.Relmap.Relmap

-- | Retrieve relation from dataset.
relmapSource :: RopUse c -> JudgePattern -> [Termname] -> (Relmap c)

-- | Constant relmap.
relmapConst :: RopUse c -> Rel c -> Relmap c

-- | Alias for relmap.
relmapAlias :: RopUse c -> Relmap c -> Relmap c

-- | Make a non-confluent relmap.
relmapCalc :: RopUse c -> RelmapCalcRelkit c -> Relmap c

-- | Make a confluent relmap.
relmapConfl :: RopUse c -> RelmapConflRelkit c -> [Relmap c] -> Relmap c
relmapGlobal :: RopUse c -> (Global c -> RelmapCalcRelkit c) -> Relmap c

-- | List of <tt>RelmapSource</tt>
relmapSourceList :: Relmap c -> [Relmap c]

-- | List of name in <tt>RelmapName</tt>
relmapNameList :: Relmap c -> [String]

-- | Link relmaps by its name.
relmapLinker :: [Named (Relmap c)] -> Relmap c -> Relmap c


-- | <tt>Relmap</tt> construction.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make half and full relmap constructors.
relmapCons :: Global c -> (RelmapCons c)

-- | Half and full relmap constructor
data RelmapCons c
RelmapCons :: RelmapConsHalf -> (RelmapConsFull c) -> RelmapCons c

-- | First step of constructing relmap, make <a>HalfRelmap</a> from use of
--   relmap operator.
type RelmapConsHalf = [TokenTree] -> Ab HalfRelmap

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>HalfRelmap</a>.
type RelmapConsFull c = HalfRelmap -> Ab (Relmap c)
instance Show (RelmapCons c)


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Assertion of affirming or denying relation. It consists of logical
--   quality, relsign, and relmap.
--   
--   See also <a>Judge</a>
data Assert c
Assert :: AssertType -> JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c

-- | Logical quality
assertType :: Assert c -> AssertType

-- | Pattern of judgement
assertPattern :: Assert c -> JudgePattern

-- | Assert option
assertOption :: Assert c -> AssertOption

-- | Relmap
assertRelmap :: Assert c -> Relmap c

-- | Source code information
assertSource :: Assert c -> [Token]

-- | Option for assertions.
type AssertOption = [Named [TokenTree]]

-- | Apply function to relamp in assert.
assertMap :: Map (Relmap c) -> Map (Assert c)
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertQuality :: AssertType -> Bool

-- | Make affirmed assertion.
affirm :: JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c

-- | Make denied assertion.
deny :: JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType
instance Show (Assert c)
instance Pretty (Assert c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges
emptyDataset :: Dataset c

-- | Gather judges into a dataset
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
addJudges :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CNil</tt> sign is used.
selectRelation :: (Ord c, CNil c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, CNil c) => Global c -> [Assert c] -> Ab [Judge c]

-- | Calculate assertion list.
runAssertDataset :: (Ord c, CNil c) => Global c -> [Assert c] -> Dataset c -> Ab [Judge c]


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Assert


-- | Intermidiate structure between <a>String</a> and <tt>Section</tt>.
module Koshucode.Baala.Core.Section.Clause
data Clause
Clause :: TokenClause -> ClauseBody -> Clause
clauseSource :: Clause -> TokenClause
clauseBody :: Clause -> ClauseBody
data ClauseBody

-- | Section name
CSection :: (Maybe String) -> ClauseBody

-- | Importing section name
CImport :: [Token] -> (Maybe Clause) -> ClauseBody

-- | Exporting relmap name
CExport :: String -> ClauseBody

-- | Short signs
CShort :: (Named String) -> ClauseBody

-- | Relmap and its name
CRelmap :: String -> HalfRelmap -> ClauseBody

-- | Not include HalfRelmap
TRelmap :: String -> [Token] -> ClauseBody

-- | Assertions of relmaps
CAssert :: AssertType -> JudgePattern -> AssertOption -> HalfRelmap -> ClauseBody

-- | Not include HalfRelmap
TAssert :: AssertType -> JudgePattern -> AssertOption -> [Token] -> ClauseBody

-- | Judge
CJudge :: Bool -> JudgePattern -> [Token] -> ClauseBody

-- | Clause comment
CComment :: ClauseBody

-- | Unknown clause
CUnknown :: ClauseBody

-- | Unresolved short sign
CUnres :: [Token] -> ClauseBody

-- | Name of clause type. e.g., <tt>"Relmap"</tt>, <tt>"Assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <a>TRelmap</a> and <a>TAssert</a> are contained. This function does
--   not depend on <a>RelmapConsHalf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [ TRelmap ( TokenClause
--                [TWord 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TWord 1 0 "a", ...]] )
--            "a" [ TWord 5 0 "source"
--                , TWord 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
consPreclause :: [TokenLine] -> [Clause]

-- | Construct <a>Clause</a> list from <a>Token</a> list. This is a first
--   step of constructing <tt>Section</tt>.
consClause :: RelmapConsHalf -> [TokenLine] -> Ab [Clause]
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause


-- | Data structure for relational calculations. There are three types of
--   section: (1) <i>editing sections</i> that output judges and read other
--   sections, (2) <i>library sections</i> that make relmaps reusable, (3)
--   <i>data sections</i> that provide data.
module Koshucode.Baala.Core.Section.Section
data Section c
Section :: Maybe String -> [Section c] -> [String] -> [Named String] -> [Assert c] -> [Named (Relmap c)] -> [Judge c] -> [Judge c] -> Resource -> RelmapCons c -> Section c

-- | Section name
sectionName :: Section c -> Maybe String

-- | Importing section
sectionImport :: Section c -> [Section c]

-- | Exporting relmap names
sectionExport :: Section c -> [String]

-- | Prefix for short signs
sectionShort :: Section c -> [Named String]

-- | Assertions of relmaps
sectionAssert :: Section c -> [Assert c]

-- | Relmaps and its name
sectionRelmap :: Section c -> [Named (Relmap c)]

-- | Affirmative or denial judgements
sectionJudge :: Section c -> [Judge c]

-- | Violated judgements, i.e., result of <tt>|=V</tt>
sectionViolate :: Section c -> [Judge c]

-- | Resource name
sectionResource :: Section c -> Resource

-- | Relmap constructor for this section
sectionCons :: Section c -> RelmapCons c

-- | Make empty section that has a given constructor.
makeEmptySection :: RelmapCons c -> Section c

-- | Section that has no contents.
emptySection :: Section c

-- | Second step of constructing <a>Section</a>.
consSection :: CContent c => RelmapConsFull c -> Resource -> [Clause] -> Ab (Section c)
instance Show c => Show (Section c)
instance Monoid (Section c)
instance (Ord c, Pretty c) => Pretty (Section c)


-- | Read, run, and write sections.
module Koshucode.Baala.Core.Section.Process

-- | Read section from certain resource.
readSection :: CContent c => Section c -> Resource -> IO (Ab (Section c))

-- | Read section from text.
readSectionText :: CContent c => Section c -> String -> Ab (Section c)

-- | Read judges from text.
readJudges :: CContent c => String -> Ab [Judge c]

-- | Run section. Output section has judges calculated from assertions in
--   input section.
runSection :: CContent c => Global c -> AbMap (Section c)

-- | Output judges in section. If violated judges are found, output they.
--   If no violations, output regular judges.
hPutSection :: CContent c => Handle -> Section c -> IO Int

module Koshucode.Baala.Core.Section.Bundle

-- | Bundle of section resources.
data SectionBundle c
SectionBundle :: Section c -> [String] -> [FilePath] -> [String] -> SectionBundle c
bundleRoot :: SectionBundle c -> Section c
bundleTexts :: SectionBundle c -> [String]
bundleFiles :: SectionBundle c -> [FilePath]
bundleURLs :: SectionBundle c -> [String]
readSectionBundle :: CContent c => SectionBundle c -> IO [Ab (Section c)]
instance Show c => Show (SectionBundle c)

module Koshucode.Baala.Core.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapConsHalf -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Section

module Koshucode.Baala.Core
