-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.48.0.0


-- | Sorter for operand of relmap operator.
module Koshucode.Baala.Core.Relmap.Operand

-- | Sorter for operand of relmap operator. Sorters docompose operand
--   trees, and give a name to suboperand.
type RopFullSorter = [TokenTree] -> Ab RopOperandAssoc
ropFullSorter :: RopOperandSorter -> RopFullSorter

-- | Relmap operand as association list.
type RopOperandAssoc = [Named [TokenTree]]

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; ropOperandAssoc $ B.tt "a b -x /c 'd -y e"
--   [ ("",   [TreeL (TWord 1 0 "a"), TreeL (TWord 3 0 "b")])
--   , ("-x", [TreeL (TTerm 7 ["/c"]), TreeL (TWord 9 1 "d")])
--   , ("-y", [TreeL (TWord 14 0 "e")]) ]
--   </pre>
ropOperandAssoc :: [TokenTree] -> RopOperandAssoc

-- | Operand sorter for relmap operator. It consists of trunk sorter, trunk
--   names, and branch names. Trunk part is unnamed operand. Branch part is
--   named operand.
type RopOperandSorter = (RopTrunkSorter, [String], [String])

-- | Mapping from basically sorted operand to fully sorted operand.
type RopTrunkSorter = AbMap RopOperandAssoc

-- | Operand sorter for no-element trunk.
sortNone :: [String] -> RopOperandSorter

-- | Operand sorter for enumerating trunk.
sortEnum :: [String] -> [String] -> RopOperandSorter

-- | Operand sorter for multiple-element trunk.
sortList :: String -> [String] -> RopOperandSorter

-- | Operand sorter for one-element trunk.
sortOne :: String -> [String] -> RopOperandSorter

-- | Operand sorter for two-element trunk.
sortTwo :: String -> String -> [String] -> RopOperandSorter
sortThree :: String -> String -> String -> [String] -> RopOperandSorter
sortFour :: String -> String -> String -> String -> [String] -> RopOperandSorter

-- | Operand sorter for one-and-multiple-element trunk.
sortOneList :: String -> String -> [String] -> RopOperandSorter


-- | Lexical relmap.
module Koshucode.Baala.Core.Relmap.Lexical

-- | Intermediate data that represents use of relational operator.
--   
--   <a>Lexmap</a> is constructed from list of <tt>TokenTree</tt>, and
--   (generic) <tt>Relmap</tt> is constructed from <a>Lexmap</a>.
data Lexmap
Lexmap :: Token -> RopOperandAssoc -> [Lexmap] -> String -> Lexmap

-- | Operator token
lexOpToken :: Lexmap -> Token

-- | Operand of relmap operation
lexOperand :: Lexmap -> RopOperandAssoc

-- | Subrelmaps in the operand
lexSubrelmap :: Lexmap -> [Lexmap]

-- | Usages description
lexUsage :: Lexmap -> String
lexOpText :: Lexmap -> String
instance Typeable Lexmap
instance Show Lexmap
instance Eq Lexmap
instance Ord Lexmap
instance Data Lexmap
instance TokenListing Lexmap
instance Pretty Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relmap.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Relhead -> RelkitBody c -> Relkit c
relkitHead :: Relkit c -> Maybe Relhead
relkitBody :: Relkit c -> RelkitBody c
type RelkitBody c = Sourced (RelkitCore c)
type RelkitKey = (Maybe Relhead, [Lexmap])
type RelkitDef c = (RelkitKey, Relkit c)

-- | Mapping for body of relation.
type Relbmap c = [[c]] -> Ab [[c]]
data RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitAbFull :: Bool -> ([Relbmap c] -> [[c]] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([Relbmap c] -> [c] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([Relbmap c] -> [c] -> Ab [c]) -> [RelkitBody c] -> RelkitCore c
RelkitAbSemi :: ([[c]] -> Ab Bool) -> (RelkitBody c) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitId :: RelkitCore c
RelkitLink :: String -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c
relkit :: Maybe Relhead -> RelkitCore c -> Relkit c
relkitJust :: Relhead -> RelkitCore c -> Relkit c
relkitNothing :: Relkit c
relkitId :: Maybe Relhead -> Relkit c
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [Termname] -> Relkit c
relkitConstSingleton :: [Termname] -> [c] -> Relkit c
relkitConstBody :: [Termname] -> [[c]] -> Relkit c
relkitSetSource :: TokenListing a => a -> Map (Relkit c)
relkitLink :: Ord c => [RelkitDef c] -> Map (Relkit c)
relkitRun :: Ord c => RelkitBody c -> AbMap [[c]]
fixedRelation :: Ord c => Map (AbMap [[c]])
bodyMapArrange :: Relhead -> Relhead -> Map (AbMap [[c]])
instance Show (RelkitCore c)
instance Monoid (Relkit c)

module Koshucode.Baala.Core.Content.HashWord

-- | Table of coresspondences of hashed sequence and its text.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" hashWordTable
--   Just "\n"
--   </pre>
hashWordTable :: [(String, String)]

-- | Convert string into hashed form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa\nbbb"
--   "aaa" #lf "bbb"
--   </pre>
hashWord :: Map String

module Koshucode.Baala.Core.Content.Class
class Show c => PrimContent c
typename :: PrimContent c => c -> String
class (Ord c, Pretty c, PrimContent c, CBool c, CText c, CDec c, CList c, CNil c, CSet c, CTermset c, CRel c) => CContent c where joinContent = foldM appendContent nil
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c

-- | Delete empty list (<a>null</a>) from content list.
nonNullFilter :: Map [[a]]

-- | Delete <a>nil</a> from content list.
nonNilFilter :: CNil c => Map [c]
class PrimContent c => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
class PrimContent c => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
class PrimContent c => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Types that can be nil
class PrimContent c => CNil c
isNil :: CNil c => c -> Bool
nil :: CNil c => c
class PrimContent c => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pDecFromInt :: CDec c => Int -> c
class PrimContent c => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
class PrimContent c => CTermset c where getTermset = getAbAb isTermset gTermset putTermset = Right . pTermset
isTermset :: CTermset c => c -> Bool
gTermset :: CTermset c => c -> [Named c]
pTermset :: CTermset c => [Named c] -> c
getTermset :: CTermset c => Ab c -> Ab [Named c]
putTermset :: CTermset c => [Named c] -> Ab c
class PrimContent c => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool


-- | Literalizer: Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal

-- | Transform <a>TokenTree</a> to something.
type Literalize a = TokenTree -> Ab a

-- | Transform list of <a>TokenTree</a> to something.
type LitTrees a = [TokenTree] -> Ab a
type LitOperators c = [Named (Literalize c -> LitTrees c)]

-- | Transform <a>TokenTree</a> into internal form of content.
litContentBy :: CContent c => LitOperators c -> Literalize c

-- | Collect term name and content.
litTermset :: CContent c => Literalize c -> LitTrees [Named c]

-- | Read list of termname and its content.
--   
--   <pre>
--   &gt;&gt;&gt; litNamedTrees . B.tokenTrees . B.tokens $ "/a 'A3 /b 10"
--   Right [("/a", TreeB 1 [TreeL (TWord 3 0 "'"), TreeL (TWord 4 0 "A3")]),
--          ("/b", TreeL (TWord 8 0 "10"))]
--   </pre>
litNamedTrees :: LitTrees [Named TokenTree]


-- | Extensions of literalizer
module Koshucode.Baala.Core.Content.Extension
litContent :: CContent c => Literalize c
litOperators :: CContent c => LitOperators c
litJudge :: CContent c => Bool -> JudgePattern -> LitTrees (Judge c)


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Cox

-- | Content expressions with source code.
type Cox c = Sourced (CoxCore c)

-- | Content expressions.
data CoxCore c

-- | A: Literal content
CoxLit :: c -> CoxCore c

-- | A: Term reference, its name and position
CoxTerm :: [Termname] -> [Int] -> CoxCore c

-- | A: Base function
CoxBase :: String -> (CopFun c) -> CoxCore c

-- | B: Variable, its name and De Bruijn index
CoxVar :: String -> Int -> CoxCore c

-- | A/B: Function application (multiple arguments)
CoxApplyL :: (Cox c) -> [Cox c] -> CoxCore c

-- | B: Derived function
CoxDeriv :: String -> (Cox c) -> CoxCore c

-- | C: Derived function (multiple variables)
CoxDerivL :: [String] -> (Cox c) -> CoxCore c

-- | Term-content operator.
data Cop c

-- | Function
CopFun :: String -> (CopFun c) -> Cop c

-- | Syntax
CopSyn :: String -> (CopSyn) -> Cop c
type CopFun c = [Ab c] -> Ab c
type CopSyn = [TokenTree] -> Ab TokenTree
isCopFunction :: Cop c -> Bool
isCopSyntax :: Cop c -> Bool
type NamedCox c = Named (Cox c)
coxAlpha :: CContent c => ([Cop c], [Named InfixHeight]) -> TokenTree -> Ab (Cox c)
coxBeta :: [Cop c] -> [NamedCox c] -> Relhead -> Cox c -> Ab (Cox c)
checkIrreducible :: Cox c -> Ab (Cox c)

-- | Calculate content expression.
coxRun :: (CRel c, CList c, Pretty c) => [c] -> Cox c -> Ab c
instance Name (Cop c)
instance Show (Cop c)
instance Pretty c => Pretty (CoxCore c)
instance Pretty c => Show (CoxCore c)


-- | Term content
module Koshucode.Baala.Core.Content


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator
data Rop c
Rop :: String -> String -> RopFullSorter -> RopCons c -> String -> Rop c

-- | Operator name
ropName :: Rop c -> String

-- | Operator group
ropGroup :: Rop c -> String

-- | Operand sorter
ropSorter :: Rop c -> RopFullSorter

-- | Constructor of operator
ropCons :: Rop c -> RopCons c

-- | Usage of operator
ropUsage :: Rop c -> String

-- | Use of relmap operator
data RopUse c
RopUse :: Global c -> Lexmap -> [Relmap c] -> RopUse c
ropGlobal :: RopUse c -> Global c

-- | Syntactic data of operator use
ropLex :: RopUse c -> Lexmap

-- | Subrelmaps
ropSubrelmap :: RopUse c -> [Relmap c]

-- | Constructor of relmap operator
type RopCons c = RopUse c -> Ab (Relmap c)
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator.
data Relmap c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgePattern -> [Termname] -> Relmap c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap c

-- | Relmap that maps relations to a relation with globals
RelmapGlobal :: Lexmap -> (Global c -> RelkitCalc c) -> Relmap c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap c] -> Relmap c

-- | Relmap reference
RelmapLink :: Lexmap -> String -> Relmap c

-- | Connect two relmaps
RelmapAppend :: (Relmap c) -> (Relmap c) -> Relmap c
type RelmapDef c = Named (Relmap c)
relmapId :: Relmap c

-- | Map function to relmaps.
mapToRelmap :: Map (Relmap c) -> Map (Relmap c)
relmapLexList :: Relmap c -> [Lexmap]

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitCalc c = Maybe Relhead -> Ab (Relkit c)

-- | Make <a>Relkit</a> from globals and input heading.
type RelkitGlobal c = Global c -> RelkitCalc c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitCalc c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [(Relkit c)] -> RelkitCalc c
data Global c
Global :: Version -> [Rop c] -> ([Cop c], [Named InfixHeight]) -> String -> [String] -> [Judge c] -> RelSelect c -> Global c
globalVersion :: Global c -> Version
globalRops :: Global c -> [Rop c]
globalCops :: Global c -> ([Cop c], [Named InfixHeight])
globalProgram :: Global c -> String
globalArgs :: Global c -> [String]
globalJudges :: Global c -> [Judge c]
globalSelect :: Global c -> RelSelect c

-- | Relation selector
type RelSelect c = JudgePattern -> [String] -> Rel c
globalCommandLine :: Global c -> [String]
globalFill :: CContent c => Map (Global c)
global :: Global c
globalSyntax :: Global c -> ([Cop c], [Named InfixHeight])
globalFunction :: Global c -> [Cop c]
instance Show (RopUse c)
instance Show (Global c)
instance Eq (Relmap c)
instance Ord (Relmap c)
instance TokenListing (Relmap c)
instance Pretty (Relmap c)
instance Name (Relmap c)
instance Monoid (Relmap c)
instance Show (Relmap c)
instance TokenListing (RopUse c)
instance Show (Rop c)


-- | <a>Relmap</a> construction.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make lex and full relmap constructors.
relmapCons :: Global c -> (RelmapCons c)

-- | Lex and full relmap constructor
data RelmapCons c
RelmapCons :: RelmapConsLex -> (RelmapConsFull c) -> RelmapCons c

-- | First step of constructing relmap, make <a>Lexmap</a> from use of
--   relmap operator.
type RelmapConsLex = [TokenTree] -> Ab Lexmap

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>Lexmap</a>.
type RelmapConsFull c = Lexmap -> Ab (Relmap c)
instance Show (RelmapCons c)


-- | Operations on <a>Relmap</a>.
module Koshucode.Baala.Core.Relmap.Relmap

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap c -> [Relmap c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap c -> [String]

-- | Retrieve relation from dataset.
relmapSource :: RopUse c -> JudgePattern -> [Termname] -> (Relmap c)

-- | Make a constant relmap.
relmapConst :: RopUse c -> Rel c -> Relmap c

-- | Make a flow relmap. Flow relmaps take no subrelmaps.
relmapFlow :: RopUse c -> RelkitCalc c -> Relmap c

-- | Make a global relmap. Global relmaps are flow relmaps with globals.
relmapGlobal :: RopUse c -> RelkitGlobal c -> Relmap c

-- | Make a binary relmap. Binary relmaps take one subrelmap.
relmapBinary :: RopUse c -> RelkitBinary c -> Relmap c -> Relmap c

-- | Make a confluent relmap. Confluent relmaps take multiple subrelmaps.
relmapConfl :: RopUse c -> RelkitConfl c -> [Relmap c] -> Relmap c
relmapSpecialize :: Global c -> [RelmapDef c] -> [RelkitDef c] -> Maybe Relhead -> Relmap c -> Ab ([RelkitDef c], Relkit c)


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert c
Assert :: AssertType -> JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c

-- | Logical quality
assertType :: Assert c -> AssertType

-- | Pattern of judgement
assertPattern :: Assert c -> JudgePattern

-- | Assert option
assertOption :: Assert c -> AssertOption

-- | Relmap
assertRelmap :: Assert c -> Relmap c

-- | Source code information
assertSource :: Assert c -> [Token]

-- | Option for assertions.
type AssertOption = [Named [TokenTree]]

-- | Apply function to relamp in assert.
assertMap :: Map (Relmap c) -> Map (Assert c)
isViolateAssert :: Assert c -> Bool
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertQuality :: AssertType -> Bool

-- | Make affirmed assertion.
affirm :: JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c

-- | Make denied assertion.
deny :: JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType
instance Show (Assert c)
instance Pretty (Assert c)
instance TokenListing (Assert c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges.
emptyDataset :: Dataset c

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
addJudges :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CNil</tt> sign is used.
selectRelation :: (Ord c, CNil c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, CNil c) => Global c -> [RelmapDef c] -> [Assert c] -> Ab [Judge c]


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Intermidiate structure between <a>String</a> and <tt>Section</tt>.
module Koshucode.Baala.Core.Section.Clause
data Clause
Clause :: TokenClause -> ClauseBody -> Clause
clauseSource :: Clause -> TokenClause
clauseBody :: Clause -> ClauseBody
data ClauseBody

-- | Section name
CSection :: (Maybe String) -> ClauseBody

-- | Importing section name
CImport :: [Token] -> (Maybe Clause) -> ClauseBody

-- | Exporting relmap name
CExport :: String -> ClauseBody

-- | Short signs
CShort :: [(Named String)] -> ClauseBody

-- | Relmap and its name
CRelmap :: String -> Lexmap -> ClauseBody

-- | Not include Lexmap
TRelmap :: String -> [Token] -> ClauseBody

-- | Assertions of relmaps
CAssert :: AssertType -> JudgePattern -> AssertOption -> Lexmap -> ClauseBody

-- | Not include Lexmap
TAssert :: AssertType -> JudgePattern -> AssertOption -> [Token] -> ClauseBody

-- | Judge
CJudge :: Bool -> JudgePattern -> [Token] -> ClauseBody

-- | Clause comment
CComment :: ClauseBody

-- | Unknown clause
CUnknown :: ClauseBody

-- | Unresolved short sign
CUnres :: [Token] -> ClauseBody

-- | Name of clause type. e.g., <tt>"Relmap"</tt>, <tt>"Assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <a>TRelmap</a> and <a>TAssert</a> are contained. This function does
--   not depend on <a>RelmapConsLex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [ TRelmap ( TokenClause
--                [TWord 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TWord 1 0 "a", ...]] )
--            "a" [ TWord 5 0 "source"
--                , TWord 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
consPreclause :: [TokenLine] -> [Clause]

-- | Construct <a>Clause</a> list from <a>Token</a> list. This is a first
--   step of constructing <tt>Section</tt>.
consClause :: RelmapConsLex -> [TokenLine] -> Ab [Short [Clause]]
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause


-- | Data structure for relational calculations. There are three types of
--   section: (1) <i>editing sections</i> that output judges and read other
--   sections, (2) <i>library sections</i> that make relmaps reusable, (3)
--   <i>data sections</i> that provide data.
module Koshucode.Baala.Core.Section.Section
data Section c
Section :: Maybe String -> [Section c] -> [String] -> [[Named String]] -> AbbrAsserts c -> [RelmapDef c] -> [Judge c] -> [Judge c] -> Resource -> RelmapCons c -> Section c

-- | Section name
sectionName :: Section c -> Maybe String

-- | Importing section
sectionImport :: Section c -> [Section c]

-- | Exporting relmap names
sectionExport :: Section c -> [String]

-- | Prefix for short signs
sectionShort :: Section c -> [[Named String]]

-- | Assertions of relmaps
sectionAssert :: Section c -> AbbrAsserts c

-- | Relmaps and its name
sectionRelmap :: Section c -> [RelmapDef c]

-- | Affirmative or denial judgements
sectionJudge :: Section c -> [Judge c]

-- | Violated judgements, i.e., result of <tt>|=V</tt>
sectionViolate :: Section c -> [Judge c]

-- | Resource name
sectionResource :: Section c -> Resource

-- | Relmap constructor for this section
sectionCons :: Section c -> RelmapCons c
type AbbrAsserts c = [Short [Assert c]]
assertViolated :: Map (AbbrAsserts c)
assertNormal :: Map (AbbrAsserts c)

-- | Make empty section that has a given constructor.
makeEmptySection :: RelmapCons c -> Section c

-- | Section that has no contents.
emptySection :: Section c

-- | Second step of constructing <a>Section</a>.
consSection :: CContent c => RelmapConsFull c -> Resource -> [Short [Clause]] -> Ab (Section c)
instance Show c => Show (Section c)
instance Monoid (Section c)
instance (Ord c, Pretty c) => Pretty (Section c)


-- | Read, run, and write sections.
module Koshucode.Baala.Core.Section.Process

-- | Read section from certain resource.
readSection :: CContent c => Section c -> Resource -> IO (Ab (Section c))

-- | Read section from text.
readSectionText :: CContent c => Section c -> String -> Ab (Section c)

-- | Read judges from text.
readJudges :: CContent c => String -> Ab [Judge c]
runSection :: CContent c => Global c -> [Section c] -> Ab ([ShortJudge c], [ShortJudge c])

module Koshucode.Baala.Core.Section.Bundle

-- | Bundle of section resources.
data SectionBundle c
SectionBundle :: Section c -> [String] -> [FilePath] -> [String] -> SectionBundle c
bundleRoot :: SectionBundle c -> Section c
bundleTexts :: SectionBundle c -> [String]
bundleFiles :: SectionBundle c -> [FilePath]
bundleURLs :: SectionBundle c -> [String]
readSectionBundle :: CContent c => SectionBundle c -> IO [Ab (Section c)]
instance Show c => Show (SectionBundle c)

module Koshucode.Baala.Core.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapConsLex -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Section

module Koshucode.Baala.Core
