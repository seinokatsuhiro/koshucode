-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.44.0.0

module Koshucode.Baala.Core.Relmap.Relkit
data Relkit c
Relkit :: Relhead -> RelkitBody c -> Relkit c
relkitHead :: Relkit c -> Relhead
relkitBody :: Relkit c -> RelkitBody c
type RelkitBody c = Sourced (RelkitCore c)
data RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([c] -> Ab [[c]]) -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([c] -> Ab [c]) -> RelkitCore c
RelkitAbFull :: Bool -> ([[c]] -> Ab [[c]]) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitId :: RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitUnion :: Bool -> [RelkitBody c] -> RelkitCore c
relkit :: Relhead -> RelkitCore c -> Relkit c
relkitId :: Relhead -> Relkit c
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [Termname] -> Relkit c
relkitConstSingleton :: [Termname] -> [c] -> Relkit c
relkitConstBody :: [Termname] -> [[c]] -> Relkit c
relkitSetSource :: TokenListing a => a -> Map (Relkit c)
relkitRun :: Ord c => RelkitBody c -> AbMap [[c]]
instance Show (RelkitCore c)
instance Monoid (Relkit c)


-- | Sorter for operand of relmap operator.
module Koshucode.Baala.Core.Relmap.Operand

-- | Sorter for operand of relmap operator. Sorters docompose operand
--   trees, and give a name to suboperand.
type RopFullSorter = [TokenTree] -> Ab RopOperandAssoc
ropFullSorter :: RopOperandSorter -> RopFullSorter

-- | Relmap operand as association list.
type RopOperandAssoc = [Named [TokenTree]]

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; ropOperandAssoc $ B.tt "a b -x /c 'd -y e"
--   [ ("",   [TreeL (TWord 1 0 "a"), TreeL (TWord 3 0 "b")])
--   , ("-x", [TreeL (TTerm 7 ["/c"]), TreeL (TWord 9 1 "d")])
--   , ("-y", [TreeL (TWord 14 0 "e")]) ]
--   </pre>
ropOperandAssoc :: [TokenTree] -> RopOperandAssoc

-- | Operand sorter for relmap operator. It consists of trunk sorter, trunk
--   names, and branch names. Trunk part is unnamed operand. Branch part is
--   named operand.
type RopOperandSorter = (RopTrunkSorter, [String], [String])

-- | Mapping from basically sorted operand to fully sorted operand.
type RopTrunkSorter = AbMap RopOperandAssoc

-- | Operand sorter for no-element trunk.
sortNone :: [String] -> RopOperandSorter

-- | Operand sorter for enumerating trunk.
sortEnum :: [String] -> [String] -> RopOperandSorter

-- | Operand sorter for multiple-element trunk.
sortList :: String -> [String] -> RopOperandSorter

-- | Operand sorter for one-element trunk.
sortOne :: String -> [String] -> RopOperandSorter

-- | Operand sorter for two-element trunk.
sortTwo :: String -> String -> [String] -> RopOperandSorter
sortThree :: String -> String -> String -> [String] -> RopOperandSorter
sortFour :: String -> String -> String -> String -> [String] -> RopOperandSorter

-- | Operand sorter for one-and-multiple-element trunk.
sortOneList :: String -> String -> [String] -> RopOperandSorter

module Koshucode.Baala.Core.Relmap.HalfRelmap

-- | Intermediate data that represents use of relational operator.
--   
--   <a>HalfRelmap</a> is constructed from list of <tt>TokenTree</tt>, and
--   (full) <tt>Relmap</tt> is constructed from <a>HalfRelmap</a>.
data HalfRelmap
HalfRelmap :: Token -> RopOperandAssoc -> [HalfRelmap] -> String -> HalfRelmap

-- | Operator token
halfOpToken :: HalfRelmap -> Token

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> RopOperandAssoc

-- | Subrelmaps in the operand
halfSubrelmap :: HalfRelmap -> [HalfRelmap]

-- | Usages description
halfUsage :: HalfRelmap -> String
halfOpText :: HalfRelmap -> String
instance Typeable HalfRelmap
instance Show HalfRelmap
instance Data HalfRelmap
instance TokenListing HalfRelmap
instance Pretty HalfRelmap

module Koshucode.Baala.Core.Content.Literal.HashWord

-- | Table of coresspondences of hashed sequence and its text.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" hashWordTable
--   Just "\n"  
--   </pre>
hashWordTable :: [(String, String)]

-- | Convert string into hashed form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa\nbbb"
--   "aaa" #lf "bbb"
--   </pre>
hashWord :: Map String

module Koshucode.Baala.Core.Content.Literal.Class
class Show c => PrimContent c
typename :: PrimContent c => c -> String
class (Ord c, Pretty c, PrimContent c, CBool c, CText c, CDec c, CList c, CNil c, CSet c, CTermset c, CRel c) => CContent c where joinContent = foldM appendContent nil
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c

-- | Delete empty list (<a>null</a>) from content list.
nonNullFilter :: Map [[a]]

-- | Delete <a>nil</a> from content list.
nonNilFilter :: CNil c => Map [c]
class PrimContent c => CBool c where needBool = need isBool getBool
isBool :: CBool c => c -> Bool
putBool :: CBool c => Bool -> c
getBool :: CBool c => c -> Bool
needBool :: CBool c => c -> Ab Bool
class PrimContent c => CText c where needText = need isText getText
isText :: CText c => c -> Bool
getText :: CText c => c -> String
putText :: CText c => String -> c
needText :: CText c => c -> Ab String
class PrimContent c => CList c where needList = need isList getList
isList :: CList c => c -> Bool
getList :: CList c => c -> [c]
putList :: CList c => [c] -> c
needList :: CList c => c -> Ab [c]

-- | Types that can be nil
class PrimContent c => CNil c
isNil :: CNil c => c -> Bool
nil :: CNil c => c
class PrimContent c => CDec c where needDec = need isDec getDec
isDec :: CDec c => c -> Bool
getDec :: CDec c => c -> Decimal
putDec :: CDec c => Decimal -> c
needDec :: CDec c => c -> Ab Decimal
putDecFromInt :: CDec c => Int -> c
class PrimContent c => CSet c where needSet = need isSet getSet
isSet :: CSet c => c -> Bool
getSet :: CSet c => c -> [c]
putSet :: CSet c => [c] -> c
needSet :: CSet c => c -> Ab [c]
class PrimContent c => CTermset c where needTermset = need isTermset getTermset
isTermset :: CTermset c => c -> Bool
getTermset :: CTermset c => c -> [Named c]
putTermset :: CTermset c => [Named c] -> c
needTermset :: CTermset c => c -> Ab [Named c]
class PrimContent c => CRel c where needRel = need isRel getRel
isRel :: CRel c => c -> Bool
getRel :: CRel c => c -> Rel c
putRel :: CRel c => Rel c -> c
needRel :: CRel c => c -> Ab (Rel c)
putTextList :: (CText c, CList c) => [String] -> c
putTextSet :: (CText c, CSet c) => [String] -> c


-- | Literalizer: Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal.Literal

-- | Transform <a>TokenTree</a> to something.
type Literalize a = TokenTree -> Ab a

-- | Transform list of <a>TokenTree</a> to something.
type LitTrees a = [TokenTree] -> Ab a
type LitOperators c = [Named (Literalize c -> LitTrees c)]

-- | Transform <a>TokenTree</a> into internal form of content.
litContentBy :: CContent c => LitOperators c -> Literalize c

-- | Collect term name and content.
litTermset :: CContent c => Literalize c -> LitTrees [Named c]

-- | Read list of termname and its content.
--   
--   <pre>
--   &gt;&gt;&gt; litNamedTrees . B.tokenTrees . B.tokens $ "/a 'A3 /b 10"
--   Right [("/a", TreeB 1 [TreeL (TWord 3 0 "'"), TreeL (TWord 4 0 "A3")]),
--          ("/b", TreeL (TWord 8 0 "10"))]
--   </pre>
litNamedTrees :: LitTrees [Named TokenTree]


-- | Extensions of literalizer
module Koshucode.Baala.Core.Content.Literal.Extension
litContent :: CContent c => Literalize c
litOperators :: CContent c => LitOperators c
litJudge :: CContent c => Bool -> JudgePattern -> LitTrees (Judge c)


-- | Term content
module Koshucode.Baala.Core.Content.Literal


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Cox

-- | Content expressions with source code.
type Cox c = Sourced (CoxCore c)

-- | Content expressions.
data CoxCore c

-- | Literal content
CoxLit :: c -> CoxCore c

-- | Operator invocation
CoxApp :: (CopFun c) -> [Cox c] -> CoxCore c

-- | Term reference, its name and position
CoxTerm :: [Termname] -> [Int] -> CoxCore c

-- | Term-content operator.
data Cop c

-- | Function
CopFun :: String -> (CopFun c) -> Cop c

-- | Syntax
CopSyn :: String -> (CopSyn) -> Cop c
type CopFun c = [c] -> Ab c
type CopSyn = CopFun TokenTree
type CoxCons c = Relhead -> Ab (Cox c)

-- | Construct content expressions from token tree.
coxCons :: CContent c => ([Cop c], [Named InfixHeight]) -> TokenTree -> Ab (CoxCons c)

-- | Calculate content expression.
coxRun :: (CRel c, CList c) => Relhead -> [c] -> CoxCons c -> Ab c
instance Name (Cop c)
instance Show (Cop c)


-- | Term content
module Koshucode.Baala.Core.Content


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator
data Rop c
Rop :: String -> String -> RopFullSorter -> RopCons c -> String -> Rop c

-- | Operator name
ropName :: Rop c -> String

-- | Operator group
ropGroup :: Rop c -> String

-- | Operand sorter
ropSorter :: Rop c -> RopFullSorter

-- | Constructor of operator
ropCons :: Rop c -> RopCons c

-- | Usage of operator
ropUsage :: Rop c -> String

-- | Use of relmap operator
data RopUse c
RopUse :: Global c -> HalfRelmap -> [Relmap c] -> RopUse c
ropGlobal :: RopUse c -> Global c

-- | Syntactic data of operator use
ropHalf :: RopUse c -> HalfRelmap

-- | Subrelmaps
ropSubrelmap :: RopUse c -> [Relmap c]

-- | Constructor of relmap operator
type RopCons c = RopUse c -> Ab (Relmap c)

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator.
data Relmap c

-- | Retrieve a relation from a dataset
RelmapSource :: HalfRelmap -> JudgePattern -> [Termname] -> Relmap c

-- | Constant relation
RelmapConst :: HalfRelmap -> (Rel c) -> Relmap c

-- | Equavalent relmap
RelmapAlias :: HalfRelmap -> (Relmap c) -> Relmap c

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> (RelkitConfl c) -> [Relmap c] -> Relmap c

-- | Relmap that maps relations to a relation
RelmapGlobal :: HalfRelmap -> (Global c -> RelkitCalc c) -> Relmap c

-- | Connect two relmaps
RelmapAppend :: (Relmap c) -> (Relmap c) -> Relmap c

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap c

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitCalc c = Relhead -> Ab (Relkit c)

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> Relhead -> Ab (Relkit c)

-- | Make <a>Relkit</a> from subrelmaps and input heading.
type RelkitConfl c = [(Relkit c)] -> Relhead -> Ab (Relkit c)

-- | Make <a>Relkit</a> from globals and input heading.
type RelkitGlobal c = Global c -> Relhead -> Ab (Relkit c)
data Global c
Global :: Version -> [Rop c] -> ([Cop c], [Named InfixHeight]) -> (TokenTree -> Ab (CoxCons c)) -> String -> [String] -> [Judge c] -> RelSelect c -> Global c
globalVersion :: Global c -> Version
globalRops :: Global c -> [Rop c]
globalCops :: Global c -> ([Cop c], [Named InfixHeight])
globalCoxCons :: Global c -> TokenTree -> Ab (CoxCons c)
globalProgram :: Global c -> String
globalArgs :: Global c -> [String]
globalJudges :: Global c -> [Judge c]
globalSelect :: Global c -> RelSelect c

-- | Relation selector
type RelSelect c = JudgePattern -> [String] -> Rel c
globalCommandLine :: Global c -> [String]
globalFill :: CContent c => Map (Global c)
global :: Global c
instance Show (RopUse c)
instance Show (Global c)
instance TokenListing (Relmap c)
instance Pretty (Relmap c)
instance Name (Relmap c)
instance Monoid (Relmap c)
instance Show (Relmap c)
instance TokenListing (RopUse c)
instance Show (Rop c)


-- | <tt>Relmap</tt> construction.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make half and full relmap constructors.
relmapCons :: Global c -> (RelmapCons c)

-- | Half and full relmap constructor
data RelmapCons c
RelmapCons :: RelmapConsHalf -> (RelmapConsFull c) -> RelmapCons c

-- | First step of constructing relmap, make <a>HalfRelmap</a> from use of
--   relmap operator.
type RelmapConsHalf = [TokenTree] -> Ab HalfRelmap

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>HalfRelmap</a>.
type RelmapConsFull c = HalfRelmap -> Ab (Relmap c)
instance Show (RelmapCons c)


-- | Data structures for relation-to-relation mappings
module Koshucode.Baala.Core.Relmap.Relmap

-- | Retrieve relation from dataset.
relmapSource :: RopUse c -> JudgePattern -> [Termname] -> (Relmap c)

-- | Constant relmap.
relmapConst :: RopUse c -> Rel c -> Relmap c

-- | Alias for relmap.
relmapAlias :: RopUse c -> Relmap c -> Relmap c

-- | Make a non-confluent relmap.
relmapCalc :: RopUse c -> RelkitCalc c -> Relmap c
relmapBinary :: RopUse c -> RelkitBinary c -> Relmap c -> Relmap c

-- | Make a confluent relmap.
relmapConfl :: RopUse c -> RelkitConfl c -> [Relmap c] -> Relmap c
relmapGlobal :: RopUse c -> RelkitGlobal c -> Relmap c

-- | List of <tt>RelmapSource</tt>
relmapSourceList :: Relmap c -> [Relmap c]

-- | List of name in <tt>RelmapName</tt>
relmapNameList :: Relmap c -> [String]

-- | Link relmaps by its name.
relmapLinker :: [Named (Relmap c)] -> Relmap c -> Relmap c


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Assertion of affirming or denying relation. It consists of logical
--   quality, relsign, and relmap.
--   
--   See also <a>Judge</a>
data Assert c
Assert :: AssertType -> JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c

-- | Logical quality
assertType :: Assert c -> AssertType

-- | Pattern of judgement
assertPattern :: Assert c -> JudgePattern

-- | Assert option
assertOption :: Assert c -> AssertOption

-- | Relmap
assertRelmap :: Assert c -> Relmap c

-- | Source code information
assertSource :: Assert c -> [Token]

-- | Option for assertions.
type AssertOption = [Named [TokenTree]]

-- | Apply function to relamp in assert.
assertMap :: Map (Relmap c) -> Map (Assert c)
isViolateAssert :: Assert c -> Bool
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertQuality :: AssertType -> Bool

-- | Make affirmed assertion.
affirm :: JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c

-- | Make denied assertion.
deny :: JudgePattern -> AssertOption -> Relmap c -> [Token] -> Assert c
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType
instance Show (Assert c)
instance Pretty (Assert c)
instance TokenListing (Assert c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges
emptyDataset :: Dataset c

-- | Gather judges into a dataset
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
addJudges :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CNil</tt> sign is used.
selectRelation :: (Ord c, CNil c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, CNil c) => Global c -> [Assert c] -> Ab [Judge c]

-- | Calculate assertion list.
runAssertDataset :: (Ord c, CNil c) => Global c -> [Assert c] -> Dataset c -> Ab [Judge c]


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Assert


-- | Intermidiate structure between <a>String</a> and <tt>Section</tt>.
module Koshucode.Baala.Core.Section.Clause
data Clause
Clause :: TokenClause -> ClauseBody -> Clause
clauseSource :: Clause -> TokenClause
clauseBody :: Clause -> ClauseBody
data ClauseBody

-- | Letter name
CLetter :: (Maybe String) -> ClauseBody

-- | Section name
CSection :: (Maybe String) -> ClauseBody

-- | Importing section name
CImport :: [Token] -> (Maybe Clause) -> ClauseBody

-- | Exporting relmap name
CExport :: String -> ClauseBody

-- | Short signs
CShort :: (Named String) -> ClauseBody

-- | Relmap and its name
CRelmap :: String -> HalfRelmap -> ClauseBody

-- | Not include HalfRelmap
TRelmap :: String -> [Token] -> ClauseBody

-- | Assertions of relmaps
CAssert :: AssertType -> JudgePattern -> AssertOption -> HalfRelmap -> ClauseBody

-- | Not include HalfRelmap
TAssert :: AssertType -> JudgePattern -> AssertOption -> [Token] -> ClauseBody

-- | Judge
CJudge :: Bool -> JudgePattern -> [Token] -> ClauseBody

-- | Clause comment
CComment :: ClauseBody

-- | Unknown clause
CUnknown :: ClauseBody

-- | Unresolved short sign
CUnres :: [Token] -> ClauseBody

-- | Name of clause type. e.g., <tt>"Relmap"</tt>, <tt>"Assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <a>TRelmap</a> and <a>TAssert</a> are contained. This function does
--   not depend on <a>RelmapConsHalf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [ TRelmap ( TokenClause
--                [TWord 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TWord 1 0 "a", ...]] )
--            "a" [ TWord 5 0 "source"
--                , TWord 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
consPreclause :: [TokenLine] -> [Clause]

-- | Construct <a>Clause</a> list from <a>Token</a> list. This is a first
--   step of constructing <tt>Section</tt>.
consClause :: RelmapConsHalf -> [TokenLine] -> Ab [Clause]
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause


-- | Data structure for relational calculations. There are three types of
--   section: (1) <i>editing sections</i> that output judges and read other
--   sections, (2) <i>library sections</i> that make relmaps reusable, (3)
--   <i>data sections</i> that provide data.
module Koshucode.Baala.Core.Section.Section
data Section c
Section :: Maybe String -> [Section c] -> [String] -> [Named String] -> [Assert c] -> [Named (Relmap c)] -> [Judge c] -> [Judge c] -> Resource -> RelmapCons c -> Section c

-- | Section name
sectionName :: Section c -> Maybe String

-- | Importing section
sectionImport :: Section c -> [Section c]

-- | Exporting relmap names
sectionExport :: Section c -> [String]

-- | Prefix for short signs
sectionShort :: Section c -> [Named String]

-- | Assertions of relmaps
sectionAssert :: Section c -> [Assert c]

-- | Relmaps and its name
sectionRelmap :: Section c -> [Named (Relmap c)]

-- | Affirmative or denial judgements
sectionJudge :: Section c -> [Judge c]

-- | Violated judgements, i.e., result of <tt>|=V</tt>
sectionViolate :: Section c -> [Judge c]

-- | Resource name
sectionResource :: Section c -> Resource

-- | Relmap constructor for this section
sectionCons :: Section c -> RelmapCons c

-- | Make empty section that has a given constructor.
makeEmptySection :: RelmapCons c -> Section c

-- | Section that has no contents.
emptySection :: Section c

-- | Second step of constructing <a>Section</a>.
consSection :: CContent c => RelmapConsFull c -> Resource -> [Clause] -> Ab (Section c)
instance Show c => Show (Section c)
instance Monoid (Section c)
instance (Ord c, Pretty c) => Pretty (Section c)


-- | Read, run, and write sections.
module Koshucode.Baala.Core.Section.Process

-- | Read section from certain resource.
readSection :: CContent c => Section c -> Resource -> IO (Ab (Section c))

-- | Read section from text.
readSectionText :: CContent c => Section c -> String -> Ab (Section c)

-- | Read judges from text.
readJudges :: CContent c => String -> Ab [Judge c]

-- | Select assertions like <tt>sectionAssert</tt>. It returns relmap-liked
--   assertions. We can run these assertions using <a>runAssertJudges</a>.
sectionLinkedAssert :: Section c -> ([Assert c], [Assert c])

module Koshucode.Baala.Core.Section.Bundle

-- | Bundle of section resources.
data SectionBundle c
SectionBundle :: Section c -> [String] -> [FilePath] -> [String] -> SectionBundle c
bundleRoot :: SectionBundle c -> Section c
bundleTexts :: SectionBundle c -> [String]
bundleFiles :: SectionBundle c -> [FilePath]
bundleURLs :: SectionBundle c -> [String]
readSectionBundle :: CContent c => SectionBundle c -> IO [Ab (Section c)]
instance Show c => Show (SectionBundle c)

module Koshucode.Baala.Core.Section.Letter
data Letter c
Letter :: Maybe String -> [Section c] -> Letter c
letterName :: Letter c -> Maybe String
letterSections :: Letter c -> [Section c]
appendSection :: Letter c -> Section c -> Letter c
appendSections :: Letter c -> [Section c] -> Letter c
runLetter :: CContent c => Global c -> AbMap (Letter c)
hPutLetter :: (CContent c, Pretty c) => Handle -> Letter c -> IO Int
instance Show c => Show (Letter c)

module Koshucode.Baala.Core.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapConsHalf -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Section

module Koshucode.Baala.Core
