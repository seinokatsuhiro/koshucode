-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.70.0.0

module Koshucode.Baala.Core.Message
abAssert :: CodePtr cp => [cp] -> Map (Ab b)
abAttr :: CodePtr cp => [cp] -> Map (Ab b)
abAttrTrees :: TokenTreesTo (Map (Ab b))
abClause :: CodePtr cp => [cp] -> Map (Ab b)
abCoxBuild :: TokenTreeTo (Map (Ab b))
abCoxCalc :: CodePtr cp => [cp] -> Map (Ab b)
abCoxFill :: CodePtr cp => [cp] -> Map (Ab b)
abCoxIrrep :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPosition :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPrefix :: TokenTreeTo (Map (Ab b))
abCoxReduce :: CodePtr cp => [cp] -> Map (Ab b)
abCoxSyntax :: TokenTreeTo (Map (Ab b))
abLexmap :: TokenTreesTo (Map (Ab b))
abLiteral :: TokenTreeTo (Map (Ab b))
abRelmap :: CodePtr cp => [cp] -> Map (Ab b)
abRun :: CodePtr cp => [cp] -> Map (Ab b)
abShort :: CodePtr cp => [cp] -> Map (Ab b)
abSlot :: CodePtr cp => [cp] -> Map (Ab b)
abSlotTree :: TokenTreeTo (Map (Ab b))
abSpecialize :: CodePtr cp => [cp] -> Map (Ab b)

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Unexpected attribute / Duplicate
dupAttr :: [String] -> Ab a

-- | Duplicate prefix
dupPrefix :: [String] -> Ab a

-- | Duplicate replacement
dupReplacement :: [String] -> Ab a

-- | Empty literal
emptyLiteral :: Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | Invalid prefix character
invalidPrefix :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | File not found
noFile :: String -> Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown clause
unkClause :: Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown nested relation
unkNestRel :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown relmap operator
unkRelmap :: String -> Ab a

-- | Unknown object
unkShow :: Show x => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Relhead -> Ab a
unkWithVar :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a
unmatchType :: String -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a

-- | Unresolved prefix
unresPrefix :: Ab a
detailTermRel :: String -> [String] -> Relhead -> [String]

module Koshucode.Baala.Core.Content.Class
class Show c => PrimContent c
typename :: PrimContent c => c -> String
class (Ord c, Write c, PrimContent c, CBool c, CText c, CTerm c, CDec c, CList c, CEmpty c, CSet c, CAssn c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
class PrimContent c => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: CBool c => c
false :: CBool c => c
class PrimContent c => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
class PrimContent c => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Types that can be empty
class PrimContent c => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c
class PrimContent c => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pDecFromInt :: CDec c => Int -> c
class PrimContent c => CTerm c where getTerm = getAbAb isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c
class PrimContent c => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
class PrimContent c => CAssn c where getAssn = getAbAb isAssn gAssn putAssn = Right . pAssn
isAssn :: CAssn c => c -> Bool
gAssn :: CAssn c => c -> [Named c]
pAssn :: CAssn c => [Named c] -> c
getAssn :: CAssn c => Ab c -> Ab [Named c]
putAssn :: CAssn c => [Named c] -> Ab c
class PrimContent c => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Cox

-- | Content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Base function
CoxBase :: [CodePt] -> (Cop c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> (Maybe String) -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> (Maybe String) -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c
type CoxAssn c = (BlankName, Cox c)
type NamedCox c = Named (Cox c)
coxSyntacticArity :: Cox c -> Int
isCoxBase :: Cox c -> Bool
isCoxForm :: Cox c -> Bool
coxMap :: Map (Map (Cox c))
coxCall :: Cox c -> (Map (Cox c)) -> Cox c
checkIrreducible :: AbMap (Cox c)

-- | Content operator.
data Cop c

-- | Convert contents
CopFun :: BlankName -> (CopFun c) -> Cop c

-- | Convert coxes
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert trees
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Base and derived operators.
type CopBundle c = ([Cop c], [NamedCox c])

-- | Base function.
type CopFun c = [Ab c] -> Ab c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TokenTree] -> Ab TokenTree
copName :: Cop c -> BlankName

-- | Non-binary operator.
copNormal :: String -> BlankName
copInternal :: String -> BlankName

-- | Convert operator name to prefix name.
copPrefix :: String -> BlankName

-- | Convert operator name to infix name.
copInfix :: String -> BlankName

-- | Convert operator name to postfix name.
copPostfix :: String -> BlankName
isCopFunction :: Cop c -> Bool
isCopSyntax :: Cop c -> Bool
instance Name (Cop c)
instance Show (Cop c)
instance Write c => Write (Cox c)
instance Write c => Show (Cox c)
instance CodePtr (Cox c)


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Run
type RunCox c = Cox c -> Ab c
type RunList c = [c] -> Ab c
coxRunCox :: (Write c, CRel c, CList c) => CopBundle c -> Relhead -> [c] -> RunCox c
coxRunList :: (Write c, CRel c, CList c) => CopBundle c -> Relhead -> Cox c -> RunList c
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)
instance CodePtr (Beta c)


-- | Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal
type CalcContent c = TokenTreeToAb c

-- | Convert <a>TokenTree</a> into internal form of content.
literal :: CContent c => CalcContent c -> TokenTreeToAb c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of sections.
getJudge :: CContent c => CalcContent c -> Char -> JudgePat -> TokenTreesToAb (Judge c)

-- | Convert token trees into a list of named token trees.
getTermedTrees :: TokenTreesToAb [NamedTree]


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Build
type CoxSyntax c = ([Cop c], [Named InfixHeight])

-- | Construct content expression from token tree
coxBuild :: CContent c => CalcContent c -> CoxSyntax c -> TokenTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> Maybe String -> [String] -> Map (Cox c)


-- | Attributes of relmap operator.
module Koshucode.Baala.Core.Lexmap.Attribute
data AttrName
AttrTree :: String -> AttrName
AttrRelmap :: String -> AttrName

-- | Test attribute name is for relmap.
isAttrRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Constant for attribute name <tt>@attr</tt>.
attrNameAttr :: AttrName

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName

-- | Definition of attribute sorter.
data AttrDefine
AttrDefine :: AbMap AttrTrees -> AbMap AttrTrees -> [AttrName] -> [AttrName] -> AttrDefine
attrTrunkSorter :: AttrDefine -> AbMap AttrTrees
attrClassifier :: AttrDefine -> AbMap AttrTrees
attrTrunkNames :: AttrDefine -> [AttrName]
attrBranchNames :: AttrDefine -> [AttrName]

-- | List of attribute name and its contents.
type AttrTrees = [(AttrName, [TokenTree])]

-- | Sorter for attribute of relmap operator. Sorters docompose attribute
--   trees, and give a name to subattribute.
type AttrSort = [TokenTree] -> Ab AttrTrees
type TreeSort = [TokenTree] -> [NamedTrees]

-- | Name of relmap operator.
type RopName = String

-- | Association of operator use and something. Operator use is represented
--   as pair of operator name and attributes.
type Roal a = ((RopName, AttrTrees), a)
attrSort :: AttrDefine -> AttrSort
attrSortBranch :: AttrSort
hyphenAssc :: TreeSort
instance Typeable AttrName
instance Show AttrName
instance Eq AttrName
instance Ord AttrName
instance Data AttrName


-- | Slot substitution.
module Koshucode.Baala.Core.Lexmap.Slot
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> AttrTrees -> AbMap [TokenTree]


-- | Mapping from attributes to attributes, aka., attribute editor.
module Koshucode.Baala.Core.Lexmap.Roamap

-- | Roamap with source code information.
type Roamap = Sourced RoamapBody

-- | Roamap operators.
data RoamapBody

-- | Identity roamap.
RoamapId :: RoamapBody

-- | Add attribute.
RoamapAdd :: Bool -> String -> [TokenTree] -> RoamapBody

-- | Rename attribute keyword.
RoamapRename :: (String, String) -> RoamapBody

-- | Fill positional attributes.
RoamapFill :: [Maybe TokenTree] -> RoamapBody

-- | Append roamaps.
RoamapAppend :: [Roamap] -> RoamapBody

-- | Construct roamap.
roamapCons :: [TokenTree] -> Ab Roamap

-- | Run roamap.
roamapRun :: Roamap -> AbMap AttrTrees
instance Typeable RoamapBody
instance Show RoamapBody
instance Eq RoamapBody
instance Ord RoamapBody
instance Data RoamapBody


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap.Lexmap

-- | Intermediate data that represents use of relmap operator. Lexmap is
--   constructed from a list of <a>TokenTree</a>, and generic relmap is
--   constructed from a lexmap.
data Lexmap
Lexmap :: LexmapType -> Token -> AttrTrees -> [Lexmap] -> [String] -> Lexmap

-- | Type of lexmap
lexType :: Lexmap -> LexmapType

-- | Token of operator
lexOpToken :: Lexmap -> Token

-- | Attribute of relmap operation
lexAttr :: Lexmap -> AttrTrees

-- | Submaps in the attribute
lexSubmap :: Lexmap -> [Lexmap]

-- | Messages on lexmap
lexMessage :: Lexmap -> [String]
data LexmapType

-- | Built-in relmap
LexmapBase :: LexmapType

-- | User-defined relmap
LexmapDerived :: LexmapType

-- | <tt>-with</tt> variable
LexmapWith :: LexmapType

-- | Name of relmap operator
lexOpName :: Lexmap -> RopName
lexAddMessage :: String -> Map Lexmap
lexMessageList :: Lexmap -> [String]

-- | First step of constructing relmap, make lexmap from source of relmap
--   operator.
type ConsLexmap = [GlobalSlot] -> [RelmapSource] -> ConsLexmapBody

-- | Construct lexmap and its submaps from source of lexmap
type ConsLexmapBody = [TokenTree] -> Ab (Lexmap, [Roal Lexmap])

-- | Source of relmap: its name, replacement, and attribute editor.
type RelmapSource = Named ([TokenTree], Roamap)
consLexmap :: [Named AttrSort] -> ConsLexmap

-- | Parse <tt>-with</tt> attribute.
withTerms :: [TokenTree] -> Ab [Terminal String]
instance Typeable LexmapType
instance Typeable Lexmap
instance Show LexmapType
instance Eq LexmapType
instance Ord LexmapType
instance Data LexmapType
instance Show Lexmap
instance Eq Lexmap
instance Ord Lexmap
instance Data Lexmap
instance CodePtr Lexmap
instance Write Lexmap


-- | Attribute sorters.
module Koshucode.Baala.Core.Lexmap.Sorter

-- | Attribute sorter for no-attribute trunk.
roaNone :: [AttrName] -> AttrDefine

-- | Attribute sorter for enumerating trunk, i.e., <tt>-1</tt>,
--   <tt>-2</tt>, ...
roaEnum :: [AttrName] -> [AttrName] -> AttrDefine

-- | Attribute sorter for multiple-attribute trunk.
roaList :: AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for one-and-multiple-attribute trunk.
roaOneList :: AttrName -> AttrName -> [AttrName] -> AttrDefine
roaOneOpt :: AttrName -> AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for one-attribute trunk.
roaOne :: AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for two-attribute trunk.
roaTwo :: AttrName -> AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for three-attribute trunk.
roaThree :: AttrName -> AttrName -> AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for four-attribute trunk.
roaFour :: AttrName -> AttrName -> AttrName -> AttrName -> [AttrName] -> AttrDefine
roaTermsOne :: AttrName -> AttrName -> [AttrName] -> AttrDefine
roaTermsTwo :: AttrName -> AttrName -> AttrName -> [AttrName] -> AttrDefine

module Koshucode.Baala.Core.Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relmap.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Relhead -> RelkitBody c -> Relkit c
relkitHead :: Relkit c -> Maybe Relhead
relkitBody :: Relkit c -> RelkitBody c
data RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitAbFull :: Bool -> ([Relbmap c] -> [[c]] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([Relbmap c] -> [c] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([Relbmap c] -> [c] -> Ab [c]) -> [RelkitBody c] -> RelkitCore c
RelkitAbSemi :: ([[c]] -> Ab Bool) -> (RelkitBody c) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitId :: RelkitCore c
RelkitSource :: String -> [TermName] -> RelkitCore c
RelkitLink :: String -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c
RelkitNest :: String -> RelkitCore c
RelkitCopy :: String -> (RelkitBody c) -> RelkitCore c
RelkitWith :: [(String, Int)] -> (RelkitBody c) -> RelkitCore c
type RelkitBody c = Sourced (RelkitCore c)
type RelkitKey = (Maybe Relhead, [Lexmap])
type RelkitDef c = (RelkitKey, Relkit c)

-- | Mapping for body of relation.
type Relbmap c = [[c]] -> Ab [[c]]

-- | Relation selector
type RelSelect c = JudgePat -> [String] -> Rel c
relkit :: Maybe Relhead -> RelkitCore c -> Relkit c
relkitJust :: Relhead -> RelkitCore c -> Relkit c
relkitNothing :: Relkit c
relkitId :: Maybe Relhead -> Relkit c
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [TermName] -> Relkit c
relkitConstSingleton :: [TermName] -> [c] -> Relkit c
relkitConstBody :: [TermName] -> [[c]] -> Relkit c
relkitSource :: JudgePat -> [TermName] -> Relkit c
relkitCopy :: String -> Map (Relkit c)
relkitWith :: [(String, Int)] -> Map (Relkit c)
relkitWithVar :: String -> Relhead -> Relkit c
relkitSetSource :: CodePtr a => a -> Map (Relkit c)
instance Show (RelkitCore c)
instance Monoid (Relkit c)


-- | Term content
module Koshucode.Baala.Core.Content


-- | Convert relation to text table.
module Koshucode.Baala.Core.Assert.RelTable
relTable :: (Write c, CRel c) => [ShortDef] -> Rel c -> String
relTableLines :: (Write c, CRel c) => [ShortDef] -> Rel c -> [String]
relText :: (Write c, CRel c) => [ShortDef] -> Rel c -> RelText


-- | Global parameters.
module Koshucode.Baala.Core.Relmap.Global
data GlobalWith rop c
Global :: Version -> [rop c] -> ([Cop c], [Named InfixHeight]) -> String -> [String] -> [Judge c] -> RelSelect c -> GlobalWith rop c
globalVersion :: GlobalWith rop c -> Version
globalRops :: GlobalWith rop c -> [rop c]
globalCops :: GlobalWith rop c -> ([Cop c], [Named InfixHeight])
globalProgram :: GlobalWith rop c -> String
globalArgs :: GlobalWith rop c -> [String]
globalJudges :: GlobalWith rop c -> [Judge c]
globalSelect :: GlobalWith rop c -> RelSelect c
globalCommandLine :: GlobalWith rop c -> [String]
globalFill :: CContent c => Map (GlobalWith rop c)
global :: GlobalWith rop c
globalSyntax :: GlobalWith rop c -> CoxSyntax c
globalFunction :: GlobalWith rop c -> [Cop c]
instance Show (GlobalWith rop c)


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Operator

-- | Global parameters
type Global c = GlobalWith Rop c
type RopUsage = String

-- | Implementation of relmap operator
data Rop c
Rop :: RopName -> String -> AttrSort -> RopCons c -> RopUsage -> Rop c

-- | Operator name
ropName :: Rop c -> RopName

-- | Operator group
ropGroup :: Rop c -> String

-- | Attribute sorter
ropSorter :: Rop c -> AttrSort

-- | Constructor of operator
ropCons :: Rop c -> RopCons c

-- | Usage of operator
ropUsage :: Rop c -> RopUsage

-- | Constructor of relmap operator
type RopCons c = RopUse c -> Ab (Relmap c)

-- | Use of relmap operator
data RopUse c
RopUse :: Global c -> Lexmap -> [Relmap c] -> RopUse c
ropGlobal :: RopUse c -> Global c

-- | Syntactic data of operator use
ropLexmap :: RopUse c -> Lexmap

-- | Subrelmaps
ropSubrelmap :: RopUse c -> [Relmap c]

-- | Generic relmap.
data Relmap c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgePat -> [TermName] -> Relmap c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap c

-- | Relmap that maps relations to a relation with globals
RelmapGlobal :: Lexmap -> (RelkitGlobal c) -> Relmap c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap c] -> Relmap c

-- | Relmap for environment of input relation
RelmapCopy :: Lexmap -> String -> (Relmap c) -> Relmap c

-- | Relmap for environment of nested relations
RelmapWith :: Lexmap -> [Terminal String] -> (Relmap c) -> Relmap c

-- | Relmap reference
RelmapLink :: Lexmap -> String -> AttrTrees -> Relmap c

-- | Connect two relmaps
RelmapAppend :: (Relmap c) -> (Relmap c) -> Relmap c

-- | Identity relmap.
relmapId :: Relmap c
relmapLexList :: Relmap c -> [Lexmap]

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitFlow c = Maybe Relhead -> Ab (Relkit c)

-- | Make <a>Relkit</a> from globals and input heading.
type RelkitGlobal c = Global c -> RelkitFlow c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitFlow c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [(Relkit c)] -> RelkitFlow c
instance Show (RopUse c)
instance Eq (Relmap c)
instance Ord (Relmap c)
instance CodePtr (Relmap c)
instance Write (Relmap c)
instance Name (Relmap c)
instance Monoid (Relmap c)
instance Show (Relmap c)
instance CodePtr (RopUse c)
instance Show (Rop c)


-- | Operations on <a>Relmap</a>.
module Koshucode.Baala.Core.Relmap.Construct

-- | Constructor of lexmap and relmap.
data RelmapCons c
RelmapCons :: ConsLexmap -> (ConsRelmap c) -> RelmapCons c

-- | Second step of constructing relmap, make relmap from lexmap.
type ConsRelmap c = Lexmap -> Ab (Relmap c)

-- | Make a constructor pair of lexmap and relmap.
relmapCons :: Global c -> RelmapCons c

-- | Retrieve relation from dataset.
relmapSource :: RopUse c -> JudgePat -> [TermName] -> (Relmap c)

-- | Make a constant relmap.
relmapConst :: RopUse c -> Rel c -> Relmap c

-- | Make a flow relmap. Flow relmaps take no subrelmaps.
relmapFlow :: RopUse c -> RelkitFlow c -> Relmap c

-- | Make a global relmap. Global relmaps are flow relmaps with globals.
relmapGlobal :: RopUse c -> RelkitGlobal c -> Relmap c

-- | Make a binary relmap. Binary relmaps take one subrelmap.
relmapBinary :: RopUse c -> RelkitBinary c -> Relmap c -> Relmap c

-- | Make a confluent relmap. Confluent relmaps take multiple subrelmaps.
relmapConfl :: RopUse c -> RelkitConfl c -> [Relmap c] -> Relmap c
relmapCopy :: RopUse c -> String -> Map (Relmap c)
relmapWith :: RopUse c -> [Terminal String] -> Map (Relmap c)
relmapWithVar :: RopUse c -> String -> Relmap c
relmapLink :: RopUse c -> String -> AttrTrees -> Relmap c

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap c -> [Relmap c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap c -> [String]
instance Show (RelmapCons c)


-- | Specialize generic relmaps to specific relmaps
module Koshucode.Baala.Core.Relmap.Specialize
relmapSpecialize :: Global c -> [Roal (Relmap c)] -> [RelkitDef c] -> Maybe Relhead -> Relmap c -> Ab ([RelkitDef c], Relkit c)


-- | Link and run relmaps.
module Koshucode.Baala.Core.Relmap.Run
relkitLink :: Ord c => [RelkitDef c] -> Map (Relkit c)
relkitRun :: (Ord c, CRel c) => Global c -> [Named [[c]]] -> RelkitBody c -> AbMap [[c]]
fixedRelation :: Ord c => Map (AbMap [[c]])
bmapAlign :: Relhead -> Relhead -> Map (AbMap [[c]])


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert c
Assert :: AssertType -> JudgePat -> AssertOption -> [Token] -> [TokenTree] -> Maybe (Relmap c) -> [Roal (Relmap c)] -> Assert c

-- | Logical quality
assType :: Assert c -> AssertType

-- | Pattern of judgement
assPattern :: Assert c -> JudgePat

-- | Assert option
assOption :: Assert c -> AssertOption

-- | Source token list
assToken :: Assert c -> [Token]

-- | Token relmap
assTree :: Assert c -> [TokenTree]

-- | Relmap
assRelmap :: Assert c -> Maybe (Relmap c)
assParts :: Assert c -> [Roal (Relmap c)]
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType

-- | Option for assertions.
type AssertOption = [NamedTrees]
assertAs :: AssertType -> JudgeOf c

-- | Assertion list with short signs.
type ShortAssert c = Short [Assert c]

-- | Select affirmative or denial assertions.
assertNormal :: Map [ShortAssert c]

-- | Select violated assertions.
assertViolated :: Map [ShortAssert c]
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType
instance Show (Assert c)
instance Write (Assert c)
instance CodePtr (Assert c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges.
emptyDataset :: Dataset c

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
addJudges :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CEmpty</tt> sign is used.
selectRelation :: (Ord c, CEmpty c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, Write c, CRel c, CEmpty c) => Global c -> ShortAssert c -> Ab (OutputChunks c)


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Intermidiate structure between <a>String</a> and <tt>Section</tt>.
module Koshucode.Baala.Core.Section.Clause
type ShortClause = Short [Clause]
data Clause
Clause :: TokenClause -> ClauseBody -> Clause
clauseSource :: Clause -> TokenClause
clauseBody :: Clause -> ClauseBody
data ClauseBody

-- | Section name
CSection :: (Maybe String) -> ClauseBody

-- | Importing section name
CImport :: [Token] -> (Maybe Clause) -> ClauseBody

-- | Exporting relmap name
CExport :: String -> ClauseBody

-- | Short signs
CShort :: [ShortDef] -> ClauseBody

-- | Source of relmap
CRelmap :: String -> [Token] -> ClauseBody

-- | (Intermediate data)
CAssert :: AssertType -> JudgePat -> [Token] -> [Token] -> ClauseBody

-- | Judge
CJudge :: Char -> JudgePat -> [Token] -> ClauseBody

-- | Global slot
CSlot :: String -> [Token] -> ClauseBody

-- | Clause comment
CComment :: ClauseBody

-- | Unknown clause
CUnknown :: ClauseBody

-- | Unresolved short sign
CUnres :: [Token] -> ClauseBody

-- | Name of clause type. e.g., <tt>"Relmap"</tt>, <tt>"Assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <tt>TTokmap</tt> and <a>CAssert</a> are contained. This function does
--   not depend on <a>ConsLexmap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [ TTokmap ( TokenClause
--                [TText 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TText 1 0 "a", ...]] )
--            "a" [ TText 5 0 "source"
--                , TText 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
--   
--   First step of constructing <tt>Section</tt>.
consClause :: [TokenLine] -> [ShortClause]
consPreclause :: [TokenLine] -> [Clause]
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause
instance CodePtr Clause


-- | Section as bundle of relational expressions.
module Koshucode.Baala.Core.Section.Section
data Section c
Section :: Maybe String -> Global c -> [Section c] -> [String] -> [NamedTrees] -> [RelmapSource] -> [ShortAssert c] -> [Judge c] -> Resource -> RelmapCons c -> [String] -> Section c

-- | Section name
secName :: Section c -> Maybe String

-- | Global parameter
secGlobal :: Section c -> Global c

-- | Importing section
secImport :: Section c -> [Section c]

-- | Exporting relmap names
secExport :: Section c -> [String]

-- | Global slots
secSlot :: Section c -> [NamedTrees]

-- | Source of relmaps
secRelmap :: Section c -> [RelmapSource]

-- | Assertions of relmaps
secAssert :: Section c -> [ShortAssert c]

-- | Affirmative or denial judgements
secJudge :: Section c -> [Judge c]

-- | Resource name
secResource :: Section c -> Resource

-- | Relmap constructor for this section
secCons :: Section c -> RelmapCons c

-- | Collection of messages
secMessage :: Section c -> [String]
calcTreeUsing :: CContent c => Global c -> CalcContent c
coxTreeUsing :: CContent c => Global c -> TokenTreeToAb (Cox c)

-- | Section that has no contents.
emptySection :: Section c

-- | Second step of constructing <a>Section</a>.
consSection :: CContent c => Section c -> Resource -> [ShortClause] -> Ab (Section c)
rootSection :: Global c -> Section c
addMessage :: String -> Map (Section c)
addMessages :: [String] -> Map (Section c)
instance Show c => Show (Section c)
instance Monoid (Section c)

module Koshucode.Baala.Core.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: ConsLexmap -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Read section.
module Koshucode.Baala.Core.Section.Read

-- | Read section from certain resource.
readSection :: CContent c => Section c -> Resource -> IO (Ab (Section c))

-- | Read section from text.
readSectionText :: CContent c => Section c -> String -> Ab (Section c)

-- | Read judges from text.
readJudges :: CContent c => String -> Ab [Judge c]

module Koshucode.Baala.Core.Section.Bundle

-- | Bundle of section resources.
data SectionBundle c
SectionBundle :: Section c -> [String] -> [FilePath] -> [String] -> SectionBundle c
bundleRoot :: SectionBundle c -> Section c
bundleTexts :: SectionBundle c -> [String]
bundleFiles :: SectionBundle c -> [FilePath]
bundleURLs :: SectionBundle c -> [String]
readSectionBundle :: CContent c => SectionBundle c -> IO [Ab (Section c)]
instance Show c => Show (SectionBundle c)


-- | Run section.
module Koshucode.Baala.Core.Section.Run
runSection :: CContent c => Global c -> [Section c] -> Ab (OutputResult c)


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Section

module Koshucode.Baala.Core
