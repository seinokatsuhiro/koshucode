-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.89.0.0

module Koshucode.Baala.Core.Message
abAssert :: CodePtr cp => [cp] -> Map (Ab b)
abAttr :: CodePtr cp => [cp] -> Map (Ab b)
abAttrTrees :: TTreesTo (Map (Ab b))
abClause :: CodePtr cp => [cp] -> Map (Ab b)
abCoxBuild :: TTreeTo (Map (Ab b))
abCoxCalc :: CodePtr cp => [cp] -> Map (Ab b)
abCoxFill :: CodePtr cp => [cp] -> Map (Ab b)
abCoxIrrep :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPosition :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPrefix :: TTreeTo (Map (Ab b))
abCoxReduce :: CodePtr cp => [cp] -> Map (Ab b)
abCoxSyntax :: TTreeTo (Map (Ab b))
abLexmap :: TTreesTo (Map (Ab b))
abLiteral :: TTreeTo (Map (Ab b))
abRelmap :: CodePtr cp => [cp] -> Map (Ab b)
abRun :: CodePtr cp => [cp] -> Map (Ab b)
abShort :: CodePtr cp => [cp] -> Map (Ab b)
abSlot :: CodePtr cp => [cp] -> Map (Ab b)
abSlotTree :: TTreeTo (Map (Ab b))
abSpecialize :: CodePtr cp => [cp] -> Map (Ab b)

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Ambiguous relmaps
ambRelmap :: String -> [d] -> Ab a

-- | Unexpected attribute / Duplicate
dupAttr :: [String] -> Ab a

-- | Duplicate prefix
dupPrefix :: [String] -> Ab a

-- | Duplicate replacement
dupReplacement :: [String] -> Ab a

-- | Empty literal
emptyLiteral :: Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | Invalid prefix character
invalidPrefix :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | File not found
noFile :: String -> Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require grouping paren
reqGroup :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown clause
unkClause :: Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown nested relation
unkNestRel :: String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown relmap operator
unkRelmap :: String -> Ab a

-- | Unknown object
unkShow :: Show x => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Head -> Ab a

-- | Unknown type name
unkType :: String -> Ab a
unkNestVar :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a
unmatchType :: String -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a

-- | Unresolved prefix
unresPrefix :: Ab a
detailTermRel :: String -> [String] -> Head -> [String]

module Koshucode.Baala.Core.Content.Class
class (Ord c, Write c, CTypeOf c, CEmpty c, CBool c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CAssn c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
class (Show c, Write c) => CTypeOf c
typeOf :: CTypeOf c => c -> Type
class CTypeOf c => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: CBool c => c
false :: CBool c => c
class CTypeOf c => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
class CTypeOf c => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Types that can be empty
class CTypeOf c => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c
maybeEmpty :: CEmpty c => (a -> c) -> Maybe a -> c
omitEmpty :: CEmpty c => Map [(a, c)]
class CTypeOf c => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pDecFromInt :: CDec c => Int -> c
pDecFromInteger :: CDec c => Integer -> c
class CTypeOf c => CClock c where getClock = getAbAb isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => Ab c -> Ab Clock
putClock :: CClock c => Clock -> Ab c
class CTypeOf c => CTime c where getTime = getAbAb isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => Ab c -> Ab Time
putTime :: CTime c => Time -> Ab c
class CTypeOf c => CTerm c where getTerm = getAbAb isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c
class CTypeOf c => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
class CTypeOf c => CAssn c where getAssn = getAbAb isAssn gAssn putAssn = Right . pAssn
isAssn :: CAssn c => c -> Bool
gAssn :: CAssn c => c -> [Named c]
pAssn :: CAssn c => [Named c] -> c
getAssn :: CAssn c => Ab c -> Ab [Named c]
putAssn :: CAssn c => [Named c] -> Ab c
class CTypeOf c => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool
class CTypeOf c => CInterp c where getInterp = getAbAb isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => Ab c -> Ab Interp
putInterp :: CInterp c => Interp -> Ab c
class CTypeOf c => CType c where getType = getAbAb isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => Ab c -> Ab Type
putType :: CType c => Type -> Ab c
contAp :: (c -> a) -> (b -> d) -> (a -> b) -> c -> d
contMap :: (c -> [a]) -> ([b] -> d) -> (a -> b) -> c -> d
contApTextToText :: CText c => Map String -> AbMap c
contMapTextToList :: (CList c, CText c) => (Char -> c) -> AbMap c


-- | Term-content expression.
module Koshucode.Baala.Core.Content.Cox

-- | Term-content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Content calculator
CoxCalc :: [CodePt] -> BlankName -> (CopCalc c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> CoxTag -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c
type MaybeCox c = Maybe (Cox c)
type NamedCox c = Named (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c
type CoxTag = Maybe String
coxLit :: c -> Cox c
coxSyntacticArity :: Cox c -> Int
coxMap :: Map (Map (Cox c))
coxCall :: Cox c -> (Map (Cox c)) -> Cox c
checkIrreducible :: AbMap (Cox c)
instance Write c => Write (Cox c)
instance Write c => Show (Cox c)
instance CodePtr (Cox c)


-- | Term-content operator.
module Koshucode.Baala.Core.Content.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TTree] -> Ab TTree
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
copsetCopList :: CopSet c -> [Cop c]
copsetInfixList :: CopSet c -> [Named InfixHeight]
copsetCalcList :: CopSet c -> [Named (Cop c)]
copsetCoxList :: CopSet c -> [Named (Cop c)]
copsetTreeList :: CopSet c -> [Named (Cop c)]
copsetFindCalc :: CopSet c -> CopFind (Cox c)
copsetFindCox :: CopSet c -> CopFind (CopCox c)
copsetFindTree :: CopSet c -> CopFind CopTree
copsetDerived :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Empty operator set.
copset :: CopSet c
copsetFill :: Map (CopSet c)
instance Name (Cop c)
instance Show (Cop c)


-- | Utilities for token trees.
module Koshucode.Baala.Core.Content.Tree
treesToTokens :: TTreesToAb [Token]
treesToTexts :: Bool -> TTreesToAb [String]
treeToText :: Bool -> TTreeToAb String
treesToDigits :: TTreesToAb String
tokenClock :: Token -> Ab Clock
treesToTime :: TTreesToAb Time

-- | Get flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
treeToFlatTerm :: TTreeToAb TermName

-- | Convert token trees into a list of named token trees.
treesToTerms :: TTreesToAb [NamedTrees]
treesToTerms1 :: TTreesToAb [NamedTree]
treesToInterp :: TTreesToAb Interp


-- | Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal

-- | Content calculator.
type CalcContent c = TTreeToAb c

-- | Convert token tree into internal form of content.
literal :: CContent c => CalcContent c -> TTreeToAb c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of resources.
treesToJudge :: CContent c => CalcContent c -> AssertType -> JudgePat -> TTreesToAb (Judge c)
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertAs :: AssertType -> JudgeOf c
assertSymbol :: AssertType -> String
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Build

-- | Construct content expression from token tree
coxBuild :: CContent c => CalcContent c -> CopSet c -> TTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Run
type RunCox c = Cox c -> Ab c
type RunList c = [c] -> Ab c
coxRunCox :: (Write c, CRel c, CList c) => CopSet c -> Head -> [c] -> RunCox c
coxRunList :: (Write c, CRel c, CList c) => CopSet c -> Head -> Cox c -> RunList c
calcContent :: CContent c => CopSet c -> CalcContent c
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)
instance CodePtr (Beta c)


-- | Attributes of relmap operator.
module Koshucode.Baala.Core.Lexmap.Attribute

-- | Attribute name for relmap operator.
data AttrName

-- | Normal attribute
AttrNameNormal :: String -> AttrName

-- | Attribute for subrelmap
AttrNameRelmap :: String -> AttrName

-- | Attribute for nested relation reference
AttrNameNest :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | Test attribute name is for nested relation reference.
isAttrNameNest :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Constant for attribute name <tt>@attr</tt>.
attrNameAttr :: AttrName

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName

-- | Definition of attribute sorter.
data AttrDefine
AttrDefine :: AbMap [AttrTree] -> AbMap [AttrTree] -> [AttrName] -> [AttrName] -> AttrDefine
attrTrunkSorter :: AttrDefine -> AbMap [AttrTree]
attrClassifier :: AttrDefine -> AbMap [AttrTree]
attrTrunkNames :: AttrDefine -> [AttrName]
attrBranchNames :: AttrDefine -> [AttrName]

-- | List of attribute name and its contents.
type AttrTree = (AttrName, [TTree])

-- | Sorter for attribute of relmap operator. Sorters docompose attribute
--   trees, and give a name to subattribute.
type AttrSort = [TTree] -> Ab [AttrTree]
type TreeSort = [TTree] -> [NamedTrees]

-- | Name of relmap operator.
type RopName = String
attrSort :: AttrDefine -> AttrSort
attrSortBranch :: AttrSort
hyphenAssc :: TreeSort
instance Typeable AttrName
instance Show AttrName
instance Eq AttrName
instance Ord AttrName
instance Data AttrName


-- | Slot substitution.
module Koshucode.Baala.Core.Lexmap.Slot
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [TTree]


-- | Attribute mapping, or attribute editor.
module Koshucode.Baala.Core.Lexmap.Attrmap

-- | Attribute mapping with source code information.
type Attrmap = Sourced AttrmapBody

-- | Operators for attribute mappings.
data AttrmapBody

-- | Identity mapping
AttrmapId :: AttrmapBody

-- | Add attribute
AttrmapAdd :: Bool -> String -> [TTree] -> AttrmapBody

-- | Rename attribute keyword
AttrmapRename :: (String, String) -> AttrmapBody

-- | Fill positional attributes
AttrmapFill :: [Maybe TTree] -> AttrmapBody

-- | Append mappings
AttrmapAppend :: [Attrmap] -> AttrmapBody

-- | Construct attribute mapping.
consAttrmap :: [TTree] -> Ab Attrmap

-- | Edit relmap attributes.
runAttrmap :: Attrmap -> AbMap [AttrTree]
instance Typeable AttrmapBody
instance Show AttrmapBody
instance Eq AttrmapBody
instance Ord AttrmapBody
instance Data AttrmapBody


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap.Lexmap

-- | Intermediate data that represents use of relmap operator. Lexmap is
--   constructed from a list of <a>TTree</a>, and generic relmap is
--   constructed from a lexmap.
data Lexmap
Lexmap :: LexmapType -> Token -> [AttrTree] -> [Lexmap] -> [String] -> Lexmap

-- | Type of lexmap
lexType :: Lexmap -> LexmapType

-- | Token of operator
lexRopToken :: Lexmap -> Token

-- | Attribute of relmap operation
lexAttr :: Lexmap -> [AttrTree]

-- | Submaps in the attribute
lexSubmap :: Lexmap -> [Lexmap]

-- | Messages on lexmap
lexMessage :: Lexmap -> [String]
data LexmapType

-- | Built-in relmap
LexmapBase :: LexmapType

-- | User-defined relmap
LexmapDerived :: LexmapType

-- | Nested relation reference
LexmapNest :: LexmapType

-- | Name of relmap operator
lexRopName :: Lexmap -> RopName
lexAddMessage :: String -> Map Lexmap
lexMessageList :: Lexmap -> [String]

-- | First step of constructing relmap, construct lexmap from token trees.
--   The function returns lexmap and related lexmap links.
consLexmap :: (RopName -> Maybe AttrSort) -> ConsLexmap

-- | Parse nested relation attribute.
nestTerms :: [TTree] -> Ab [Terminal RopName]
type ConsLexmap = [GlobalSlot] -> FindRelmap -> ConsLexmapBody
type ConsLexmapBody = SecNo -> [TTree] -> Ab (Lexmap, LexmapLinkTable)

-- | Section number.
type SecNo = Int
type FindRelmap = SecNo -> RopName -> [RelmapSource]
type LexmapLinkTable = [(Lexmap, Lexmap)]

-- | Source of relmap: its name, replacement, and attribute editor.
type RelmapSource = NNamed ([TTree], Attrmap)

-- | Numbered name.
type NName = (SecNo, String)

-- | Pair which key is a numbered name.
type NNamed a = (NName, a)
instance Typeable LexmapType
instance Typeable Lexmap
instance Show LexmapType
instance Eq LexmapType
instance Ord LexmapType
instance Data LexmapType
instance Show Lexmap
instance Eq Lexmap
instance Ord Lexmap
instance Data Lexmap
instance CodePtr Lexmap
instance Write Lexmap


-- | Attribute sorters.
module Koshucode.Baala.Core.Lexmap.Sorter

-- | Attribute sorter for no-attribute trunk.
roaNone :: [AttrName] -> AttrDefine

-- | Attribute sorter for enumerating trunk, i.e., <tt>-1</tt>,
--   <tt>-2</tt>, ...
roaEnum :: [AttrName] -> [AttrName] -> AttrDefine

-- | Attribute sorter for multiple-attribute trunk.
roaList :: AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for one-and-multiple-attribute trunk.
roaOneList :: AttrName -> AttrName -> [AttrName] -> AttrDefine
roaOneOpt :: AttrName -> AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for one-attribute trunk.
roaOne :: AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for two-attribute trunk.
roaTwo :: AttrName -> AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for three-attribute trunk.
roaThree :: AttrName -> AttrName -> AttrName -> [AttrName] -> AttrDefine

-- | Attribute sorter for four-attribute trunk.
roaFour :: AttrName -> AttrName -> AttrName -> AttrName -> [AttrName] -> AttrDefine
roaTermsOne :: AttrName -> AttrName -> [AttrName] -> AttrDefine
roaTermsTwo :: AttrName -> AttrName -> AttrName -> [AttrName] -> AttrDefine

module Koshucode.Baala.Core.Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relmap.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Head -> RelkitBody c -> Relkit c
relkitHead :: Relkit c -> Maybe Head
relkitBody :: Relkit c -> RelkitBody c
data RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitAbFull :: Bool -> ([Relbmap c] -> [[c]] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([Relbmap c] -> [c] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([Relbmap c] -> [c] -> Ab [c]) -> [RelkitBody c] -> RelkitCore c
RelkitAbSemi :: ([[c]] -> Ab Bool) -> (RelkitBody c) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitId :: RelkitCore c
RelkitSource :: JudgePat -> [TermName] -> RelkitCore c
RelkitLink :: RopName -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c
RelkitNestVar :: RopName -> RelkitCore c
RelkitCopy :: RopName -> (RelkitBody c) -> RelkitCore c
RelkitNest :: [(String, Int)] -> (RelkitBody c) -> RelkitCore c
type RelkitBody c = Sourced (RelkitCore c)
type RelkitKey = (Maybe Head, [Lexmap])
type RelkitDef c = (RelkitKey, Relkit c)

-- | Mapping for body of relation.
type Relbmap c = [[c]] -> Ab [[c]]

-- | Relation selector
type RelSelect c = JudgePat -> [String] -> Rel c

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitFlow c = Maybe Head -> Ab (Relkit c)

-- | Make <a>Relkit</a> from hook data and input heading.
type RelkitHook' h c = h c -> RelkitFlow c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitFlow c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [Relkit c] -> RelkitFlow c
relkit :: Maybe Head -> RelkitCore c -> Relkit c
relkitJust :: Head -> RelkitCore c -> Relkit c
relkitNothing :: Relkit c
relkitId :: Maybe Head -> Relkit c
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [TermName] -> Relkit c
relkitConstSingleton :: [TermName] -> [c] -> Relkit c
relkitConstBody :: [TermName] -> [[c]] -> Relkit c
relkitSource :: JudgePat -> [TermName] -> Relkit c
relkitCopy :: String -> Map (Relkit c)
relkitNest :: [(String, Int)] -> Map (Relkit c)
relkitNestVar :: String -> Head -> Relkit c
relkitSetSource :: CodePtr a => a -> Map (Relkit c)
instance Show (RelkitCore c)
instance Monoid (Relkit c)


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Relmap

-- | Generic relmap.
data Relmap' h c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgePat -> [TermName] -> Relmap' h c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap' h c

-- | Relmap that maps relations to a relation with hook data
RelmapHook :: Lexmap -> (RelkitHook' h c) -> Relmap' h c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap' h c] -> Relmap' h c

-- | Relmap for environment of input relation
RelmapCopy :: Lexmap -> String -> (Relmap' h c) -> Relmap' h c

-- | Relmap for environment of nested relations
RelmapNest :: Lexmap -> [Terminal String] -> (Relmap' h c) -> Relmap' h c

-- | Relmap reference
RelmapLink :: Lexmap -> Relmap' h c

-- | Connect two relmaps
RelmapAppend :: (Relmap' h c) -> (Relmap' h c) -> Relmap' h c

-- | Identity relmap.
relmapId :: Relmap' h c
relmapLexmaps :: Relmap' h c -> [Lexmap]
instance Eq (Relmap' h c)
instance Ord (Relmap' h c)
instance CodePtr (Relmap' h c)
instance Write (Relmap' h c)
instance Name (Relmap' h c)
instance Monoid (Relmap' h c)
instance Show (Relmap' h c)


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator
data Rop' h c
Rop :: RopName -> String -> AttrSort -> RopCons' h c -> RopUsage -> Rop' h c

-- | Operator name
ropName :: Rop' h c -> RopName

-- | Operator group
ropGroup :: Rop' h c -> String

-- | Attribute sorter
ropSorter :: Rop' h c -> AttrSort

-- | Constructor of operator
ropCons :: Rop' h c -> RopCons' h c

-- | Usage of operator
ropUsage :: Rop' h c -> RopUsage

-- | Operator usage.
type RopUsage = String

-- | Use of relmap operator
data RopUse' h c
RopUse :: h c -> Lexmap -> [Relmap' h c] -> RopUse' h c
ropHook :: RopUse' h c -> h c

-- | Syntactic data of operator use
ropLexmap :: RopUse' h c -> Lexmap

-- | Subrelmaps
ropSubrelmap :: RopUse' h c -> [Relmap' h c]

-- | Constructor of relmap operator
type RopCons' h c = RopUse' h c -> Ab (Relmap' h c)
instance Show (h c) => Show (RopUse' h c)
instance CodePtr (RopUse' h c)
instance Name (Rop' h c)
instance Show (Rop' h c)


-- | Content of term in judgement.
module Koshucode.Baala.Core.Content


-- | Convert relation to text table.
module Koshucode.Baala.Core.Assert.RelTable
relTable :: (Write c, CRel c) => [ShortDef] -> Rel c -> String
relTableLines :: (Write c, CRel c) => [ShortDef] -> Rel c -> [String]
relText :: (Write c, CRel c) => [ShortDef] -> Rel c -> RelText


-- | Global parameters.
module Koshucode.Baala.Core.Relmap.Global

-- | Global parameters
data Global' h c
Global :: Version -> OpSet' (Rop' h) c -> String -> [String] -> Time -> [Source] -> [Judge c] -> Global' h c
globalVersion :: Global' h c -> Version
globalOpset :: Global' h c -> OpSet' (Rop' h) c
globalProgram :: Global' h c -> String
globalArgs :: Global' h c -> [String]
globalTime :: Global' h c -> Time
globalSources :: Global' h c -> [Source]
globalJudges :: Global' h c -> [Judge c]
globalCommandLine :: Global' h c -> [String]
globalFill :: CContent c => Map (Global' h c)
globalRops :: Global' h c -> [Rop' h c]
globalCops :: Global' h c -> [Cop c]
globalCopset :: Global' h c -> CopSet c
globalInfix :: Global' h c -> [Named InfixHeight]

-- | Empty global parameters.
global :: Global' h c
class GetGlobal h
getGlobal :: GetGlobal h => h c -> Global' h c
ropGlobal :: GetGlobal h => RopUse' h c -> Global' h c

-- | Get operator set from <tt>RopUse</tt>.
ropCopset :: GetGlobal h => RopUse' h c -> CopSet c

-- | Set of relmap and content operators.
data OpSet' rop c
OpSet :: [rop c] -> (RopName -> Maybe (rop c)) -> CopSet c -> OpSet' rop c
opsetRopList :: OpSet' rop c -> [rop c]
opsetFindRop :: OpSet' rop c -> RopName -> Maybe (rop c)
opsetCop :: OpSet' rop c -> CopSet c

-- | Empty operator set.
opset :: OpSet' rop c
opsetFill :: Name (rop c) => Map (OpSet' rop c)
instance Show (Global' h c)


-- | Operations on <a>Relmap</a>.
module Koshucode.Baala.Core.Relmap.Construct

-- | Second step of constructing relmap, make relmap from lexmap.
type ConsRelmap' h c = Lexmap -> Ab (Relmap' h c)

-- | Make a constructor pair of lexmap and relmap.
relmapCons :: GetGlobal h => h c -> (ConsLexmap, ConsRelmap' h c)

-- | Retrieve relation from dataset.
relmapSource :: RopUse' h c -> JudgePat -> [TermName] -> (Relmap' h c)

-- | Make a constant relmap.
relmapConst :: RopUse' h c -> Rel c -> Relmap' h c

-- | Make a flow relmap. Flow relmaps take no subrelmaps.
relmapFlow :: RopUse' h c -> RelkitFlow c -> Relmap' h c
relmapHook :: RopUse' h c -> RelkitHook' h c -> Relmap' h c

-- | Make a binary relmap. Binary relmaps take one subrelmap.
relmapBinary :: RopUse' h c -> RelkitBinary c -> Relmap' h c -> Relmap' h c

-- | Make a confluent relmap. Confluent relmaps take multiple subrelmaps.
relmapConfl :: RopUse' h c -> RelkitConfl c -> [Relmap' h c] -> Relmap' h c
relmapCopy :: RopUse' h c -> String -> Map (Relmap' h c)
relmapNest :: RopUse' h c -> [Terminal String] -> Map (Relmap' h c)
relmapNestVar :: RopUse' h c -> String -> Relmap' h c
relmapLink :: RopUse' h c -> Relmap' h c

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap' h c -> [Relmap' h c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap' h c -> [String]


-- | Specialize generic relmaps to specific relmaps
module Koshucode.Baala.Core.Relmap.Specialize
relmapSpecialize :: GetGlobal h => h c -> RelmapLinkTable' h c -> [RelkitDef c] -> Maybe Head -> Relmap' h c -> Ab ([RelkitDef c], Relkit c)
type RelmapLinkTable' h c = [(Lexmap, Relmap' h c)]


-- | Link and run relmaps.
module Koshucode.Baala.Core.Relmap.Run
relkitLink :: Ord c => [RelkitDef c] -> Map (Relkit c)
relkitRun :: (Ord c, CRel c, SelectRel h, GetGlobal h) => h c -> [Named [[c]]] -> RelkitBody c -> AbMap [[c]]
fixedRelation :: Ord c => Map (AbMap [[c]])
bmapAlign :: Head -> Head -> Map (AbMap [[c]])


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert' h c
Assert :: SecNo -> AssertType -> JudgePat -> AssertOption -> [Token] -> [TTree] -> Maybe (Relmap' h c) -> RelmapLinkTable' h c -> Assert' h c

-- | Section number
assSection :: Assert' h c -> SecNo

-- | Logical quality
assType :: Assert' h c -> AssertType

-- | Pattern of judgement
assPattern :: Assert' h c -> JudgePat

-- | Assert option
assOption :: Assert' h c -> AssertOption

-- | Source token list
assToken :: Assert' h c -> [Token]

-- | Token relmap
assTree :: Assert' h c -> [TTree]

-- | Relmap
assRelmap :: Assert' h c -> Maybe (Relmap' h c)
assLinks :: Assert' h c -> RelmapLinkTable' h c

-- | Option for assertions.
type AssertOption = [NamedTrees]

-- | Assertion list with short signs.
type ShortAssert' h c = Short [Assert' h c]

-- | Select affirmative or denial assertions.
assertNormal :: Map [ShortAssert' h c]

-- | Select violated assertions.
assertViolated :: Map [ShortAssert' h c]
instance Show (Assert' h c)
instance Write (Assert' h c)
instance CodePtr (Assert' h c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges.
datasetEmpty :: Dataset c

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
datasetAdd :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CEmpty</tt> sign is used.
datasetSelect :: (Ord c, CEmpty c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, Write c, CRel c, CEmpty c, SelectRel h, GetGlobal h) => h c -> ShortAssert' h c -> Ab (OutputChunks c)


-- | Intermidiate structure between <a>String</a> and <tt>Resource</tt>.
module Koshucode.Baala.Core.Resource.Clause
type ShortClause = Short [Clause]
data Clause
Clause :: TokenClause -> SecNo -> ClauseBody -> Clause
clauseSource :: Clause -> TokenClause
clauseSecNo :: Clause -> SecNo
clauseBody :: Clause -> ClauseBody
data ClauseBody

-- | Includeing source
CInclude :: [Token] -> (Maybe Clause) -> ClauseBody

-- | Exporting name
CExport :: String -> ClauseBody

-- | Short signs
CShort :: [ShortDef] -> ClauseBody

-- | Source of relmap
CRelmap :: String -> [Token] -> ClauseBody

-- | Assertion
CAssert :: AssertType -> JudgePat -> [Token] -> [Token] -> ClauseBody

-- | Judge
CJudge :: AssertType -> JudgePat -> [Token] -> ClauseBody

-- | Global slot
CSlot :: String -> [Token] -> ClauseBody

-- | Unknown clause
CUnknown :: ClauseBody

-- | Unresolved short sign
CUnres :: [Token] -> ClauseBody

-- | Name of clause type. e.g., <tt>"relmap"</tt>, <tt>"assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <tt>TTokmap</tt> and <a>CAssert</a> are contained. This function does
--   not depend on <a>ConsLexmap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [ TTokmap ( TokenClause
--                [TText 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TText 1 0 "a", ...]] )
--            "a" [ TText 5 0 "source"
--                , TText 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
--   
--   First step of constructing <tt>Resource</tt>.
consClause :: SecNo -> [TokenLine] -> [ShortClause]
consPreclause :: SecNo -> [TokenLine] -> [Clause]
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause
instance CodePtr Clause


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Resource as bundle of relational expressions.
module Koshucode.Baala.Core.Resource.Resource
data Resource c
Resource :: Global c -> [Resource c] -> [String] -> [NamedTrees] -> [RelmapSource] -> [ShortAssert c] -> [Judge c] -> Source -> [String] -> SecNo -> RelSelect c -> Resource c

-- | Global parameter
resGlobal :: Resource c -> Global c

-- | Importing resources
resImport :: Resource c -> [Resource c]

-- | Exporting names
resExport :: Resource c -> [String]

-- | Global slots
resSlot :: Resource c -> [NamedTrees]

-- | Source of relmaps
resRelmap :: Resource c -> [RelmapSource]

-- | Assertions of relmaps
resAssert :: Resource c -> [ShortAssert c]

-- | Affirmative or denial judgements
resJudge :: Resource c -> [Judge c]

-- | Source name
resSource :: Resource c -> Source

-- | Collection of messages
resMessage :: Resource c -> [String]

-- | Last section number
resLastSecNo :: Resource c -> SecNo
resSelect :: Resource c -> RelSelect c
coxBuildG :: CContent c => Global c -> TTreeToAb (Cox c)
addMessage :: String -> Map (Resource c)
addMessages :: [String] -> Map (Resource c)

-- | Resource that has no contents.
resEmpty :: Resource c

-- | Include source code into resource.
resInclude :: CContent c => Resource c -> Source -> String -> Ab (Resource c)
type Assert c = Assert' Resource c
type ConsRelmap c = ConsRelmap' Resource c
type Global c = Global' Resource c
type RelkitHook c = RelkitHook' Resource c
type Relmap c = Relmap' Resource c
type RelmapLinkTable c = RelmapLinkTable' Resource c
type Rop c = Rop' Resource c
type RopCons c = RopCons' Resource c
type RopUse c = RopUse' Resource c
type ShortAssert c = ShortAssert' Resource c
instance GetGlobal Resource
instance SelectRel Resource
instance Show (Resource c)

module Koshucode.Baala.Core.Resource.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: ConsLexmap -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Read source as resource.
module Koshucode.Baala.Core.Resource.Read

-- | Read resource from certain source.
readResource :: CContent c => Resource c -> Source -> IO (Ab (Resource c))

-- | Read resource from text.
readResourceText :: CContent c => Resource c -> String -> Ab (Resource c)

-- | Bundle of sources.
data SourceBundle c
SourceBundle :: Resource c -> [Source] -> SourceBundle c
bundleRoot :: SourceBundle c -> Resource c
bundleSources :: SourceBundle c -> [Source]
bundleTexts :: SourceBundle c -> [String]
bundleRead :: CContent c => SourceBundle c -> IO (Ab (Resource c))
instance Show (SourceBundle c)


-- | Run resource.
module Koshucode.Baala.Core.Resource.Run
runResource :: CContent c => Resource c -> Ab (OutputResult c)


-- | Runtime structure for calculations written in Koshucode.
--   <a>Resource</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Resource

module Koshucode.Baala.Core
