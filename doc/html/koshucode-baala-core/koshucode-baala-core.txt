-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.119.0.0


-- | Result of relational calculation.
module Koshucode.Baala.Core.Relmap.Result

-- | Result of calculation.
data Result c
Result :: ResultWriter c -> Bool -> Bool -> Int -> Int -> [InputPoint] -> IOPoint -> [[String]] -> [[String]] -> [ShortResultChunks c] -> [ShortResultChunks c] -> [JudgePat] -> Result c
resultWriter :: Result c -> ResultWriter c
resultPrintHead :: Result c -> Bool
resultPrintFoot :: Result c -> Bool
resultGutter :: Result c -> Int
resultMeasure :: Result c -> Int
resultInput :: Result c -> [InputPoint]
resultOutput :: Result c -> IOPoint
resultEcho :: Result c -> [[String]]
resultLicense :: Result c -> [[String]]
resultViolated :: Result c -> [ShortResultChunks c]
resultNormal :: Result c -> [ShortResultChunks c]
resultPattern :: Result c -> [JudgePat]
data InputPoint
InputPoint :: IOPoint -> [TTree] -> InputPoint
inputPoint :: InputPoint -> IOPoint
inputPointAbout :: InputPoint -> [TTree]

-- | Empty result.
resultEmpty :: (Show c, Write c) => Result c

-- | Chunk of judgements.
data ResultChunk c
ResultJudge :: [Judge c] -> ResultChunk c
ResultRel :: JudgePat -> (Rel c) -> ResultChunk c
ResultNote :: [String] -> ResultChunk c
type ResultWriterChunk c = Handle -> Result c -> ExitCode -> [ShortResultChunks c] -> IO ExitCode
type ResultWriterJudge c = Handle -> Result c -> ExitCode -> [Judge c] -> IO ExitCode
type ShortResultChunks c = Short [ResultChunk c]
resultChunkJudges :: ResultChunk c -> [Judge c]
resultDump :: Show c => ResultWriter c
data ResultWriter c
ResultWriterChunk :: String -> (ResultWriterChunk c) -> ResultWriter c
ResultWriterJudge :: String -> (ResultWriterJudge c) -> ResultWriter c

-- | <a>stdout</a> version of <a>hPutResult</a>.
putResult :: Write c => Result c -> IO ExitCode

-- | Print result of calculation, and return status.
hPutResult :: Write c => Handle -> Result c -> IO ExitCode
useUtf8 :: Handle -> IO ()
instance Show InputPoint
instance Eq InputPoint
instance Ord InputPoint
instance Show c => Show (ResultChunk c)
instance Ord c => Eq (ResultChunk c)
instance Ord c => Ord (ResultChunk c)
instance Show c => Show (Result c)
instance Ord c => Eq (Result c)
instance Ord c => Ord (Result c)
instance Name (ResultWriter c)
instance Eq (ResultWriter c)
instance Ord (ResultWriter c)
instance Show (ResultWriter c)


-- | Convert relation to text table.
module Koshucode.Baala.Core.Assert.RelTable
relTable :: (Write c, CRel c) => [ShortDef] -> Rel c -> String
relTableLines :: (Write c, CRel c) => [ShortDef] -> Rel c -> [String]
relText :: (Write c, CRel c) => [ShortDef] -> Rel c -> RelText

module Koshucode.Baala.Core.Message
abAssert :: CodePtr cp => [cp] -> Map (Ab b)
abAttr :: CodePtr cp => [cp] -> Map (Ab b)
abAttrTrees :: TTreesTo (Map (Ab b))
abClause :: CodePtr cp => [cp] -> Map (Ab b)
abLexmap :: TTreesTo (Map (Ab b))
abOption :: TTreesTo (Map (Ab b))
abRelmap :: CodePtr cp => [cp] -> Map (Ab b)
abRun :: CodePtr cp => [cp] -> Map (Ab b)
abSlot :: CodePtr cp => [cp] -> Map (Ab b)
abSlotTree :: TTreeTo (Map (Ab b))
abSpecialize :: CodePtr cp => [cp] -> Map (Ab b)

-- | Ambiguous relmaps
ambRelmap :: String -> [d] -> Ab a

-- | Unexpected attribute / Duplicate
dupAttr :: [String] -> Ab a

-- | Duplicate prefix
dupPrefix :: [String] -> Ab a

-- | Duplicate replacement
dupReplacement :: [String] -> Ab a

-- | Empty literal
emptyLiteral :: Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | HTTP Error
httpError :: String -> Int -> String -> Ab a

-- | Invalid prefix character
invalidPrefix :: [String] -> Ab a

-- | File not found
noFile :: FilePath -> String -> Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Require grouping paren
reqGroup :: Ab a

-- | Same I/O points
sameIOPoints :: IOPoint -> Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a
unexpAttr0 :: Ab a
unexpAttr1 :: Ab a
unexpAttr2 :: Ab a
unexpAttr3 :: Ab a
unexpAttr4 :: Ab a
unexpAttr1V :: Ab a
unexpAttr1Q :: Ab a

-- | Unknown clause
unkClause :: [String] -> Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown nested relation
unkNestRel :: Token -> String -> [String] -> Ab a
unkNestVar :: String -> [Token] -> [((Token, Local String), Head)] -> Ab a

-- | Unknown option
unkOption :: ParaUnmatch String -> Ab a

-- | Unknown relmap operator
unkRelmap :: String -> Ab a

-- | Unresolved prefix
unresPrefix :: String -> Ab a


-- | Positional attributes.
module Koshucode.Baala.Core.Lexmap.AttrPos
data AttrPos a
AttrPos0 :: AttrPos a
AttrPos1 :: a -> AttrPos a
AttrPos2 :: a -> a -> AttrPos a
AttrPos3 :: a -> a -> a -> AttrPos a
AttrPos4 :: a -> a -> a -> a -> AttrPos a
AttrPosE :: [a] -> AttrPos a
AttrPosV :: a -> AttrPos a
AttrPos1V :: a -> a -> AttrPos a
AttrPos1Q :: a -> a -> AttrPos a
attrTypeNames :: AttrPos a -> [a]
ropAttrPos :: AttrPos AttrName -> AttrSortTree
type AttrSortTree = [TTree] -> Ab [AttrTree]

-- | Attribute name and its contents.
type AttrTree = (AttrName, [TTree])

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: String -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: String -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName
instance Typeable AttrName
instance Show a => Show (AttrPos a)
instance Eq a => Eq (AttrPos a)
instance Ord a => Ord (AttrPos a)
instance Show AttrName
instance Eq AttrName
instance Ord AttrName
instance Data AttrName


-- | Attributes of relmap operator.
module Koshucode.Baala.Core.Lexmap.Attr

-- | Definition of attribute sorter.
data RopAttr
RopAttr :: AttrSortTree -> Map AttrName -> AttrPos AttrName -> [AttrName] -> [AttrName] -> RopAttr
attrPosSorter :: RopAttr -> AttrSortTree
attrClassifier :: RopAttr -> Map AttrName
attrPos :: RopAttr -> AttrPos AttrName
attrPosNames :: RopAttr -> [AttrName]
attrBranchNames :: RopAttr -> [AttrName]
ropAttrCons :: AttrPos AttrName -> [AttrName] -> RopAttr
type AttrPara = ParaBody AttrName TTree

-- | Sorter for attribute of relmap operator. Sorters docompose attribute
--   trees, and give a name to subattribute.
type AttrSortPara = [TTree] -> Ab AttrPara
attrSort :: RopAttr -> AttrSortPara
attrBranch :: AttrSortPara
maybeSingleHyphen :: TTreeTo (Maybe String)


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap.Lexmap

-- | Intermediate data that represents use of relmap operator. Lexmap is
--   constructed from a list of <a>TTree</a>, and generic relmap is
--   constructed from a lexmap.
data Lexmap
Lexmap :: LexmapType -> Token -> AttrPara -> [Lexmap] -> [String] -> Lexmap

-- | Type of lexmap
lexType :: Lexmap -> LexmapType

-- | Token of operator
lexToken :: Lexmap -> Token

-- | Attribute of relmap operation
lexAttr :: Lexmap -> AttrPara

-- | Submaps in the attribute
lexSubmap :: Lexmap -> [Lexmap]

-- | Messages on lexmap
lexMessage :: Lexmap -> [String]
data LexmapType

-- | Built-in relmap
LexmapBase :: LexmapType

-- | User-defined relmap
LexmapDerived :: LexmapType

-- | Local relation reference
LexmapLocal :: LexmapType

-- | Name of relmap operator.
type RopName = String

-- | Empty base lexmap.
lexBase :: Lexmap

-- | Name of relmap operator
lexName :: Lexmap -> RopName
lexAddMessage :: String -> Map Lexmap
lexMessageList :: Lexmap -> [String]

-- | Attribute of relmap operation.
lexAttrTree :: Lexmap -> [AttrTree]
instance Typeable LexmapType
instance Typeable Lexmap
instance Show LexmapType
instance Eq LexmapType
instance Ord LexmapType
instance Data LexmapType
instance Show Lexmap
instance Eq Lexmap
instance Ord Lexmap
instance Data Lexmap
instance CodePtr Lexmap
instance Write Lexmap


-- | Slot substitution.
module Koshucode.Baala.Core.Lexmap.Slot
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [TTree]


-- | Attribute editor.
module Koshucode.Baala.Core.Lexmap.AttrEd

-- | Attribute editor with source code information.
type AttrEd = Sourced AttrEdBody

-- | Operators for attribute editors.
data AttrEdBody

-- | Identity editor
AttrEdId :: AttrEdBody

-- | Add attribute
AttrEdAdd :: Bool -> String -> [TTree] -> AttrEdBody

-- | Rename attribute keyword
AttrEdRename :: (String, String) -> AttrEdBody

-- | Fill positional attributes
AttrEdFill :: [Maybe TTree] -> AttrEdBody

-- | Make term name
AttrEdTerm :: String -> [TTree] -> AttrEdBody

-- | Nested relation reference
AttrEdNest :: String -> [TTree] -> AttrEdBody

-- | Append editors
AttrEdAppend :: [AttrEd] -> AttrEdBody

-- | Construct attribute editor.
consAttrEd :: [TTree] -> Ab AttrEd

-- | Edit relmap attributes.
runAttrEd :: AttrEd -> AbMap [AttrTree]
instance Typeable AttrEdBody
instance Show AttrEdBody
instance Eq AttrEdBody
instance Ord AttrEdBody
instance Data AttrEdBody


-- | Lexmap trees
module Koshucode.Baala.Core.Lexmap.LexmapTrees
data LexmapTrees
LexmapTrees :: [TTree] -> TTreePara -> AttrEd -> LexmapTrees
lexmapTrees :: LexmapTrees -> [TTree]
lexmapPara :: LexmapTrees -> TTreePara
lexmapAttrEd :: LexmapTrees -> AttrEd
consLexmapTrees :: TTreePara -> Ab LexmapTrees

-- | Token Tree parameter.
type TTreePara = Para TTree

-- | Make token tree parameter with single-hyphen names.
ttreePara1 :: [Token] -> Ab TTreePara

-- | Make token tree parameter with double-hyphen names.
ttreePara2 :: [Token] -> Ab TTreePara
instance Show LexmapTrees
instance Eq LexmapTrees
instance Ord LexmapTrees


-- | Construction of lexical relmaps.
module Koshucode.Baala.Core.Lexmap.Construct

-- | First step of constructing relmap, construct lexmap from token trees.
--   The function returns lexmap and related lexmap links.
consLexmap :: FindSorter -> ConsLexmap
type ConsLexmap = [GlobalSlot] -> FindDeriv -> SecNo -> ConsLexmapBody

-- | Find derived relmap operator.
type FindDeriv = SecNo -> RopName -> [LexmapClause]

-- | Source of relmap: its name, replacement, and attribute editor.
type LexmapClause = NNamed LexmapTrees

-- | Section number.
type SecNo = Int

-- | Numbered name.
type NName = (SecNo, String)

-- | Pair which key is a numbered name.
type NNamed a = (NName, a)

-- | Find attribute sorter of relmap operator.
type FindSorter = RopName -> Maybe AttrSortPara
type ConsLexmapBody = [TTree] -> Ab (Lexmap, LexmapLinkTable)
type LexmapLinkTable = [(Lexmap, Lexmap)]


-- | Options.
module Koshucode.Baala.Core.Relmap.Option
type Option c = Map String (OptionContent c)
data OptionContent c
OptionBool :: Bool -> OptionContent c
OptionChar :: [Char] -> Char -> OptionContent c
OptionTerms :: [TermName] -> OptionContent c
option :: (CBool c, CText c) => Option c
optionBool :: String -> Option c -> Bool
optionParse :: (Eq c, CBool c, CText c) => ContentCalc c -> [Token] -> AbMap (Option c)
instance Show (OptionContent c)
instance Eq (OptionContent c)
instance Ord (OptionContent c)

module Koshucode.Baala.Core.Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relkit.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Head -> Maybe Head -> RelkitBody c -> Relkit c
relkitInput :: Relkit c -> Maybe Head
relkitOutput :: Relkit c -> Maybe Head
relkitBody :: Relkit c -> RelkitBody c
data RelkitCore c
RelkitFull :: Bool -> (Map [[c]]) -> RelkitCore c
RelkitOneToMany :: Bool -> (ManyMap [c]) -> RelkitCore c
RelkitOneToOne :: Bool -> (Map [c]) -> RelkitCore c
RelkitPred :: (Pred [c]) -> RelkitCore c
RelkitAbFull :: Bool -> ([BodyMap c] -> AbMap [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([BodyMap c] -> AbManyMap [c]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([BodyMap c] -> AbMap [c]) -> [RelkitBody c] -> RelkitCore c
RelkitAbSemi :: (AbPred [[c]]) -> (RelkitBody c) -> RelkitCore c
RelkitAbPred :: (AbPred [c]) -> RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitId :: RelkitCore c
RelkitSource :: JudgePat -> [TermName] -> RelkitCore c
RelkitLink :: RopName -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c
RelkitCopy :: Token -> RopName -> (RelkitBody c) -> RelkitCore c
RelkitNestVar :: Token -> RopName -> RelkitCore c
RelkitNest :: Token -> [(String, Int)] -> (RelkitBody c) -> RelkitCore c
type RelkitBody c = Sourced (RelkitCore c)
type RelkitKey = (Maybe Head, [Lexmap])
type RelkitDef c = (RelkitKey, Relkit c)

-- | Mapping for body of relation.
type BodyMap c = AbMap [[c]]

-- | Relation selector
type RelSelect c = JudgePat -> [String] -> Rel c

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitFlow c = Maybe Head -> Ab (Relkit c)

-- | Make <a>Relkit</a> from hook data and input heading.
type RelkitHook' h c = h c -> RelkitFlow c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitFlow c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [Relkit c] -> RelkitFlow c
instance Show (RelkitCore c)


-- | Relkit constructors.
module Koshucode.Baala.Core.Relkit.Construct
relkit :: Maybe Head -> RelkitCore c -> Relkit c
relkitId :: Maybe Head -> Relkit c
relkitJust :: Head -> RelkitCore c -> Relkit c
relkitNothing :: Relkit c
relkitSetSource :: CodePtr a => a -> Map (Relkit c)
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [TermName] -> Relkit c
relkitConstSingleton :: [TermName] -> [c] -> Relkit c
relkitConstBody :: [TermName] -> [[c]] -> Relkit c
relkitSource :: JudgePat -> [TermName] -> Relkit c
relkitCopy :: Token -> String -> Map (Relkit c)
relkitNest :: Token -> [(String, Int)] -> Map (Relkit c)
relkitNestVar :: Token -> String -> Head -> Relkit c
type Local a = Lexical [Named a]
type Lexical a = (Token, a)
localsLines :: [Local a] -> [String]
a2lookup :: (Eq a, Eq b) => a -> b -> [(a, [(b, c)])] -> Maybe c
instance Monoid (Relkit c)


-- | Link and run relmaps.
module Koshucode.Baala.Core.Relkit.Run
relkitLink :: Ord c => [RelkitDef c] -> Map (Relkit c)
relkitRun :: (Ord c, CRel c, SelectRel h) => h c -> [Local [[c]]] -> RelkitBody c -> AbMap [[c]]
fixedRelation :: Ord c => Map (AbMap [[c]])
bmapAlign :: Head -> Head -> Map (AbMap [[c]])


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relkit


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges.
datasetEmpty :: Dataset c

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
datasetAdd :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CEmpty</tt> sign is used.
datasetSelect :: (Ord c, CEmpty c) => Dataset c -> RelSelect c


-- | Generic relmap.
module Koshucode.Baala.Core.Relmap.Relmap

-- | Generic relmap.
data Relmap' h c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap' h c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgePat -> [TermName] -> Relmap' h c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap' h c] -> Relmap' h c

-- | Relmap that maps relations to a relation with hook data
RelmapHook :: Lexmap -> (RelkitHook' h c) -> Relmap' h c

-- | Relmap for environment of input relation
RelmapCopy :: Lexmap -> String -> (Relmap' h c) -> Relmap' h c

-- | Relmap for environment of nested relations
RelmapNest :: Lexmap -> (Relmap' h c) -> Relmap' h c

-- | Relmap reference
RelmapLink :: Lexmap -> Relmap' h c

-- | Connect two relmaps
RelmapAppend :: (Relmap' h c) -> (Relmap' h c) -> Relmap' h c

-- | Identity relmap.
relmapId :: Relmap' h c
relmapLexmaps :: Relmap' h c -> [Lexmap]

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap' h c -> [Relmap' h c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap' h c -> [String]
instance Eq (Relmap' h c)
instance Ord (Relmap' h c)
instance CodePtr (Relmap' h c)
instance Write (Relmap' h c)
instance Name (Relmap' h c)
instance Monoid (Relmap' h c)
instance Show (Relmap' h c)


-- | Relmap operators.
module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator.
data Rop' h c
Rop :: RopName -> String -> RopUsage -> RopAttr -> AttrSortPara -> RopCons' h c -> Rop' h c

-- | Operator name
ropName :: Rop' h c -> RopName

-- | Operator group
ropGroup :: Rop' h c -> String

-- | Usage text of operator
ropUsage :: Rop' h c -> RopUsage

-- | Attribute of operator
ropAttr :: Rop' h c -> RopAttr

-- | Attribute sorter
ropSorter :: Rop' h c -> AttrSortPara

-- | Constructor of operator
ropCons :: Rop' h c -> RopCons' h c

-- | Usage text of operator.
type RopUsage = String
type FindRop' h c = RopName -> Maybe (Rop' h c)

-- | Constructor of relmap operator, i.e., function from intermediate
--   relamp to generic relmap.
type RopCons' h c = Intmed' h c -> Ab (Relmap' h c)

-- | Intermediate relmap, that is in between lexmap and generic relmap.
data Intmed' h c
Intmed :: h c -> Lexmap -> [Relmap' h c] -> Intmed' h c
medHook :: Intmed' h c -> h c

-- | Syntactic data of operator use
medLexmap :: Intmed' h c -> Lexmap

-- | Subrelmaps
medSubmap :: Intmed' h c -> [Relmap' h c]
instance Show (h c) => Show (Intmed' h c)
instance CodePtr (Intmed' h c)
instance Name (Rop' h c)
instance Show (Rop' h c)


-- | Construction of relmaps.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make a constant relmap.
relmapConst :: Intmed' h c -> Rel c -> Relmap' h c

-- | Relmap for retrieving relation from dataset.
relmapSource :: Intmed' h c -> JudgePat -> [TermName] -> Relmap' h c

-- | Make a flow relmap. Flow relmaps take no submaps.
relmapFlow :: Intmed' h c -> RelkitFlow c -> Relmap' h c
relmapHook :: Intmed' h c -> RelkitHook' h c -> Relmap' h c

-- | Make a binary relmap. Binary relmaps take one submap.
relmapBinary :: Intmed' h c -> RelkitBinary c -> Relmap' h c -> Relmap' h c

-- | Make a confluent relmap. Confluent relmaps take multiple submaps.
relmapConfl :: Intmed' h c -> RelkitConfl c -> [Relmap' h c] -> Relmap' h c

-- | Parent for nested relation references.
relmapNest :: Intmed' h c -> Map (Relmap' h c)
relmapCopy :: Intmed' h c -> RopName -> Map (Relmap' h c)
relmapLink :: Intmed' h c -> Relmap' h c
relmapLocalSymbol :: Intmed' h c -> String -> Relmap' h c
relmapLocalNest :: Intmed' h c -> String -> Relmap' h c

-- | Second step of constructing relmap, make relmap from lexmap.
type ConsRelmap' h c = Lexmap -> Ab (Relmap' h c)

-- | Construct relmap from lexmap.
consRelmap :: FindRop' h c -> h c -> ConsRelmap' h c


-- | Global parameters.
module Koshucode.Baala.Core.Relmap.Global

-- | Global parameters
data Global' h c
Global :: String -> Version -> OpSet' h c -> String -> [String] -> [HttpProxy] -> Time -> Result c -> Option c -> Int -> [CodePiece] -> h c -> Global' h c

-- | One-line description of calculator
globalSynopsis :: Global' h c -> String

-- | Version of calculator
globalVersion :: Global' h c -> Version

-- | Set of operators
globalOpset :: Global' h c -> OpSet' h c

-- | Name of invoked program
globalProgram :: Global' h c -> String

-- | Command line arguments
globalArgs :: Global' h c -> [String]

-- | Proxy setting from environment variables
globalProxy :: Global' h c -> [HttpProxy]

-- | Invocation time
globalTime :: Global' h c -> Time

-- | Result template
globalResult :: Global' h c -> Result c

-- | Options
globalOption :: Global' h c -> Option c

-- | Sequential number for sources
globalSourceCount :: Global' h c -> Int

-- | Included sources
globalSources :: Global' h c -> [CodePiece]

-- | Usually, data resource is used as hook
globalHook :: Global' h c -> h c
globalVersionText :: Global' h c -> String
globalCommandLine :: Global' h c -> [String]
globalFill :: CContent c => Map (Global' h c)
globalRops :: Global' h c -> [Rop' h c]
globalRopsAdd :: [Rop' h c] -> Map (Global' h c)
globalCops :: Global' h c -> [Cop c]
globalCopset :: Global' h c -> CopSet c
globalInfix :: Global' h c -> [Named InfixHeight]
globalAbort :: Global' h c -> AbortReason -> IO a

-- | Empty global parameters.
global' :: (CBool c, CText c) => h c -> Global' h c
class GetGlobal h
getGlobal :: GetGlobal h => h c -> Global' h c
ropGlobal :: GetGlobal h => Intmed' h c -> Global' h c

-- | Get operator set from <tt>Intmed</tt>.
ropCopset :: GetGlobal h => Intmed' h c -> CopSet c

-- | Set of relmap and content operators.
data OpSet' h c
OpSet :: [Rop' h c] -> FindRop' h c -> CopSet c -> OpSet' h c
opsetRopList :: OpSet' h c -> [Rop' h c]
opsetFindRop :: OpSet' h c -> FindRop' h c
opsetCop :: OpSet' h c -> CopSet c

-- | Empty operator set.
opset :: OpSet' h c
opsetFill :: Map (OpSet' h c)
instance Show (Global' h c)


-- | Specialize generic relmaps to specific relmaps
module Koshucode.Baala.Core.Relmap.Specialize
relmapSpecialize :: h c -> RelmapLinkTable' h c -> [RelkitDef c] -> Maybe Head -> Relmap' h c -> Ab ([RelkitDef c], Relkit c)
type RelmapLinkTable' h c = [(Lexmap, Relmap' h c)]


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert' h c
Assert :: SecNo -> AssertType -> JudgePat -> [Token] -> TTreePara -> Maybe (Relmap' h c) -> RelmapLinkTable' h c -> Assert' h c

-- | Section number
assSection :: Assert' h c -> SecNo

-- | Logical quality
assType :: Assert' h c -> AssertType

-- | Pattern of judgement
assPattern :: Assert' h c -> JudgePat

-- | Source token list
assToken :: Assert' h c -> [Token]
assPara :: Assert' h c -> TTreePara

-- | Relmap
assRelmap :: Assert' h c -> Maybe (Relmap' h c)
assLinks :: Assert' h c -> RelmapLinkTable' h c

-- | Assertion with short signs.
type ShortAssert' h c = Short (Assert' h c)

-- | Assertion list with short signs.
type ShortAsserts' h c = Short [Assert' h c]

-- | Select affirmative or denial assertions.
assertNormal :: Map [ShortAssert' h c]

-- | Select violated assertions.
assertViolated :: Map [ShortAssert' h c]
instance Show (Assert' h c)
instance Write (Assert' h c)
instance CodePtr (Assert' h c)


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, Write c, CRel c, CEmpty c, SelectRel h, GetGlobal h) => h c -> Option c -> ShortAsserts' h c -> Ab (ShortResultChunks c)


-- | Intermidiate structure between <a>String</a> and <tt>Resource</tt>.
module Koshucode.Baala.Core.Resource.Clause
data Clause
Clause :: ClauseHead -> ClauseBody -> Clause
clauseHead :: Clause -> ClauseHead
clauseBody :: Clause -> ClauseBody
data ClauseHead
ClauseHead :: TokenClause -> SecNo -> [ShortDef] -> [Token] -> ClauseHead
clauseSource :: ClauseHead -> TokenClause
clauseSecNo :: ClauseHead -> SecNo
clauseShort :: ClauseHead -> [ShortDef]
clauseAbout :: ClauseHead -> [Token]
data ClauseBody

-- | Input point
CInput :: [Token] -> ClauseBody

-- | Exporting name
CExport :: String -> ClauseBody

-- | Source of relmap
CRelmap :: String -> [Token] -> ClauseBody

-- | Assertion
CAssert :: AssertType -> JudgePat -> [Token] -> ClauseBody

-- | Judge
CJudge :: AssertType -> JudgePat -> [Token] -> ClauseBody

-- | Global slot
CSlot :: String -> [Token] -> ClauseBody

-- | Option settings
COption :: [Token] -> ClauseBody

-- | Output point
COutput :: [Token] -> ClauseBody

-- | Echo text
CEcho :: TokenClause -> ClauseBody

-- | License text
CLicense :: String -> ClauseBody

-- | The empty clause heading.
clauseHeadEmpty :: ClauseHead

-- | Name of clause type. e.g., <tt>"relmap"</tt>, <tt>"assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <tt>TTokmap</tt> and <a>CAssert</a> are contained. This function does
--   not depend on <a>ConsLexmap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consClause . B.tokenize $ "a : source A /x /y"
--   [ TTokmap ( TokenClause
--                [TText 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TText 1 0 "a", ...]] )
--            "a" [ TText 5 0 "source"
--                , TText 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
--   
--   First step of constructing <tt>Resource</tt>.
consClause :: [Token] -> SecNo -> [TokenLine] -> [Ab Clause]
instance Typeable ClauseHead
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseHead
instance Data ClauseHead
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause
instance CodePtr ClauseHead
instance CodePtr Clause


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Internal representation of relational data resource. Data resource
--   bundles data themselves and calculation stuffs. In Koshucode, data is
--   represented as set of judgements, and calculation is as
--   relation-to-relation mapping. This internal representation is usually
--   constructed from computer files or web resources addressed by URI.
--   Result of calculation on some resource becomes also data resource.
module Koshucode.Baala.Core.Resource.Resource

-- | Relational data resource
data Resource c
Resource :: Global c -> Option c -> [Resource c] -> [String] -> [NamedTrees] -> [LexmapClause] -> [ShortAssert c] -> [Judge c] -> ([InputPoint], [InputPoint], [CodePiece]) -> IOPoint -> [[TokenLine]] -> [(SecNo, String)] -> [String] -> SecNo -> RelSelect c -> Resource c

-- | Global parameter
resGlobal :: Resource c -> Global c

-- | Options
resOption :: Resource c -> Option c

-- | Importing resources
resImport :: Resource c -> [Resource c]

-- | Exporting names
resExport :: Resource c -> [String]

-- | Global slots
resSlot :: Resource c -> [NamedTrees]

-- | Source of relmaps
resLexmap :: Resource c -> [LexmapClause]

-- | Assertions of relmaps
resAssert :: Resource c -> [ShortAssert c]

-- | Affirmative or denial judgements
resJudge :: Resource c -> [Judge c]

-- | Input points
resInputStack :: Resource c -> ([InputPoint], [InputPoint], [CodePiece])

-- | Output point
resOutput :: Resource c -> IOPoint

-- | Echo text
resEcho :: Resource c -> [[TokenLine]]

-- | License text
resLicense :: Resource c -> [(SecNo, String)]

-- | Collection of messages
resMessage :: Resource c -> [String]

-- | Last section number
resLastSecNo :: Resource c -> SecNo
resSelect :: Resource c -> RelSelect c

-- | Abort or resource.
type AbResource c = Ab (Resource c)

-- | Resource that has no contents.
resEmpty :: CContent c => Resource c
resIncluded :: Resource c -> [CodePiece]
resInput :: Resource c -> [IOPoint]
resInputPoint :: Resource c -> [InputPoint]
resPattern :: Resource c -> [JudgePat]
addMessage :: String -> Map (Resource c)
addMessages :: [String] -> Map (Resource c)
type Assert c = Assert' Resource c
type ConsRelmap c = ConsRelmap' Resource c
type Global c = Global' Resource c
type RelkitHook c = RelkitHook' Resource c
type Relmap c = Relmap' Resource c
type RelmapLinkTable c = RelmapLinkTable' Resource c
type Rop c = Rop' Resource c
type RopCons c = RopCons' Resource c
type Intmed c = Intmed' Resource c
type ShortAssert c = ShortAssert' Resource c
type ShortAsserts c = ShortAsserts' Resource c
global :: CContent c => Global c
instance GetGlobal Resource
instance SelectRel Resource
instance Show (Resource c)


-- | Resource as bundle of relational expressions.
module Koshucode.Baala.Core.Resource.Include

-- | Include source code into resource.
resInclude :: CContent c => [Token] -> FilePath -> Resource c -> CodePiece -> String -> AbResource c
coxBuildG :: CContent c => Global c -> TTreeToAb (Cox c)

module Koshucode.Baala.Core.Resource.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: ConsLexmap -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Read resource.
module Koshucode.Baala.Core.Resource.Read

-- | I/O with global state.
type GlobalIO a c = StateT (Global c) IO a

-- | Calculation that returns abortable resource.
type ResourceIO c = GlobalIO (AbResource c) c
gio :: IO a -> GlobalIO a c
gioResource :: ResourceIO c -> Global c -> IO (AbResource c, Global c)

-- | Read resource from text.
readResourceText :: CContent c => Resource c -> String -> AbResource c
readSources :: CContent c => [IOPoint] -> ResourceIO c


-- | Run resource.
module Koshucode.Baala.Core.Resource.Run
runResource :: CContent c => Resource c -> Ab (Result c)
assembleRelmap :: AbMap (Resource c)

-- | Make a constructor pair of lexmap and relmap.
relmapCons :: GetGlobal h => h c -> (ConsLexmap, ConsRelmap' h c)


-- | Runtime structure for calculations written in Koshucode.
--   <a>Resource</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Resource

module Koshucode.Baala.Core
