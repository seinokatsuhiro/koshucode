-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.61.0.0

module Koshucode.Baala.Core.Message

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Duplicate prefix
dupPrefix :: [String] -> Ab a

-- | Duplicate replacement
dupReplacement :: [String] -> Ab a

-- | Empty literal
emptyLiteral :: Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | Invalid prefix character
invalidPrefix :: [String] -> Ab a

-- | File not found
noFile :: String -> Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Odd relation literal
oddRelation :: Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown clause
unkClause :: Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown nested relation
unkNestRel :: String -> Ab a

-- | Unknown relmap operator
unkRelmap :: String -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Relhead -> Ab a
unkWithVar :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a
unmatchType :: String -> Ab a

-- | Unresolved prefix
unresPrefix :: Ab a
detailTermRel :: String -> [String] -> Relhead -> [String]

module Koshucode.Baala.Core.Content.Class
class Show c => PrimContent c
typename :: PrimContent c => c -> String
class (Ord c, Write c, PrimContent c, CBool c, CText c, CDec c, CList c, CNil c, CSet c, CAssn c, CRel c) => CContent c where joinContent = foldM appendContent nil
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
class PrimContent c => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: CBool c => c
false :: CBool c => c
class PrimContent c => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
class PrimContent c => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Types that can be nil
class PrimContent c => CNil c
isNil :: CNil c => c -> Bool
nil :: CNil c => c
class PrimContent c => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pDecFromInt :: CDec c => Int -> c
class PrimContent c => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
class PrimContent c => CAssn c where getAssn = getAbAb isAssn gAssn putAssn = Right . pAssn
isAssn :: CAssn c => c -> Bool
gAssn :: CAssn c => c -> [Named c]
pAssn :: CAssn c => [Named c] -> c
getAssn :: CAssn c => Ab c -> Ab [Named c]
putAssn :: CAssn c => [Named c] -> Ab c
class PrimContent c => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool


-- | Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal

-- | Convert <a>TokenTree</a> to content.
type LitTree c = TokenTree -> Ab c

-- | Convert list of <a>TokenTree</a> to content.
type LitTrees c = [TokenTree] -> Ab c
type LitOperators c = [Named (LitTree c -> LitTrees c)]
litOperators :: CContent c => LitOperators c
litContent :: CContent c => LitTree c

-- | Convert token trees into a list of named token trees.
litNamedTrees :: LitTrees [Named TokenTree]

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of sections.
litJudge :: CContent c => Bool -> JudgePat -> LitTrees (Judge c)


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Cox

-- | Content expressions with source code.
type Cox c = Sourced (CoxCore c)

-- | Content expressions.
data CoxCore c

-- | A: Literal content
CoxLit :: c -> CoxCore c

-- | A: Term reference, its name and position
CoxTerm :: [TermName] -> [Int] -> CoxCore c

-- | A: Base function
CoxBase :: String -> (CopFun c) -> CoxCore c

-- | B: Variable, its name and De Bruijn index
CoxVar :: String -> Int -> CoxCore c

-- | A/B: Function application (multiple arguments)
CoxApplyL :: (Cox c) -> [Cox c] -> CoxCore c

-- | B: Derived function
CoxDeriv :: String -> (Cox c) -> CoxCore c

-- | C: Derived function (multiple variables)
CoxDerivL :: [String] -> (Cox c) -> CoxCore c

-- | Term-content operator.
data Cop c

-- | Function
CopFun :: String -> (CopFun c) -> Cop c

-- | Syntax
CopSyn :: String -> (CopSyn) -> Cop c
type CopFun c = [Ab c] -> Ab c
type CopSyn = [TokenTree] -> Ab TokenTree
isCopFunction :: Cop c -> Bool
isCopSyntax :: Cop c -> Bool
type NamedCox c = Named (Cox c)
coxAlpha :: CContent c => ([Cop c], [Named InfixHeight]) -> TokenTree -> Ab (Cox c)
coxBeta :: [Cop c] -> [NamedCox c] -> Relhead -> Cox c -> Ab (Cox c)
checkIrreducible :: Cox c -> Ab (Cox c)
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)

-- | Calculate content expression.
coxRun :: (CRel c, CList c, Write c) => [c] -> Cox c -> Ab c
instance Name (Cop c)
instance Show (Cop c)
instance Write c => Write (CoxCore c)
instance Write c => Show (CoxCore c)


-- | Relmap operator attributes.
module Koshucode.Baala.Core.Lexmap.Attribute

-- | Relmap operation attributes as association list.
type Roa = [NamedTrees]

-- | Association of operator use and something. Operator use is represented
--   as pair of operator name and attributes.
type Roal a = ((String, Roa), a)

-- | Sorter for attribute of relmap operator. Sorters docompose attribute
--   trees, and give a name to subattribute.
type RoaSorter = [TokenTree] -> Ab Roa

-- | Attribute sorter for relmap operator. It consists of trunk sorter,
--   trunk names, and branch names.
type RoaSpec = (AbMap Roa, [String], [String])

-- | Split attribute into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; roa $ B.tt "a b -x /c 'd -y e"
--   [ ("@trunk", [TreeL (TText 1 0 "a"), TreeL (TText 3 0 "b")])
--   , ("-x", [TreeL (TTerm 7 ["/c"]), TreeL (TText 9 1 "d")])
--   , ("-y", [TreeL (TText 14 0 "e")]) ]
--   </pre>
roa :: [TokenTree] -> Roa
roaBranch :: RoaSorter
roaSorter :: RoaSpec -> RoaSorter

-- | Attribute sorter for no-element trunk.
roaNone :: [String] -> RoaSpec

-- | Attribute sorter for enumerating trunk.
roaEnum :: [String] -> [String] -> RoaSpec

-- | Attribute sorter for multiple-element trunk.
roaList :: String -> [String] -> RoaSpec

-- | Attribute sorter for one-element trunk.
roaOne :: String -> [String] -> RoaSpec

-- | Attribute sorter for two-element trunk.
roaTwo :: String -> String -> [String] -> RoaSpec
roaThree :: String -> String -> String -> [String] -> RoaSpec
roaFour :: String -> String -> String -> String -> [String] -> RoaSpec

-- | Attribute sorter for one-and-multiple-element trunk.
roaOneList :: String -> String -> [String] -> RoaSpec
roaOneOpt :: String -> String -> [String] -> RoaSpec


-- | Slot substitution.
module Koshucode.Baala.Core.Lexmap.Slot
type GlobalSlot = NamedTrees
slotTrees :: [GlobalSlot] -> Roa -> AbMap [TokenTree]


-- | Mapping from attributes to attributes, aka., attribute editor.
module Koshucode.Baala.Core.Lexmap.Roamap

-- | Roamap with source code information.
type Roamap = Sourced RoamapBody

-- | Roamap operators.
data RoamapBody

-- | Identity roamap.
RoamapId :: RoamapBody

-- | Add attribute.
RoamapAdd :: Bool -> String -> [TokenTree] -> RoamapBody

-- | Rename attribute keyword.
RoamapRename :: (String, String) -> RoamapBody

-- | Fill positional attributes.
RoamapFill :: [Maybe TokenTree] -> RoamapBody

-- | Append roamaps.
RoamapAppend :: [Roamap] -> RoamapBody

-- | Construct roamap.
roamapCons :: [TokenTree] -> Ab Roamap

-- | Run roamap.
roamapRun :: Roamap -> AbMap Roa
instance Typeable RoamapBody
instance Show RoamapBody
instance Eq RoamapBody
instance Ord RoamapBody
instance Data RoamapBody


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap.Lexmap

-- | Intermediate data that represents use of relmap operator. Lexmap is
--   constructed from a list of <a>TokenTree</a>, and generic relmap is
--   constructed from a lexmap.
data Lexmap
Lexmap :: LexmapType -> Token -> Roa -> [Lexmap] -> [String] -> Lexmap

-- | Type of lexmap
lexType :: Lexmap -> LexmapType

-- | Token of operator
lexOpToken :: Lexmap -> Token

-- | Attribute of relmap operation
lexAttr :: Lexmap -> Roa

-- | Submaps in the attribute
lexSubmap :: Lexmap -> [Lexmap]

-- | Messages on lexmap
lexMessage :: Lexmap -> [String]
data LexmapType

-- | Built-in relmap
LexmapBase :: LexmapType

-- | User-defined relmap
LexmapDerived :: LexmapType

-- | <tt>-with</tt> variable
LexmapWith :: LexmapType

-- | Name of relmap operator
lexOpName :: Lexmap -> String
lexAddMessage :: String -> Map Lexmap
lexMessageList :: Lexmap -> [String]

-- | First step of constructing relmap, make lexmap from source of relmap
--   operator.
type ConsLexmap = [GlobalSlot] -> [RelmapSource] -> ConsLexmapBody

-- | Construct lexmap and its submaps from source of lexmap
type ConsLexmapBody = [TokenTree] -> Ab (Lexmap, [Roal Lexmap])

-- | Source of relmap: its name, replacement, and attribute editor.
type RelmapSource = Named ([TokenTree], Roamap)
consLexmap :: [Named RoaSorter] -> ConsLexmap

-- | Parse <tt>-with</tt> attribute.
withTerms :: [TokenTree] -> Ab [Terminal String]
instance Typeable LexmapType
instance Typeable Lexmap
instance Show LexmapType
instance Eq LexmapType
instance Ord LexmapType
instance Data LexmapType
instance Show Lexmap
instance Eq Lexmap
instance Ord Lexmap
instance Data Lexmap
instance CodePointer Lexmap
instance Write Lexmap

module Koshucode.Baala.Core.Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relmap.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Relhead -> RelkitBody c -> Relkit c
relkitHead :: Relkit c -> Maybe Relhead
relkitBody :: Relkit c -> RelkitBody c
data RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitAbFull :: Bool -> ([Relbmap c] -> [[c]] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([Relbmap c] -> [c] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([Relbmap c] -> [c] -> Ab [c]) -> [RelkitBody c] -> RelkitCore c
RelkitAbSemi :: ([[c]] -> Ab Bool) -> (RelkitBody c) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitId :: RelkitCore c
RelkitSource :: String -> [TermName] -> RelkitCore c
RelkitLink :: String -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c
RelkitNest :: String -> RelkitCore c
RelkitCopy :: String -> (RelkitBody c) -> RelkitCore c
RelkitWith :: [(String, Int)] -> (RelkitBody c) -> RelkitCore c
type RelkitBody c = Sourced (RelkitCore c)
type RelkitKey = (Maybe Relhead, [Lexmap])
type RelkitDef c = (RelkitKey, Relkit c)

-- | Mapping for body of relation.
type Relbmap c = [[c]] -> Ab [[c]]

-- | Relation selector
type RelSelect c = JudgePat -> [String] -> Rel c
relkit :: Maybe Relhead -> RelkitCore c -> Relkit c
relkitJust :: Relhead -> RelkitCore c -> Relkit c
relkitNothing :: Relkit c
relkitId :: Maybe Relhead -> Relkit c
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [TermName] -> Relkit c
relkitConstSingleton :: [TermName] -> [c] -> Relkit c
relkitConstBody :: [TermName] -> [[c]] -> Relkit c
relkitSource :: String -> [TermName] -> Relkit c
relkitCopy :: String -> Map (Relkit c)
relkitWith :: [(String, Int)] -> Map (Relkit c)
relkitWithVar :: String -> Relhead -> Relkit c
relkitSetSource :: CodePointer a => a -> Map (Relkit c)
instance Show (RelkitCore c)
instance Monoid (Relkit c)


-- | Term content
module Koshucode.Baala.Core.Content


-- | Convert relation to text table.
module Koshucode.Baala.Core.Assert.RelTable
relTable :: (Write c, CRel c) => [ShortDef] -> Rel c -> String
relTableLines :: (Write c, CRel c) => [ShortDef] -> Rel c -> [String]
relText :: (Write c, CRel c) => [ShortDef] -> Rel c -> RelText


-- | Implementation of relmap operators.
module Koshucode.Baala.Core.Relmap.Operator

-- | Implementation of relmap operator
data Rop c
Rop :: String -> String -> RoaSorter -> RopCons c -> String -> Rop c

-- | Operator name
ropName :: Rop c -> String

-- | Operator group
ropGroup :: Rop c -> String

-- | Attribute sorter
ropSorter :: Rop c -> RoaSorter

-- | Constructor of operator
ropCons :: Rop c -> RopCons c

-- | Usage of operator
ropUsage :: Rop c -> String

-- | Use of relmap operator
data RopUse c
RopUse :: Global c -> Lexmap -> [Relmap c] -> RopUse c
ropGlobal :: RopUse c -> Global c

-- | Syntactic data of operator use
ropLexmap :: RopUse c -> Lexmap

-- | Subrelmaps
ropSubrelmap :: RopUse c -> [Relmap c]

-- | Constructor of relmap operator
type RopCons c = RopUse c -> Ab (Relmap c)

-- | Generic relmap.
data Relmap c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgePat -> [TermName] -> Relmap c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap c

-- | Relmap that maps relations to a relation with globals
RelmapGlobal :: Lexmap -> (Global c -> RelkitFlow c) -> Relmap c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap c] -> Relmap c

-- | Relmap for environment of input relation
RelmapCopy :: Lexmap -> String -> (Relmap c) -> Relmap c

-- | Relmap for environment of nested relations
RelmapWith :: Lexmap -> [Terminal String] -> (Relmap c) -> Relmap c

-- | Relmap reference
RelmapLink :: Lexmap -> String -> Roa -> Relmap c

-- | Connect two relmaps
RelmapAppend :: (Relmap c) -> (Relmap c) -> Relmap c

-- | Identity relmap.
relmapId :: Relmap c

-- | Map function to relmaps.
mapToRelmap :: Map (Relmap c) -> Map (Relmap c)
relmapLexList :: Relmap c -> [Lexmap]

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitFlow c = Maybe Relhead -> Ab (Relkit c)

-- | Make <a>Relkit</a> from globals and input heading.
type RelkitGlobal c = Global c -> RelkitFlow c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitFlow c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [(Relkit c)] -> RelkitFlow c
data Global c
Global :: Version -> [Rop c] -> ([Cop c], [Named InfixHeight]) -> String -> [String] -> [Judge c] -> RelSelect c -> Global c
globalVersion :: Global c -> Version
globalRops :: Global c -> [Rop c]
globalCops :: Global c -> ([Cop c], [Named InfixHeight])
globalProgram :: Global c -> String
globalArgs :: Global c -> [String]
globalJudges :: Global c -> [Judge c]
globalSelect :: Global c -> RelSelect c
globalCommandLine :: Global c -> [String]
globalFill :: CContent c => Map (Global c)
global :: Global c
globalSyntax :: Global c -> ([Cop c], [Named InfixHeight])
globalFunction :: Global c -> [Cop c]
instance Show (RopUse c)
instance Show (Global c)
instance Eq (Relmap c)
instance Ord (Relmap c)
instance CodePointer (Relmap c)
instance Write (Relmap c)
instance Name (Relmap c)
instance Monoid (Relmap c)
instance Show (Relmap c)
instance CodePointer (RopUse c)
instance Show (Rop c)


-- | Operations on <a>Relmap</a>.
module Koshucode.Baala.Core.Relmap.Construct

-- | Constructor of lexmap and relmap.
data RelmapCons c
RelmapCons :: ConsLexmap -> (ConsRelmap c) -> RelmapCons c

-- | Second step of constructing relmap, make relmap from lexmap.
type ConsRelmap c = Lexmap -> Ab (Relmap c)

-- | Make a constructor pair of lexmap and relmap.
relmapCons :: Global c -> RelmapCons c

-- | Retrieve relation from dataset.
relmapSource :: RopUse c -> JudgePat -> [TermName] -> (Relmap c)

-- | Make a constant relmap.
relmapConst :: RopUse c -> Rel c -> Relmap c

-- | Make a flow relmap. Flow relmaps take no subrelmaps.
relmapFlow :: RopUse c -> RelkitFlow c -> Relmap c

-- | Make a global relmap. Global relmaps are flow relmaps with globals.
relmapGlobal :: RopUse c -> RelkitGlobal c -> Relmap c

-- | Make a binary relmap. Binary relmaps take one subrelmap.
relmapBinary :: RopUse c -> RelkitBinary c -> Relmap c -> Relmap c

-- | Make a confluent relmap. Confluent relmaps take multiple subrelmaps.
relmapConfl :: RopUse c -> RelkitConfl c -> [Relmap c] -> Relmap c
relmapCopy :: RopUse c -> String -> Map (Relmap c)
relmapWith :: RopUse c -> [Terminal String] -> Map (Relmap c)
relmapWithVar :: RopUse c -> String -> Relmap c
relmapLink :: RopUse c -> String -> Roa -> Relmap c

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap c -> [Relmap c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap c -> [String]
instance Show (RelmapCons c)


-- | Specialize generic relmaps to specific relmaps
module Koshucode.Baala.Core.Relmap.Specialize
relmapSpecialize :: Global c -> [Roal (Relmap c)] -> [RelkitDef c] -> Maybe Relhead -> Relmap c -> Ab ([RelkitDef c], Relkit c)


-- | Link and run relmaps.
module Koshucode.Baala.Core.Relmap.Run
relkitLink :: Ord c => [RelkitDef c] -> Map (Relkit c)
relkitRun :: (Ord c, CRel c) => Global c -> [Named [[c]]] -> RelkitBody c -> AbMap [[c]]
fixedRelation :: Ord c => Map (AbMap [[c]])
bmapAlign :: Relhead -> Relhead -> Map (AbMap [[c]])


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert c
Assert :: AssertType -> JudgePat -> AssertOption -> [Token] -> [TokenTree] -> Maybe (Relmap c) -> [Roal (Relmap c)] -> Assert c

-- | Logical quality
assType :: Assert c -> AssertType

-- | Pattern of judgement
assPattern :: Assert c -> JudgePat

-- | Assert option
assOption :: Assert c -> AssertOption

-- | Source token list
assToken :: Assert c -> [Token]

-- | Token relmap
assTree :: Assert c -> [TokenTree]

-- | Relmap
assRelmap :: Assert c -> Maybe (Relmap c)
assParts :: Assert c -> [Roal (Relmap c)]
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType

-- | Option for assertions.
type AssertOption = [NamedTrees]
assertQuality :: AssertType -> Bool

-- | Assertion list with short signs.
type ShortAssert c = Short [Assert c]

-- | Select affirmative or denial assertions.
assertNormal :: Map [ShortAssert c]

-- | Select violated assertions.
assertViolated :: Map [ShortAssert c]
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType
instance Show (Assert c)
instance Write (Assert c)
instance CodePointer (Assert c)


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges.
emptyDataset :: Dataset c

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
addJudges :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CNil</tt> sign is used.
selectRelation :: (Ord c, CNil c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, Write c, CRel c, CNil c) => Global c -> ShortAssert c -> Ab (OutputChunks c)


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Intermidiate structure between <a>String</a> and <tt>Section</tt>.
module Koshucode.Baala.Core.Section.Clause
type ShortClause = Short [Clause]
data Clause
Clause :: TokenClause -> ClauseBody -> Clause
clauseSource :: Clause -> TokenClause
clauseBody :: Clause -> ClauseBody
data ClauseBody

-- | Section name
CSection :: (Maybe String) -> ClauseBody

-- | Importing section name
CImport :: [Token] -> (Maybe Clause) -> ClauseBody

-- | Exporting relmap name
CExport :: String -> ClauseBody

-- | Short signs
CShort :: [ShortDef] -> ClauseBody

-- | Source of relmap
CRelmap :: String -> [Token] -> ClauseBody

-- | (Intermediate data)
CAssert :: AssertType -> JudgePat -> [Token] -> [Token] -> ClauseBody

-- | Judge
CJudge :: Bool -> JudgePat -> [Token] -> ClauseBody

-- | Global slot
CSlot :: String -> [Token] -> ClauseBody

-- | Clause comment
CComment :: ClauseBody

-- | Unknown clause
CUnknown :: ClauseBody

-- | Unresolved short sign
CUnres :: [Token] -> ClauseBody

-- | Name of clause type. e.g., <tt>"Relmap"</tt>, <tt>"Assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <tt>TTokmap</tt> and <a>CAssert</a> are contained. This function does
--   not depend on <a>ConsLexmap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [ TTokmap ( TokenClause
--                [TText 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TText 1 0 "a", ...]] )
--            "a" [ TText 5 0 "source"
--                , TText 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
--   
--   First step of constructing <tt>Section</tt>.
consClause :: [TokenLine] -> [ShortClause]
consPreclause :: [TokenLine] -> [Clause]
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause
instance CodePointer Clause


-- | Section as bundle of relational expressions.
module Koshucode.Baala.Core.Section.Section
data Section c
Section :: Maybe String -> [Section c] -> [String] -> [NamedTrees] -> [RelmapSource] -> [ShortAssert c] -> [Judge c] -> Resource -> RelmapCons c -> [String] -> Section c

-- | Section name
secName :: Section c -> Maybe String

-- | Importing section
secImport :: Section c -> [Section c]

-- | Exporting relmap names
secExport :: Section c -> [String]

-- | Global slots
secSlot :: Section c -> [NamedTrees]

-- | Source of relmaps
secRelmap :: Section c -> [RelmapSource]

-- | Assertions of relmaps
secAssert :: Section c -> [ShortAssert c]

-- | Affirmative or denial judgements
secJudge :: Section c -> [Judge c]

-- | Resource name
secResource :: Section c -> Resource

-- | Relmap constructor for this section
secCons :: Section c -> RelmapCons c

-- | Collection of messages
secMessage :: Section c -> [String]

-- | Section that has no contents.
emptySection :: Section c

-- | Second step of constructing <a>Section</a>.
consSection :: CContent c => Section c -> Resource -> [ShortClause] -> Ab (Section c)
addMessage :: String -> Map (Section c)
addMessages :: [String] -> Map (Section c)
instance Show c => Show (Section c)
instance Monoid (Section c)

module Koshucode.Baala.Core.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: ConsLexmap -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Read section.
module Koshucode.Baala.Core.Section.Read

-- | Read section from certain resource.
readSection :: CContent c => Section c -> Resource -> IO (Ab (Section c))

-- | Read section from text.
readSectionText :: CContent c => Section c -> String -> Ab (Section c)

-- | Read judges from text.
readJudges :: CContent c => String -> Ab [Judge c]

module Koshucode.Baala.Core.Section.Bundle

-- | Bundle of section resources.
data SectionBundle c
SectionBundle :: Section c -> [String] -> [FilePath] -> [String] -> SectionBundle c
bundleRoot :: SectionBundle c -> Section c
bundleTexts :: SectionBundle c -> [String]
bundleFiles :: SectionBundle c -> [FilePath]
bundleURLs :: SectionBundle c -> [String]
readSectionBundle :: CContent c => SectionBundle c -> IO [Ab (Section c)]
instance Show c => Show (SectionBundle c)


-- | Run section.
module Koshucode.Baala.Core.Section.Run
runSection :: CContent c => Global c -> [Section c] -> Ab (OutputResult c)


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Section

module Koshucode.Baala.Core
