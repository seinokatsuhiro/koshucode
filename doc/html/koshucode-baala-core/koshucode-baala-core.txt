-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.101.0.0

module Koshucode.Baala.Core.Message
abAssert :: CodePtr cp => [cp] -> Map (Ab b)
abAttr :: CodePtr cp => [cp] -> Map (Ab b)
abAttrTrees :: TTreesTo (Map (Ab b))
abClause :: CodePtr cp => [cp] -> Map (Ab b)
abCoxBuild :: TTreeTo (Map (Ab b))
abCoxCalc :: CodePtr cp => [cp] -> Map (Ab b)
abCoxFill :: CodePtr cp => [cp] -> Map (Ab b)
abCoxIrrep :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPosition :: CodePtr cp => [cp] -> Map (Ab b)
abCoxPrefix :: TTreeTo (Map (Ab b))
abCoxReduce :: CodePtr cp => [cp] -> Map (Ab b)
abCoxSyntax :: TTreeTo (Map (Ab b))
abLexmap :: TTreesTo (Map (Ab b))
abLiteral :: TTreeTo (Map (Ab b))
abRelmap :: CodePtr cp => [cp] -> Map (Ab b)
abRun :: CodePtr cp => [cp] -> Map (Ab b)
abSlot :: CodePtr cp => [cp] -> Map (Ab b)
abSlotTree :: TTreeTo (Map (Ab b))
abSpecialize :: CodePtr cp => [cp] -> Map (Ab b)

-- | Ambiguous infix operators
ambInfixes :: [String] -> Ab a

-- | Ambiguous relmaps
ambRelmap :: String -> [d] -> Ab a

-- | Unexpected attribute / Duplicate
dupAttr :: [String] -> Ab a

-- | Duplicate prefix
dupPrefix :: [String] -> Ab a

-- | Duplicate replacement
dupReplacement :: [String] -> Ab a

-- | Empty literal
emptyLiteral :: Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | HTTP Error
httpError :: String -> Int -> String -> Ab a

-- | Invalid prefix character
invalidPrefix :: [String] -> Ab a

-- | Lack of argument
lackArg :: String -> Ab a

-- | File not found
noFile :: String -> Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Nothing
nothing :: Ab a

-- | Odd relation literal
oddRelation :: Ab a

-- | Quoted type name
quoteType :: String -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Require flat name
reqFlatName :: Token -> Ab a

-- | Require grouping paren
reqGroup :: Ab a

-- | Require term name
reqTermName :: Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a
unexpAttr0 :: Ab a
unexpAttr1 :: Ab a
unexpAttr2 :: Ab a
unexpAttr3 :: Ab a
unexpAttr4 :: Ab a
unexpAttr1V :: Ab a
unexpAttr1Q :: Ab a
unexpAttrT1 :: Ab a
unexpAttrT2 :: Ab a

-- | Unknown bracket
unkBracket :: Ab a

-- | Unknown clause
unkClause :: [String] -> Ab a

-- | Unknown content operator
unkCop :: String -> Ab a

-- | Unknown expression
unkCox :: String -> Ab a

-- | Unknown global variable
unkGlobalVar :: String -> Ab a

-- | Unknown nested relation
unkNestRel :: Token -> String -> [String] -> Ab a
unkNestVar :: String -> [Token] -> [((Token, Local String), Head)] -> Ab a

-- | Unknown option
unkOption :: ParaUnmatch String -> Ab a

-- | Unknown reference for variable
unkRefVar :: (String, Int) -> [String] -> Ab a

-- | Unknown relmap operator
unkRelmap :: String -> Ab a

-- | Unknown object
unkShow :: Show x => x -> Ab a

-- | Unknown term name
unkTerm :: [TermName] -> Head -> Ab a

-- | Unknown type name
unkType :: String -> Ab a

-- | Unknown word
unkWord :: String -> Ab a
unmatchType :: String -> Ab a

-- | Unmatch blank (bug)
unmatchBlank :: String -> Int -> String -> [String] -> Ab a

-- | Unresolved prefix
unresPrefix :: String -> Ab a
detailTermRel :: String -> [String] -> Head -> [String]
expectActual :: String -> String -> [String]
expect2Actual :: String -> String -> String -> [String]

module Koshucode.Baala.Core.Content.Class
class (Ord c, Write c, CTypeOf c, CEmpty c, CBool c, CText c, CClock c, CTime c, CTerm c, CDec c, CType c, CInterp c, CList c, CSet c, CAssn c, CRel c) => CContent c where joinContent = foldM appendContent empty
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c
class (Show c, Write c) => CTypeOf c
typeOf :: CTypeOf c => c -> Type
class CTypeOf c => CBool c where getBool = getAbAb isBool gBool putBool = Right . pBool
isBool :: CBool c => c -> Bool
pBool :: CBool c => Bool -> c
gBool :: CBool c => c -> Bool
getBool :: CBool c => Ab c -> Ab Bool
putBool :: CBool c => Bool -> Ab c
true :: CBool c => c
false :: CBool c => c
class CTypeOf c => CText c where getText = getAbAb isText gText putText = Right . pText
isText :: CText c => c -> Bool
gText :: CText c => c -> String
pText :: CText c => String -> c
getText :: CText c => Ab c -> Ab String
putText :: CText c => String -> Ab c
pTextList :: (CText c, CList c) => [String] -> c
pTextSet :: (CText c, CSet c) => [String] -> c
class CTypeOf c => CList c where getList = getAbAb isList gList putList = Right . pList
isList :: CList c => c -> Bool
gList :: CList c => c -> [c]
pList :: CList c => [c] -> c
getList :: CList c => Ab c -> Ab [c]
putList :: CList c => [c] -> Ab c

-- | Types that can be empty
class CTypeOf c => CEmpty c
isEmpty :: CEmpty c => c -> Bool
empty :: CEmpty c => c
maybeEmpty :: CEmpty c => (a -> c) -> Maybe a -> c
omitEmpty :: CEmpty c => Map [(a, c)]
class CTypeOf c => CDec c where getDec = getAbAb isDec gDec putDec = Right . pDec
isDec :: CDec c => c -> Bool
gDec :: CDec c => c -> Decimal
pDec :: CDec c => Decimal -> c
getDec :: CDec c => Ab c -> Ab Decimal
putDec :: CDec c => Decimal -> Ab c
pDecFromInt :: CDec c => Int -> c
pDecFromInteger :: CDec c => Integer -> c
class CTypeOf c => CClock c where getClock = getAbAb isClock gClock putClock = Right . pClock
isClock :: CClock c => c -> Bool
gClock :: CClock c => c -> Clock
pClock :: CClock c => Clock -> c
getClock :: CClock c => Ab c -> Ab Clock
putClock :: CClock c => Clock -> Ab c
class CTypeOf c => CTime c where getTime = getAbAb isTime gTime putTime = Right . pTime
isTime :: CTime c => c -> Bool
gTime :: CTime c => c -> Time
pTime :: CTime c => Time -> c
getTime :: CTime c => Ab c -> Ab Time
putTime :: CTime c => Time -> Ab c
class CTypeOf c => CTerm c where getTerm = getAbAb isTerm gTerm putTerm = Right . pTerm
isTerm :: CTerm c => c -> Bool
gTerm :: CTerm c => c -> String
pTerm :: CTerm c => String -> c
getTerm :: CTerm c => Ab c -> Ab String
putTerm :: CTerm c => String -> Ab c
class CTypeOf c => CSet c where getSet = getAbAb isSet gSet putSet = Right . pSet
isSet :: CSet c => c -> Bool
gSet :: CSet c => c -> [c]
pSet :: CSet c => [c] -> c
getSet :: CSet c => Ab c -> Ab [c]
putSet :: CSet c => [c] -> Ab c
class CTypeOf c => CAssn c where getAssn = getAbAb isAssn gAssn putAssn = Right . pAssn
isAssn :: CAssn c => c -> Bool
gAssn :: CAssn c => c -> [Named c]
pAssn :: CAssn c => [Named c] -> c
getAssn :: CAssn c => Ab c -> Ab [Named c]
putAssn :: CAssn c => [Named c] -> Ab c
class CTypeOf c => CRel c where getRel = getAbAb isRel gRel putRel = Right . pRel
isRel :: CRel c => c -> Bool
gRel :: CRel c => c -> Rel c
pRel :: CRel c => Rel c -> c
getRel :: CRel c => Ab c -> Ab (Rel c)
putRel :: CRel c => Rel c -> Ab c
isMember :: (Eq c, CSet c, CList c) => c -> c -> Bool
class CTypeOf c => CInterp c where getInterp = getAbAb isInterp gInterp putInterp = Right . pInterp
isInterp :: CInterp c => c -> Bool
gInterp :: CInterp c => c -> Interp
pInterp :: CInterp c => Interp -> c
getInterp :: CInterp c => Ab c -> Ab Interp
putInterp :: CInterp c => Interp -> Ab c
class CTypeOf c => CType c where getType = getAbAb isType gType putType = Right . pType
isType :: CType c => c -> Bool
gType :: CType c => c -> Type
pType :: CType c => Type -> c
getType :: CType c => Ab c -> Ab Type
putType :: CType c => Type -> Ab c
contAp :: (c -> a) -> (b -> d) -> (a -> b) -> c -> d
contMap :: (c -> [a]) -> ([b] -> d) -> (a -> b) -> c -> d
contApTextToText :: CText c => Map String -> AbMap c
contMapTextToList :: (CList c, CText c) => (Char -> c) -> AbMap c


-- | Term-content expression.
module Koshucode.Baala.Core.Content.Cox

-- | Term-content expressions.
data Cox c

-- | Literal content
CoxLit :: [CodePt] -> c -> Cox c

-- | Term reference, its name and position
CoxTerm :: [CodePt] -> [TermName] -> [Int] -> Cox c

-- | Content calculator
CoxCalc :: [CodePt] -> BlankName -> (CopCalc c) -> Cox c

-- | Local blank, its name and De Bruijn index
CoxLocal :: [CodePt] -> String -> Int -> Cox c

-- | Blank in form
CoxBlank :: [CodePt] -> BlankName -> Cox c

-- | Fill args in a form
CoxFill :: [CodePt] -> (Cox c) -> [Cox c] -> Cox c

-- | Form with single blank
CoxForm1 :: [CodePt] -> CoxTag -> String -> (Cox c) -> Cox c

-- | Form with multiple blanks
CoxForm :: [CodePt] -> CoxTag -> [String] -> (Cox c) -> Cox c

-- | Cox with outside arguments
CoxWith :: [CodePt] -> [NamedCox c] -> (Cox c) -> Cox c
type MaybeCox c = Maybe (Cox c)
type NamedCox c = Named (Cox c)

-- | Term-content calculator.
type CopCalc c = [Ab c] -> Ab c
type CoxTag = Maybe String
coxLit :: c -> Cox c
coxSyntacticArity :: Cox c -> Int
coxMap :: Map (Map (Cox c))
coxCall :: Cox c -> (Map (Cox c)) -> Cox c
checkIrreducible :: AbMap (Cox c)
instance Write c => Write (Cox c)
instance Write c => Show (Cox c)
instance CodePtr (Cox c)


-- | Term-content operator.
module Koshucode.Baala.Core.Content.Cop

-- | Term-content operator.
data Cop c

-- | Convert <tt>c</tt> (content)
CopCalc :: BlankName -> (CopCalc c) -> Cop c

-- | Convert <a>Cox</a> c
CopCox :: BlankName -> (CopCox c) -> Cop c

-- | Convert <a>TTree</a>
CopTree :: BlankName -> (CopTree) -> Cop c

-- | Expression-level syntax.
type CopCox c = [Cox c] -> Ab (Cox c)

-- | Tree-level syntax.
type CopTree = [TTree] -> Ab TTree
copName :: Cop c -> BlankName

-- | Name for non-binary operator.
copNormal :: String -> BlankName

-- | Name for program-generated operator.
copInternal :: String -> BlankName

-- | Name for prefix operator.
copPrefix :: String -> BlankName

-- | Name for infix operator.
copInfix :: String -> BlankName

-- | Name for postfix operator.
copPostfix :: String -> BlankName
data CopSet c
CopSet :: [Cop c] -> [Named InfixHeight] -> [Named (Cop c)] -> [Named (Cop c)] -> [Named (Cop c)] -> CopFind (Cox c) -> CopFind (CopCox c) -> CopFind CopTree -> [NamedCox c] -> CopSet c
copsetCopList :: CopSet c -> [Cop c]
copsetInfixList :: CopSet c -> [Named InfixHeight]
copsetCalcList :: CopSet c -> [Named (Cop c)]
copsetCoxList :: CopSet c -> [Named (Cop c)]
copsetTreeList :: CopSet c -> [Named (Cop c)]
copsetFindCalc :: CopSet c -> CopFind (Cox c)
copsetFindCox :: CopSet c -> CopFind (CopCox c)
copsetFindTree :: CopSet c -> CopFind CopTree
copsetDerived :: CopSet c -> [NamedCox c]

-- | Find content operator from its name.
type CopFind f = BlankName -> Maybe f

-- | Empty operator set.
copset :: CopSet c
copsetFill :: Map (CopSet c)
instance Name (Cop c)
instance Show (Cop c)


-- | Utilities for token trees.
module Koshucode.Baala.Core.Content.Tree
treesToTokens :: TTreesToAb [Token]
treesToTexts :: Bool -> TTreesToAb [String]
treeToText :: Bool -> TTreeToAb String
treesToDigits :: TTreesToAb String
tokenClock :: Token -> Ab Clock
treesToTime :: TTreesToAb Time

-- | Get flat term name from token tree. If the token tree contains nested
--   term name, this function failed.
treeToFlatTerm :: TTreeToAb TermName

-- | Convert token trees into a list of named token trees.
treesToTerms :: TTreesToAb [NamedTrees]
treesToTerms1 :: TTreesToAb [NamedTree]
treesToInterp :: TTreesToAb Interp


-- | Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal

-- | Content calculator.
type CalcContent c = TTreeToAb c

-- | Convert token tree into internal form of content.
literal :: CContent c => CalcContent c -> TTreeToAb c

-- | Convert token trees into a judge. Judges itself are not content type.
--   It can be only used in the top-level of resources.
treesToJudge :: CContent c => CalcContent c -> AssertType -> JudgePat -> TTreesToAb (Judge c)
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=x</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=xx</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertMultiDeny :: AssertType

-- | <tt>|=c</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertChange :: AssertType

-- | <tt>|=cc</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertMultiChange :: AssertType

-- | <tt>|=v</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertAs :: AssertType -> JudgeOf c
assertSymbol :: AssertType -> String
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Build

-- | Construct content expression from token tree
coxBuild :: CContent c => CalcContent c -> CopSet c -> TTreeToAb (Cox c)

-- | Insert fresh form into indexed expression.
coxForm :: [CodePt] -> CoxTag -> [String] -> Map (Cox c)


-- | Term-content calcutation.
module Koshucode.Baala.Core.Content.Run
type RunCox c = Cox c -> Ab c
type RunList c = [c] -> Ab c
coxRunCox :: (Write c, CRel c, CList c) => CopSet c -> Head -> [c] -> RunCox c
coxRunList :: (Write c, CRel c, CList c) => CopSet c -> Head -> Cox c -> RunList c
calcContent :: CContent c => CopSet c -> CalcContent c
getArg1 :: [Ab c] -> Ab (Ab c)
getArg2 :: [Ab c] -> Ab (Ab c, Ab c)
getArg3 :: [Ab c] -> Ab (Ab c, Ab c, Ab c)
instance CodePtr (Beta c)


-- | Positional attributes.
module Koshucode.Baala.Core.Lexmap.AttrPos
data AttrPos a
AttrPos0 :: AttrPos a
AttrPos1 :: a -> AttrPos a
AttrPos2 :: a -> a -> AttrPos a
AttrPos3 :: a -> a -> a -> AttrPos a
AttrPos4 :: a -> a -> a -> a -> AttrPos a
AttrPosE :: [a] -> AttrPos a
AttrPosV :: a -> AttrPos a
AttrPos1V :: a -> a -> AttrPos a
AttrPos1Q :: a -> a -> AttrPos a
AttrPosT1 :: a -> a -> AttrPos a
AttrPosT2 :: a -> a -> a -> AttrPos a
attrTypeNames :: AttrPos a -> [a]
ropAttrPos :: AttrPos AttrName -> AttrSortTree
type AttrSortTree = [TTree] -> Ab [AttrTree]

-- | Attribute name and its contents.
type AttrTree = (AttrName, [TTree])

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: String -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: String -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName
instance Typeable AttrName
instance Show a => Show (AttrPos a)
instance Eq a => Eq (AttrPos a)
instance Ord a => Ord (AttrPos a)
instance Show AttrName
instance Eq AttrName
instance Ord AttrName
instance Data AttrName


-- | Attributes of relmap operator.
module Koshucode.Baala.Core.Lexmap.Attr

-- | Definition of attribute sorter.
data RopAttr
RopAttr :: AttrSortTree -> Map AttrName -> AttrPos AttrName -> [AttrName] -> [AttrName] -> RopAttr
attrPosSorter :: RopAttr -> AttrSortTree
attrClassifier :: RopAttr -> Map AttrName
attrPos :: RopAttr -> AttrPos AttrName
attrPosNames :: RopAttr -> [AttrName]
attrBranchNames :: RopAttr -> [AttrName]
ropAttrCons :: AttrPos AttrName -> [AttrName] -> RopAttr
type AttrPara = ParaBody AttrName TTree

-- | Sorter for attribute of relmap operator. Sorters docompose attribute
--   trees, and give a name to subattribute.
type AttrSortPara = [TTree] -> Ab AttrPara
attrSort :: RopAttr -> AttrSortPara
attrBranch :: AttrSortPara
maybeHyname :: TTreeTo (Maybe String)


-- | Lexical relmap.
module Koshucode.Baala.Core.Lexmap.Lexmap

-- | Intermediate data that represents use of relmap operator. Lexmap is
--   constructed from a list of <a>TTree</a>, and generic relmap is
--   constructed from a lexmap.
data Lexmap
Lexmap :: LexmapType -> Token -> AttrPara -> [Lexmap] -> [String] -> Lexmap

-- | Type of lexmap
lexType :: Lexmap -> LexmapType

-- | Token of operator
lexToken :: Lexmap -> Token

-- | Attribute of relmap operation
lexAttr :: Lexmap -> AttrPara

-- | Submaps in the attribute
lexSubmap :: Lexmap -> [Lexmap]

-- | Messages on lexmap
lexMessage :: Lexmap -> [String]
data LexmapType

-- | Built-in relmap
LexmapBase :: LexmapType

-- | User-defined relmap
LexmapDerived :: LexmapType

-- | Local relation reference
LexmapLocal :: LexmapType

-- | Name of relmap operator.
type RopName = String

-- | Empty base lexmap.
lexBase :: Lexmap

-- | Name of relmap operator
lexName :: Lexmap -> RopName
lexAddMessage :: String -> Map Lexmap
lexMessageList :: Lexmap -> [String]

-- | Attribute of relmap operation.
lexAttrTree :: Lexmap -> [AttrTree]
instance Typeable LexmapType
instance Typeable Lexmap
instance Show LexmapType
instance Eq LexmapType
instance Ord LexmapType
instance Data LexmapType
instance Show Lexmap
instance Eq Lexmap
instance Ord Lexmap
instance Data Lexmap
instance CodePtr Lexmap
instance Write Lexmap


-- | Slot substitution.
module Koshucode.Baala.Core.Lexmap.Slot
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [TTree]


-- | Attribute mapping, or attribute editor.
module Koshucode.Baala.Core.Lexmap.Attrmap

-- | Attribute mapping with source code information.
type Attrmap = Sourced AttrmapBody

-- | Operators for attribute mappings.
data AttrmapBody

-- | Identity mapping
AttrmapId :: AttrmapBody

-- | Add attribute
AttrmapAdd :: Bool -> String -> [TTree] -> AttrmapBody

-- | Rename attribute keyword
AttrmapRename :: (String, String) -> AttrmapBody

-- | Fill positional attributes
AttrmapFill :: [Maybe TTree] -> AttrmapBody

-- | Append mappings
AttrmapAppend :: [Attrmap] -> AttrmapBody

-- | Construct attribute mapping.
consAttrmap :: [TTree] -> Ab Attrmap

-- | Edit relmap attributes.
runAttrmap :: Attrmap -> AbMap [AttrTree]
instance Typeable AttrmapBody
instance Show AttrmapBody
instance Eq AttrmapBody
instance Ord AttrmapBody
instance Data AttrmapBody


-- | Construction of lexical relmaps.
module Koshucode.Baala.Core.Lexmap.Construct

-- | First step of constructing relmap, construct lexmap from token trees.
--   The function returns lexmap and related lexmap links.
consLexmap :: FindSorter -> ConsLexmap
type ConsLexmap = [GlobalSlot] -> FindDeriv -> SecNo -> ConsLexmapBody

-- | Find derived relmap operator.
type FindDeriv = SecNo -> RopName -> [RelmapSource]

-- | Source of relmap: its name, replacement, and attribute editor.
type RelmapSource = NNamed ([TTree], Attrmap)

-- | Section number.
type SecNo = Int

-- | Numbered name.
type NName = (SecNo, String)

-- | Pair which key is a numbered name.
type NNamed a = (NName, a)

-- | Find attribute sorter of relmap operator.
type FindSorter = RopName -> Maybe AttrSortPara
type ConsLexmapBody = [TTree] -> Ab (Lexmap, LexmapLinkTable)
type LexmapLinkTable = [(Lexmap, Lexmap)]

module Koshucode.Baala.Core.Lexmap


-- | Specialized relmap.
module Koshucode.Baala.Core.Relkit.Relkit

-- | Specialized relmap.
data Relkit c
Relkit :: Maybe Head -> Maybe Head -> RelkitBody c -> Relkit c
relkitInput :: Relkit c -> Maybe Head
relkitOutput :: Relkit c -> Maybe Head
relkitBody :: Relkit c -> RelkitBody c
data RelkitCore c
RelkitFull :: Bool -> ([[c]] -> [[c]]) -> RelkitCore c
RelkitOneToMany :: Bool -> ([c] -> [[c]]) -> RelkitCore c
RelkitOneToOne :: Bool -> ([c] -> [c]) -> RelkitCore c
RelkitPred :: ([c] -> Bool) -> RelkitCore c
RelkitAbFull :: Bool -> ([Relbmap c] -> [[c]] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbMany :: Bool -> ([Relbmap c] -> [c] -> Ab [[c]]) -> [RelkitBody c] -> RelkitCore c
RelkitOneToAbOne :: Bool -> ([Relbmap c] -> [c] -> Ab [c]) -> [RelkitBody c] -> RelkitCore c
RelkitAbSemi :: ([[c]] -> Ab Bool) -> (RelkitBody c) -> RelkitCore c
RelkitAbPred :: ([c] -> Ab Bool) -> RelkitCore c
RelkitAppend :: (RelkitBody c) -> (RelkitBody c) -> RelkitCore c
RelkitConst :: [[c]] -> RelkitCore c
RelkitId :: RelkitCore c
RelkitSource :: JudgePat -> [TermName] -> RelkitCore c
RelkitLink :: RopName -> RelkitKey -> (Maybe (RelkitBody c)) -> RelkitCore c
RelkitCopy :: Token -> RopName -> (RelkitBody c) -> RelkitCore c
RelkitNestVar :: Token -> RopName -> RelkitCore c
RelkitNest :: Token -> [(String, Int)] -> (RelkitBody c) -> RelkitCore c
type RelkitBody c = Sourced (RelkitCore c)
type RelkitKey = (Maybe Head, [Lexmap])
type RelkitDef c = (RelkitKey, Relkit c)

-- | Mapping for body of relation.
type Relbmap c = [[c]] -> Ab [[c]]

-- | Relation selector
type RelSelect c = JudgePat -> [String] -> Rel c

-- | Make <a>Relkit</a> from heading of input relation.
type RelkitFlow c = Maybe Head -> Ab (Relkit c)

-- | Make <a>Relkit</a> from hook data and input heading.
type RelkitHook' h c = h c -> RelkitFlow c

-- | Make <a>Relkit</a> from one subrelmap and input heading.
type RelkitBinary c = Relkit c -> RelkitFlow c

-- | Make <a>Relkit</a> from multiple subrelmaps and input heading.
type RelkitConfl c = [Relkit c] -> RelkitFlow c
instance Show (RelkitCore c)


-- | Relkit constructors.
module Koshucode.Baala.Core.Relkit.Construct
relkit :: Maybe Head -> RelkitCore c -> Relkit c
relkitId :: Maybe Head -> Relkit c
relkitJust :: Head -> RelkitCore c -> Relkit c
relkitNothing :: Relkit c
relkitSetSource :: CodePtr a => a -> Map (Relkit c)
relkitConst :: Rel c -> Relkit c
relkitConstEmpty :: [TermName] -> Relkit c
relkitConstSingleton :: [TermName] -> [c] -> Relkit c
relkitConstBody :: [TermName] -> [[c]] -> Relkit c
relkitSource :: JudgePat -> [TermName] -> Relkit c
relkitCopy :: Token -> String -> Map (Relkit c)
relkitNest :: Token -> [(String, Int)] -> Map (Relkit c)
relkitNestVar :: Token -> String -> Head -> Relkit c
type Local a = Lexical [Named a]
type Lexical a = (Token, a)
localsLines :: [Local a] -> [String]
a2lookup :: (Eq a, Eq b) => a -> b -> [(a, [(b, c)])] -> Maybe c
instance Monoid (Relkit c)


-- | Content of term in judgement.
module Koshucode.Baala.Core.Content


-- | Convert relation to text table.
module Koshucode.Baala.Core.Assert.RelTable
relTable :: (Write c, CRel c) => [ShortDef] -> Rel c -> String
relTableLines :: (Write c, CRel c) => [ShortDef] -> Rel c -> [String]
relText :: (Write c, CRel c) => [ShortDef] -> Rel c -> RelText


-- | Link and run relmaps.
module Koshucode.Baala.Core.Relkit.Run
relkitLink :: Ord c => [RelkitDef c] -> Map (Relkit c)
relkitRun :: (Ord c, CRel c, SelectRel h) => h c -> [Local [[c]]] -> RelkitBody c -> AbMap [[c]]
fixedRelation :: Ord c => Map (AbMap [[c]])
bmapAlign :: Head -> Head -> Map (AbMap [[c]])


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relkit


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Dataset that has no judges.
datasetEmpty :: Dataset c

-- | Gather judges into a dataset.
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
datasetAdd :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CEmpty</tt> sign is used.
datasetSelect :: (Ord c, CEmpty c) => Dataset c -> RelSelect c


-- | Generic relmap.
module Koshucode.Baala.Core.Relmap.Relmap

-- | Generic relmap.
data Relmap' h c

-- | Constant relation
RelmapConst :: Lexmap -> (Rel c) -> Relmap' h c

-- | Retrieve a relation from a dataset
RelmapSource :: Lexmap -> JudgePat -> [TermName] -> Relmap' h c

-- | Relmap that maps relations to a relation
RelmapCalc :: Lexmap -> (RelkitConfl c) -> [Relmap' h c] -> Relmap' h c

-- | Relmap that maps relations to a relation with hook data
RelmapHook :: Lexmap -> (RelkitHook' h c) -> Relmap' h c

-- | Relmap for environment of input relation
RelmapCopy :: Lexmap -> String -> (Relmap' h c) -> Relmap' h c

-- | Relmap for environment of nested relations
RelmapNest :: Lexmap -> (Relmap' h c) -> Relmap' h c

-- | Relmap reference
RelmapLink :: Lexmap -> Relmap' h c

-- | Connect two relmaps
RelmapAppend :: (Relmap' h c) -> (Relmap' h c) -> Relmap' h c

-- | Identity relmap.
relmapId :: Relmap' h c
relmapLexmaps :: Relmap' h c -> [Lexmap]

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap' h c -> [Relmap' h c]

-- | List of name in <a>RelmapLink</a>
relmapNameList :: Relmap' h c -> [String]
instance Eq (Relmap' h c)
instance Ord (Relmap' h c)
instance CodePtr (Relmap' h c)
instance Write (Relmap' h c)
instance Name (Relmap' h c)
instance Monoid (Relmap' h c)
instance Show (Relmap' h c)


-- | Relmap operators.
module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator.
data Rop' h c
Rop :: RopName -> String -> RopUsage -> RopAttr -> AttrSortPara -> RopCons' h c -> Rop' h c

-- | Operator name
ropName :: Rop' h c -> RopName

-- | Operator group
ropGroup :: Rop' h c -> String

-- | Usage text of operator
ropUsage :: Rop' h c -> RopUsage

-- | Attribute of operator
ropAttr :: Rop' h c -> RopAttr

-- | Attribute sorter
ropSorter :: Rop' h c -> AttrSortPara

-- | Constructor of operator
ropCons :: Rop' h c -> RopCons' h c

-- | Usage text of operator.
type RopUsage = String
type FindRop' h c = RopName -> Maybe (Rop' h c)

-- | Constructor of relmap operator, i.e., function from intermediate
--   relamp to generic relmap.
type RopCons' h c = Intmed' h c -> Ab (Relmap' h c)

-- | Intermediate relmap, that is in between lexmap and generic relmap.
data Intmed' h c
Intmed :: h c -> Lexmap -> [Relmap' h c] -> Intmed' h c
medHook :: Intmed' h c -> h c

-- | Syntactic data of operator use
medLexmap :: Intmed' h c -> Lexmap

-- | Subrelmaps
medSubmap :: Intmed' h c -> [Relmap' h c]
instance Show (h c) => Show (Intmed' h c)
instance CodePtr (Intmed' h c)
instance Name (Rop' h c)
instance Show (Rop' h c)


-- | Construction of relmaps.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make a constant relmap.
relmapConst :: Intmed' h c -> Rel c -> Relmap' h c

-- | Relmap for retrieving relation from dataset.
relmapSource :: Intmed' h c -> JudgePat -> [TermName] -> Relmap' h c

-- | Make a flow relmap. Flow relmaps take no submaps.
relmapFlow :: Intmed' h c -> RelkitFlow c -> Relmap' h c
relmapHook :: Intmed' h c -> RelkitHook' h c -> Relmap' h c

-- | Make a binary relmap. Binary relmaps take one submap.
relmapBinary :: Intmed' h c -> RelkitBinary c -> Relmap' h c -> Relmap' h c

-- | Make a confluent relmap. Confluent relmaps take multiple submaps.
relmapConfl :: Intmed' h c -> RelkitConfl c -> [Relmap' h c] -> Relmap' h c

-- | Parent for nested relation references.
relmapNest :: Intmed' h c -> Map (Relmap' h c)
relmapCopy :: Intmed' h c -> RopName -> Map (Relmap' h c)
relmapLink :: Intmed' h c -> Relmap' h c
relmapLocalSymbol :: Intmed' h c -> String -> Relmap' h c
relmapLocalNest :: Intmed' h c -> String -> Relmap' h c

-- | Second step of constructing relmap, make relmap from lexmap.
type ConsRelmap' h c = Lexmap -> Ab (Relmap' h c)

-- | Construct relmap from lexmap.
consRelmap :: FindRop' h c -> h c -> ConsRelmap' h c


-- | Specialize generic relmaps to specific relmaps
module Koshucode.Baala.Core.Relmap.Specialize
relmapSpecialize :: h c -> RelmapLinkTable' h c -> [RelkitDef c] -> Maybe Head -> Relmap' h c -> Ab ([RelkitDef c], Relkit c)
type RelmapLinkTable' h c = [(Lexmap, Relmap' h c)]


-- | Global parameters.
module Koshucode.Baala.Core.Relmap.Global

-- | Global parameters
data Global' h c
Global :: String -> Version -> OpSet' h c -> String -> [String] -> [HttpProxy] -> Time -> Int -> [CodePiece] -> h c -> Global' h c

-- | One-line description of calculator
globalSynopsis :: Global' h c -> String

-- | Version of calculator
globalVersion :: Global' h c -> Version

-- | Set of operators
globalOpset :: Global' h c -> OpSet' h c

-- | Name of invoked program
globalProgram :: Global' h c -> String

-- | Command line arguments
globalArgs :: Global' h c -> [String]

-- | Proxy setting from environment variables
globalProxy :: Global' h c -> [HttpProxy]

-- | Invocation time
globalTime :: Global' h c -> Time

-- | Sequential number for sources
globalSourceCount :: Global' h c -> Int

-- | Included sources
globalSources :: Global' h c -> [CodePiece]

-- | Usually, data resource is used as hook
globalHook :: Global' h c -> h c
globalVersionText :: Global' h c -> String
globalCommandLine :: Global' h c -> [String]
globalFill :: CContent c => Map (Global' h c)
globalRops :: Global' h c -> [Rop' h c]
globalRopsAdd :: [Rop' h c] -> Map (Global' h c)
globalCops :: Global' h c -> [Cop c]
globalCopset :: Global' h c -> CopSet c
globalInfix :: Global' h c -> [Named InfixHeight]

-- | Empty global parameters.
global' :: h c -> Global' h c
class GetGlobal h
getGlobal :: GetGlobal h => h c -> Global' h c
ropGlobal :: GetGlobal h => Intmed' h c -> Global' h c

-- | Get operator set from <tt>Intmed</tt>.
ropCopset :: GetGlobal h => Intmed' h c -> CopSet c

-- | Set of relmap and content operators.
data OpSet' h c
OpSet :: [Rop' h c] -> FindRop' h c -> CopSet c -> OpSet' h c
opsetRopList :: OpSet' h c -> [Rop' h c]
opsetFindRop :: OpSet' h c -> FindRop' h c
opsetCop :: OpSet' h c -> CopSet c

-- | Empty operator set.
opset :: OpSet' h c
opsetFill :: Map (OpSet' h c)
instance Show (Global' h c)


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Affirming or denying relation. It consists of logical quality,
--   judgement pattern, and relmap. See also <a>Judge</a>
data Assert' h c
Assert :: SecNo -> AssertType -> JudgePat -> TokenPara -> [Token] -> [TTree] -> Maybe (Relmap' h c) -> RelmapLinkTable' h c -> Assert' h c

-- | Section number
assSection :: Assert' h c -> SecNo

-- | Logical quality
assType :: Assert' h c -> AssertType

-- | Pattern of judgement
assPattern :: Assert' h c -> JudgePat

-- | Assert option
assOption :: Assert' h c -> TokenPara

-- | Source token list
assToken :: Assert' h c -> [Token]

-- | Token relmap
assTree :: Assert' h c -> [TTree]

-- | Relmap
assRelmap :: Assert' h c -> Maybe (Relmap' h c)
assLinks :: Assert' h c -> RelmapLinkTable' h c
type TokenPara = Para TTree
tokenPara :: [Token] -> Ab TokenPara

-- | Assertion with short signs.
type ShortAssert' h c = Short (Assert' h c)

-- | Assertion list with short signs.
type ShortAsserts' h c = Short [Assert' h c]

-- | Select affirmative or denial assertions.
assertNormal :: Map [ShortAssert' h c]

-- | Select violated assertions.
assertViolated :: Map [ShortAssert' h c]
instance Show (Assert' h c)
instance Write (Assert' h c)
instance CodePtr (Assert' h c)


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, Write c, CRel c, CEmpty c, SelectRel h, GetGlobal h) => h c -> ShortAsserts' h c -> Ab (OutputChunks c)


-- | Intermidiate structure between <a>String</a> and <tt>Resource</tt>.
module Koshucode.Baala.Core.Resource.Clause
data Clause
Clause :: ClauseHead -> ClauseBody -> Clause
clauseHead :: Clause -> ClauseHead
clauseBody :: Clause -> ClauseBody
data ClauseHead
ClauseHead :: TokenClause -> SecNo -> [ShortDef] -> [Token] -> ClauseHead
clauseSource :: ClauseHead -> TokenClause
clauseSecNo :: ClauseHead -> SecNo
clauseShort :: ClauseHead -> [ShortDef]
clauseAbout :: ClauseHead -> [Token]
data ClauseBody

-- | Includeing source
CInclude :: [Token] -> ClauseBody

-- | Exporting name
CExport :: String -> ClauseBody

-- | Source of relmap
CRelmap :: String -> [Token] -> ClauseBody

-- | Assertion
CAssert :: AssertType -> JudgePat -> [Token] -> [Token] -> ClauseBody

-- | Judge
CJudge :: AssertType -> JudgePat -> [Token] -> ClauseBody

-- | Global slot
CSlot :: String -> [Token] -> ClauseBody

-- | The empty clause heading.
clauseHeadEmpty :: ClauseHead

-- | Name of clause type. e.g., <tt>"relmap"</tt>, <tt>"assert"</tt>.
clauseTypeText :: Clause -> String

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <tt>TTokmap</tt> and <a>CAssert</a> are contained. This function does
--   not depend on <a>ConsLexmap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consClause . B.tokenize $ "a : source A /x /y"
--   [ TTokmap ( TokenClause
--                [TText 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TText 1 0 "a", ...]] )
--            "a" [ TText 5 0 "source"
--                , TText 7 0 "A"
--                , TTerm 9 ["/x"]
--                , TTerm 11 ["/y"]
--                ]]
--   </pre>
--   
--   First step of constructing <tt>Resource</tt>.
consClause :: SecNo -> [TokenLine] -> [Ab Clause]
instance Typeable ClauseHead
instance Typeable ClauseBody
instance Typeable Clause
instance Show ClauseHead
instance Data ClauseHead
instance Show ClauseBody
instance Data ClauseBody
instance Show Clause
instance Data Clause
instance CodePtr ClauseHead
instance CodePtr Clause


-- | Affirming or denying proposition.
module Koshucode.Baala.Core.Assert


-- | Internal representation of relational data resource. Data resource
--   bundles data themselves and calculation stuffs. In Koshucode, data is
--   represented as set of judgements, and calculation is as
--   relation-to-relation mapping. This internal representation is usually
--   constructed from computer files or web resources addressed by URI.
--   Result of calculation on some resource becomes also data resource.
module Koshucode.Baala.Core.Resource.Resource

-- | Relational data resource
data Resource c
Resource :: Global c -> [Resource c] -> [String] -> [NamedTrees] -> [RelmapSource] -> [ShortAssert c] -> [Judge c] -> ([CodeName], [CodeName], [CodePiece]) -> [String] -> SecNo -> RelSelect c -> Resource c

-- | Global parameter
resGlobal :: Resource c -> Global c

-- | Importing resources
resImport :: Resource c -> [Resource c]

-- | Exporting names
resExport :: Resource c -> [String]

-- | Global slots
resSlot :: Resource c -> [NamedTrees]

-- | Source of relmaps
resRelmap :: Resource c -> [RelmapSource]

-- | Assertions of relmaps
resAssert :: Resource c -> [ShortAssert c]

-- | Affirmative or denial judgements
resJudge :: Resource c -> [Judge c]

-- | Codes of resource
resArticle :: Resource c -> ([CodeName], [CodeName], [CodePiece])

-- | Collection of messages
resMessage :: Resource c -> [String]

-- | Last section number
resLastSecNo :: Resource c -> SecNo
resSelect :: Resource c -> RelSelect c

-- | Abort or resource.
type AbResource c = Ab (Resource c)

-- | Resource that has no contents.
resEmpty :: Resource c
resIncluded :: Resource c -> [CodePiece]
addMessage :: String -> Map (Resource c)
addMessages :: [String] -> Map (Resource c)
type Assert c = Assert' Resource c
type ConsRelmap c = ConsRelmap' Resource c
type Global c = Global' Resource c
type RelkitHook c = RelkitHook' Resource c
type Relmap c = Relmap' Resource c
type RelmapLinkTable c = RelmapLinkTable' Resource c
type Rop c = Rop' Resource c
type RopCons c = RopCons' Resource c
type Intmed c = Intmed' Resource c
type ShortAssert c = ShortAssert' Resource c
type ShortAsserts c = ShortAsserts' Resource c
global :: Global c
instance GetGlobal Resource
instance SelectRel Resource
instance Show (Resource c)


-- | Resource as bundle of relational expressions.
module Koshucode.Baala.Core.Resource.Include

-- | Include source code into resource.
resInclude :: CContent c => Resource c -> CodePiece -> String -> AbResource c
coxBuildG :: CContent c => Global c -> TTreeToAb (Cox c)

module Koshucode.Baala.Core.Resource.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: ConsLexmap -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *


-- | Read resource.
module Koshucode.Baala.Core.Resource.Read

-- | I/O with global state.
type GlobalIO a c = StateT (Global c) IO a

-- | Calculation that returns abortable resource.
type ResourceIO c = GlobalIO (AbResource c) c
gio :: IO a -> GlobalIO a c
gioResource :: ResourceIO c -> Global c -> IO (AbResource c, Global c)

-- | Read resource from text.
readResourceText :: CContent c => Resource c -> String -> AbResource c
readSources :: CContent c => [CodeName] -> ResourceIO c


-- | Run resource.
module Koshucode.Baala.Core.Resource.Run
runResource :: CContent c => Resource c -> Ab (OutputResult c)

-- | Make a constructor pair of lexmap and relmap.
relmapCons :: GetGlobal h => h c -> (ConsLexmap, ConsRelmap' h c)


-- | Runtime structure for calculations written in Koshucode.
--   <a>Resource</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Resource

module Koshucode.Baala.Core
