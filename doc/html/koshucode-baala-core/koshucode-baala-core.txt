-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-core
@version 0.39.0.0

module Koshucode.Baala.Core.Section.Clausify
data ClauseSource
ClauseSource :: [Token] -> [TokenLine] -> ClauseSource

-- | Source tokens of clause
clauseTokens :: ClauseSource -> [Token]

-- | Source lines of clause
clauseLines :: ClauseSource -> [TokenLine]

-- | Convert token list into list of token clauses
clausify :: [TokenLine] -> [ClauseSource]
instance Typeable ClauseSource
instance Show ClauseSource
instance Data ClauseSource

module Koshucode.Baala.Core.Relmap.Operand
type RopOperand = (RopSorter, [String], [String])
type RopSorter = RopAssoc -> Ab RopAssoc

-- | Sorter for operand of relational operator. This soters docompose
--   operand trees, and give a name to suboperand.
type RopFullSorter = [TokenTree] -> Ab RopAssoc
type RopAssoc = [Named [TokenTree]]

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; sortOperand $ B.tt "a b -x /c 'd -y e"
--   [ ("",   [TreeL (TWord 1 0 "a"), TreeL (TWord 3 0 "b")])
--   , ("-x", [TreeL (TTerm 7 ["/c"]), TreeL (TWord 9 1 "d")])
--   , ("-y", [TreeL (TWord 14 0 "e")]) ]
--   </pre>
sortOperand :: [TokenTree] -> RopAssoc
sortUpOperand :: [TokenTree] -> [Named (OnceMore [TokenTree])]

-- | No-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandNone []
--   </pre>
operandNone :: [String] -> RopOperand

-- | Enumerating trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandEnum ["-1", "-2"] []
--   </pre>
operandEnum :: [String] -> [String] -> RopOperand

-- | Multiple-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandList "-term" []
--   </pre>
operandList :: String -> [String] -> RopOperand

-- | One-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandOne "-relmap" []
--   </pre>
operandOne :: String -> [String] -> RopOperand

-- | Two-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandTwo "-term" "-relmap" []
--   </pre>
operandTwo :: String -> String -> [String] -> RopOperand

-- | One-and-multiple-element trunk.
--   
--   <pre>
--   &gt;&gt;&gt; operandOneList "-pattern" "-term" []
--   </pre>
operandOneList :: String -> String -> [String] -> RopOperand

module Koshucode.Baala.Core.Relmap.Relfy
data Relfy c
Relfy :: Relhead -> RelfyBody c -> Relfy c
relfyHead :: Relfy c -> Relhead
relfyBody :: Relfy c -> RelfyBody c
data RelfyBody c
RelfyOneToMany :: Bool -> ([c] -> [[c]]) -> RelfyBody c
RelfyOneToOne :: Bool -> ([c] -> [c]) -> RelfyBody c
RelfyFull :: Bool -> ([[c]] -> [[c]]) -> RelfyBody c
RelfyPred :: ([c] -> Bool) -> RelfyBody c
RelfyOneToAbMany :: Bool -> ([c] -> Ab [[c]]) -> RelfyBody c
RelfyOneToAbOne :: Bool -> ([c] -> Ab [c]) -> RelfyBody c
RelfyAbFull :: Bool -> ([[c]] -> Ab [[c]]) -> RelfyBody c
RelfyAbPred :: ([c] -> Ab Bool) -> RelfyBody c
RelfyConst :: [[c]] -> RelfyBody c
RelfyId :: RelfyBody c
RelfyAppend :: (RelfyBody c) -> (RelfyBody c) -> RelfyBody c
RelfyUnion :: Bool -> [RelfyBody c] -> RelfyBody c
type RelmapRelfy c = [(Relfy c)] -> Relhead -> Ab (Relfy c)
relfyConst :: Rel c -> Relfy c
relfyId :: RelmapRelfy c
relfy :: Ord c => RelfyBody c -> AbMap [[c]]
instance Monoid (RelfyBody c)
instance Show (RelfyBody c)
instance Monoid (Relfy c)

module Koshucode.Baala.Core.Relmap.HalfRelmap

-- | Intermediate data that represents use of relational operator.
--   
--   <a>HalfRelmap</a> is constructed from list of <tt>TokenTree</tt>, and
--   (full) <tt>Relmap</tt> is constructed from <a>HalfRelmap</a>.
data HalfRelmap
HalfRelmap :: String -> [TokenLine] -> String -> RopAssoc -> [HalfRelmap] -> HalfRelmap

-- | Usages description
halfUsage :: HalfRelmap -> String

-- | Source information
halfLines :: HalfRelmap -> [TokenLine]

-- | Operator name of relmap operation
halfOperator :: HalfRelmap -> String

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> RopAssoc

-- | Subrelmaps in the operand
halfSubmap :: HalfRelmap -> [HalfRelmap]
instance Typeable HalfRelmap
instance Show HalfRelmap
instance Data HalfRelmap
instance Pretty HalfRelmap


-- | Data structures for relation-to-relation mappings
module Koshucode.Baala.Core.Relmap.Relmap

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator.
data Relmap c

-- | Retrieve a relation from a dataset
RelmapSource :: HalfRelmap -> JudgePattern -> [Termname] -> Relmap c

-- | Constant relation
RelmapConst :: HalfRelmap -> String -> (Rel c) -> Relmap c

-- | Equavalent relmap
RelmapAlias :: HalfRelmap -> (Relmap c) -> Relmap c

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> String -> (RelmapRelfy c) -> [Relmap c] -> Relmap c

-- | Connect two relmaps
RelmapAppend :: (Relmap c) -> (Relmap c) -> Relmap c

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap c

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap c -> [Relmap c]

-- | List of name in <a>RelmapName</a>
relmapNameList :: Relmap c -> [String]

-- | Expand <a>RelmapAppend</a> to list of <a>Relmap</a>
relmapAppendList :: Relmap c -> [Relmap c]

-- | Link relmaps by its name.
relmapLinker :: [Named (Relmap c)] -> Relmap c -> Relmap c
instance Pretty (Relmap c)
instance Name (Relmap c)
instance Monoid (Relmap c)
instance Show (Relmap c)

module Koshucode.Baala.Core.Relmap.Rop

-- | Implementation of relmap operator.
data Rop c
Rop :: String -> String -> RopFullSorter -> RopCons c -> String -> Rop c

-- | Operator name
ropName :: Rop c -> String

-- | Operator group
ropGroup :: Rop c -> String

-- | Operand sorter
ropFullSorter :: Rop c -> RopFullSorter

-- | Constructor of operator
ropCons :: Rop c -> RopCons c

-- | Usage of operator
ropUsage :: Rop c -> String

-- | Constructor of relational operator <a>Relmap</a>. <a>Relmap</a> is
--   constructed from <a>HalfRelmap</a> and subrelmaps in it.
type RopCons c = RopUse c -> AbortTokens (Relmap c)

-- | Use of operator
data RopUse c
RopUse :: HalfRelmap -> [Relmap c] -> RopUse c

-- | Syntactic data of operator use
ropHalf :: RopUse c -> HalfRelmap

-- | Subrelmaps
ropSubmap :: RopUse c -> [Relmap c]

-- | Retrieve relation from dataset.
relmapSource :: RopUse c -> String -> [String] -> (Relmap c)

-- | Constant relmap.
relmapConst :: RopUse c -> String -> Rel c -> Relmap c

-- | Alias relmap.
relmapAlias :: RopUse c -> Relmap c -> Relmap c

-- | Make a non-confluent relmap.
relmapCalc :: RopUse c -> String -> RelmapRelfy c -> Relmap c

-- | Make a confluent relmap.
relmapConfl :: RopUse c -> String -> RelmapRelfy c -> [Relmap c] -> Relmap c
instance Show (RopUse c)


-- | <tt>Relmap</tt> construction.
module Koshucode.Baala.Core.Relmap.Construct

-- | Make half and full relmap constructors.
relmapCons :: [Rop c] -> (RelmapCons c)

-- | Half and full relmap constructor
data RelmapCons c
RelmapCons :: RelmapHalfCons -> RelmapFullCons c -> RelmapCons c
consHalf :: RelmapCons c -> RelmapHalfCons
consFull :: RelmapCons c -> RelmapFullCons c

-- | First step of constructing relmap, make <tt>HalfRelmap</tt> from use
--   of relational operator.
type RelmapHalfCons = [TokenLine] -> [TokenTree] -> Ab HalfRelmap

-- | Second step of constructing relmap, make <tt>Relmap</tt> from contents
--   of <tt>HalfRelmap</tt>.
type RelmapFullCons c = HalfRelmap -> AbortTokens (Relmap c)
instance Show (RelmapCons c)


-- | Term calcutation.
module Koshucode.Baala.Core.Content.Operator

-- | Content expressions.
data Cox c

-- | Literal content.
CoxLit :: c -> Cox c

-- | Operator invocation.
CoxApp :: (Cop c) -> [Cox c] -> Cox c

-- | Term reference. Term names <tt>[String]</tt> and positions
--   <tt>[Int]</tt>. <tt>formCox</tt> makes positions empty,
--   <tt>posCox</tt> fills it.
CoxTerm :: [String] -> [Int] -> Cox c

-- | Term content operator.
data Cop c
CopLit :: String -> (CopLitF c) -> Cop c
CopLazy :: String -> (CopLazyF c) -> Cop c
CopEager :: String -> (CopEagerF c) -> Cop c
type CopLitF c = [TokenTree] -> Ab c
type CopLazyF c = [Cox c] -> Ab c
type CopEagerF c = [c] -> Ab c

-- | Type for finding term content operator.
type FindCop c = String -> Maybe (Cop c)
namedLit :: String -> CopLitF c -> (String, Cop c)
namedEager :: String -> CopEagerF c -> (String, Cop c)
namedLazy :: String -> CopLazyF c -> (String, Cop c)
instance Show c => Show (Cox c)
instance Show (Cop c)

module Koshucode.Baala.Core.Content.HashWord

-- | Table of coresspondences of hashed sequence and its text.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" hashWordTable
--   Just "\n"  
--   </pre>
hashWordTable :: [(String, String)]

-- | Convert string into hashed form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa\nbbb"
--   "aaa" #lf "bbb"
--   </pre>
hashWord :: Map String

module Koshucode.Baala.Core.Content.Class
class Show c => PrimContent c
typename :: PrimContent c => c -> String
class (Ord c, Pretty c, PrimContent c, CBool c, CText c, CDec c, CList c, CNil c, CSet c, CTermset c, CRel c) => CContent c where joinContent = foldM appendContent nil
appendContent :: CContent c => c -> c -> Ab c
joinContent :: CContent c => [c] -> Ab c

-- | Delete empty list (<a>null</a>) from content list.
nonNullFilter :: Map [[a]]

-- | Delete <a>nil</a> from content list.
nonNilFilter :: CNil c => Map [c]
class PrimContent c => CBool c where needBool = need isBool getBool
isBool :: CBool c => c -> Bool
putBool :: CBool c => Bool -> c
getBool :: CBool c => c -> Bool
needBool :: CBool c => c -> Ab Bool
class PrimContent c => CText c where needText = need isText getText
isText :: CText c => c -> Bool
getText :: CText c => c -> String
putText :: CText c => String -> c
needText :: CText c => c -> Ab String
class PrimContent c => CList c where needList = need isList getList
isList :: CList c => c -> Bool
getList :: CList c => c -> [c]
putList :: CList c => [c] -> c
needList :: CList c => c -> Ab [c]

-- | Types that can be nil
class PrimContent c => CNil c
isNil :: CNil c => c -> Bool
nil :: CNil c => c
class PrimContent c => CDec c where needDec = need isDec getDec
isDec :: CDec c => c -> Bool
getDec :: CDec c => c -> Decimal
putDec :: CDec c => Decimal -> c
needDec :: CDec c => c -> Ab Decimal
putDecFromInt :: CDec c => Int -> c
class PrimContent c => CSet c where needSet = need isSet getSet
isSet :: CSet c => c -> Bool
getSet :: CSet c => c -> [c]
putSet :: CSet c => [c] -> c
needSet :: CSet c => c -> Ab [c]
class PrimContent c => CTermset c where needTermset = need isTermset getTermset
isTermset :: CTermset c => c -> Bool
getTermset :: CTermset c => c -> [Named c]
putTermset :: CTermset c => [Named c] -> c
needTermset :: CTermset c => c -> Ab [Named c]
class PrimContent c => CRel c where needRel = need isRel getRel
isRel :: CRel c => c -> Bool
getRel :: CRel c => c -> Rel c
putRel :: CRel c => Rel c -> c
needRel :: CRel c => c -> Ab (Rel c)
putTextList :: (CText c, CList c) => [String] -> c
putTextSet :: (CText c, CSet c) => [String] -> c


-- | Literalizer: Make literal contents from token tree.
module Koshucode.Baala.Core.Content.Literal

-- | Transform <a>TokenTree</a> to something.
type Literalize a = TokenTree -> Ab a

-- | Transform list of <a>TokenTree</a> to something.
type LitTrees a = [TokenTree] -> Ab a
type LitOperators c = [Named (Literalize c -> LitTrees c)]

-- | Transform <a>TokenTree</a> into internal form of content.
litContentBy :: CContent c => LitOperators c -> Literalize c

-- | Collect term name and content.
litTermset :: CContent c => Literalize c -> LitTrees [Named c]

-- | Read list of termname and its content.
--   
--   <pre>
--   &gt;&gt;&gt; litNamedTrees . B.tokenTrees . B.tokens $ "/a 'A3 /b 10"
--   Right [("/a", TreeB 1 [TreeL (TWord 3 0 "'"), TreeL (TWord 4 0 "A3")]),
--          ("/b", TreeL (TWord 8 0 "10"))]
--   </pre>
litNamedTrees :: LitTrees [Named TokenTree]


-- | Extensions of literalizer
module Koshucode.Baala.Core.Content.Extension
litContent :: CContent c => Literalize c
litOperators :: CContent c => LitOperators c
litJudge :: CContent c => Bool -> JudgePattern -> LitTrees (Judge c)


-- | Term calcutation.
module Koshucode.Baala.Core.Content.Expression

-- | Construct content expression.
formCox :: CContent c => FindCop c -> TokenTree -> Ab (Cox c)
type PosCox c = Relhead -> Ab (Cox c)

-- | Put term positions for actural heading.
posCox :: Cox c -> PosCox c

-- | Calculate content expression.
runCox :: (CList c, CRel c) => [c] -> Cox c -> Ab c
runCoxH :: (CRel c, CList c) => Relhead -> [c] -> (PosCox c) -> Ab c


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Relmap


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Core.Assert.Assert

-- | Assertion of affirming or denying relation. It consists of logical
--   quality, relsign, and relmap.
--   
--   See also <a>Judge</a>
data Assert c
Assert :: AssertType -> JudgePattern -> AssertOption -> Relmap c -> [TokenLine] -> Assert c

-- | Logical quality
assertType :: Assert c -> AssertType

-- | Pattern of judgement
assertPattern :: Assert c -> JudgePattern

-- | Assert option
assertOption :: Assert c -> AssertOption

-- | Relmap
assertRelmap :: Assert c -> Relmap c

-- | Source code information
assertSource :: Assert c -> [TokenLine]

-- | Option for assertions.
type AssertOption = [Named [TokenTree]]

-- | Apply function to relamp in assert.
assertMap :: Map (Relmap c) -> Map (Assert c)
data AssertType

-- | <tt>|==</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertAffirm :: AssertType

-- | <tt>|=X</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertDeny :: AssertType

-- | <tt>|=V</tt> <i>pattern</i> <tt>:</tt> <i>relmap</i>
AssertViolate :: AssertType
assertQuality :: AssertType -> Bool

-- | Make affirmed assertion.
affirm :: JudgePattern -> AssertOption -> Relmap c -> [TokenLine] -> Assert c

-- | Make denied assertion.
deny :: JudgePattern -> AssertOption -> Relmap c -> [TokenLine] -> Assert c
instance Typeable AssertType
instance Show AssertType
instance Eq AssertType
instance Ord AssertType
instance Data AssertType
instance Show (Assert c)
instance Pretty (Assert c)


-- | Content
module Koshucode.Baala.Core.Content


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Core.Assert.Dataset

-- | Dataset is a set of judges.
data Dataset c

-- | Relation selector
type RelSelect c = JudgePattern -> [String] -> Rel c

-- | Dataset that has no judges
emptyDataset :: Dataset c

-- | Gather judges into a dataset
dataset :: [Judge c] -> Dataset c

-- | Add judges to dataset.
addJudges :: [Judge c] -> Dataset c -> Dataset c

-- | Select relation from dataset. If a giving term is not in judges,
--   <tt>CNil</tt> sign is used.
selectRelation :: (Ord c, CNil c) => Dataset c -> RelSelect c


-- | Running relational calculation.
module Koshucode.Baala.Core.Assert.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord c, CNil c) => [Assert c] -> [Judge c] -> AbortOr [Judge c]

-- | Calculate assertion list.
runAssertDataset :: (Ord c, CNil c) => [Assert c] -> Dataset c -> AbortOr [Judge c]


-- | Relation-to-relation mapping.
module Koshucode.Baala.Core.Assert


-- | Data structure for relational calculations. There are three types of
--   section: (1) <i>editing sections</i> that output judges and read other
--   sections, (2) <i>library sections</i> that make relmaps reusable, (3)
--   <i>data sections</i> that provide data.
module Koshucode.Baala.Core.Section.Section
data Section c
Section :: Maybe String -> [Section c] -> [String] -> [Named String] -> [Assert c] -> [Named (Relmap c)] -> [Judge c] -> [Judge c] -> String -> RelmapCons c -> Section c

-- | Section name
sectionName :: Section c -> Maybe String

-- | Importing section
sectionImport :: Section c -> [Section c]

-- | Exporting relmap names
sectionExport :: Section c -> [String]

-- | Prefix for short signs
sectionShort :: Section c -> [Named String]

-- | Assertions of relmaps
sectionAssert :: Section c -> [Assert c]

-- | Relmaps and its name
sectionRelmap :: Section c -> [Named (Relmap c)]

-- | Affirmative or denial judgements
sectionJudge :: Section c -> [Judge c]

-- | Violated judgements, i.e., result of <tt>|=V</tt>
sectionViolate :: Section c -> [Judge c]

-- | Resource name
sectionResource :: Section c -> String

-- | Relmap constructor for this section
sectionCons :: Section c -> RelmapCons c

-- | Select assertions like <a>sectionAssert</a>. It returns relmap-liked
--   assertions. We can run these assertions using <a>runAssertJudges</a>.
sectionLinkedAssert :: Section c -> [Assert c]

-- | Make empty section that has a given constructor.
makeEmptySection :: RelmapCons c -> Section c

-- | Section that has no contents.
emptySection :: Section c

-- | Section that has only judgements.
dataSection :: [Judge c] -> Section c
instance Show c => Show (Section c)
instance (Ord c, Pretty c) => Pretty (Section c)

module Koshucode.Baala.Core.Section.SectionUnion
sectionUnion :: Section c -> Section c -> Section c
sectionUse :: Section c -> Section c -> Section c
instance Monoid (Section c)


-- | Intermidiate structure between <a>String</a> and <a>Section</a>.
module Koshucode.Baala.Core.Section.Clause
data Clause

-- | Section name
CSection :: ClauseSource -> (Maybe String) -> Clause

-- | Importing section name
CImport :: ClauseSource -> [Token] -> (Maybe Clause) -> Clause

-- | Exporting relmap name
CExport :: ClauseSource -> String -> Clause

-- | Short signs
CShort :: ClauseSource -> (Named String) -> Clause

-- | Relmap and its name
CRelmap :: ClauseSource -> String -> HalfRelmap -> Clause

-- | Not include HalfRelmap
TRelmap :: ClauseSource -> String -> [Token] -> Clause

-- | Assertions of relmaps
CAssert :: ClauseSource -> AssertType -> JudgePattern -> AssertOption -> HalfRelmap -> Clause

-- | Not include HalfRelmap
TAssert :: ClauseSource -> AssertType -> JudgePattern -> AssertOption -> [Token] -> Clause

-- | Judge
CJudge :: ClauseSource -> Bool -> JudgePattern -> [Token] -> Clause

-- | Clause comment
CComment :: ClauseSource -> Clause

-- | Unknown clause
CUnknown :: ClauseSource -> Clause

-- | Unresolved short sign
CUnres :: ClauseSource -> [Token] -> Clause

-- | Name of clause type. e.g., <tt>"Relmap"</tt>, <tt>"Assert"</tt>.
clauseTypeText :: Clause -> String

-- | Source code information of clause.
clauseSource :: Clause -> ClauseSource

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <a>TRelmap</a> and <a>TAssert</a> are contained. This function does
--   not depend on <a>RelmapHalfCons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause . B.tokenize $ "a : source A /x /y"
--   [TRelmap (ClauseSource
--                [TWord 1 0 "a", TSpace 2 1, ..., TTerm 11 ["/y"]]
--                [CodeLine 1 "a : source A /x /y" [TWord 1 0 "a", ...]])
--            "a" [ TreeL (TWord 5 0 "source")
--                , TreeL (TWord 7 0 "A")
--                , TreeL (TTerm 9  ["/x"])
--                , TreeL (TTerm 11 ["/y"]) ]]
--   </pre>
consPreclause :: [TokenLine] -> [Clause]

-- | Construct <a>Clause</a> list from <a>Token</a> list. This is a first
--   step of constructing <a>Section</a>.
consClause :: RelmapHalfCons -> [TokenLine] -> AbortOr [Clause]

-- | Second step of constructing <a>Section</a>.
consSection :: CContent c => RelmapFullCons c -> String -> [Clause] -> AbortOr (Section c)
instance Typeable Clause
instance Show Clause
instance Data Clause

module Koshucode.Baala.Core.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapHalfCons -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *

module Koshucode.Baala.Core.Section.SectionIO

-- | Read section from text.
sectionRead :: CContent c => Section c -> String -> String -> AbortOr (Section c)

-- | Read section from file.
sectionFile :: CContent c => Section c -> FilePath -> IO (AbortOr (Section c))
readJudges :: CContent c => String -> AbortOr [Judge c]

-- | Run section. Output section has judges calculated from assertions in
--   input section.
runSection :: CContent c => Section c -> AbortOr (Section c)

-- | Run section and output judges.
runSectionIO :: CContent c => Section c -> IO Int
hRunSectionIO :: CContent c => Handle -> Section c -> IO Int


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Core.Section

module Koshucode.Baala.Core
