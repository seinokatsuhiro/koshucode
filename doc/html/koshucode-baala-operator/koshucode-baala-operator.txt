-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Relational operators in Koshucode
--   
--   An impelemntion of relational operators. Operators are used in the
--   <tt>koshu</tt> calculator that is contained in the
--   <tt>koshucode-baala-calculator</tt> package.
@package koshucode-baala-operator
@version 0.25.0.0


-- | Term values.
module Koshucode.Baala.Vanilla.Value.Val

-- | Type for values.
data Val

-- | String value
Stringv :: String -> Val

-- | Integer value
Intv :: Int -> Val

-- | Boolean value
Boolv :: Bool -> Val

-- | List of values
Listv :: [Val] -> Val

-- | List of values
Termsetv :: [Named Val] -> Val

-- | Relational value
Relv :: (Rel Val) -> Val

-- | Sign of no ordinary values
Nov :: Val
stringv :: String -> Val
intv :: Int -> Val
listv :: [Val] -> Val
relv :: Rel Val -> Val
nov :: Val
binv :: (Int -> Int -> Int) -> Val -> Map Val
toInt :: Val -> Int
toString :: Val -> String
valRangeMinMax :: Val -> Val -> [Val]
instance Show Val
instance Eq Val
instance Ord Val
instance Value Val
instance Pretty Val
instance Nil Val
instance RelValue Val
instance TermsetValue Val
instance ListValue Val
instance StringValue Val
instance IntValue Val
instance BoolValue Val

module Koshucode.Baala.Vanilla.Order
data OrderCap v
orders :: String -> [OrderCap [Char]]
sortByName :: (Ord v, Eq n) => [OrderCap n] -> [n] -> [[v]] -> [[v]]
instance Show v => Show (OrderCap v)
instance Eq v => Eq (OrderCap v)
instance Ord v => Ord (OrderCap v)


-- | Relation on type <a>Val</a>
module Koshucode.Baala.Vanilla.Value.Relval
terms :: [String] -> [Relterm]
unionUpTerm :: Name a => [String] -> [a] -> [Relterm]


-- | Kit for implementing relational operators
module Koshucode.Baala.Minimal.OpKit

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | Abort symbols
data Abort :: *
AbortLookup :: [SourceLine] -> String -> Abort
AbortMalformedOperand :: [SourceLine] -> String -> Abort
AbortMissingTermName :: [SourceLine] -> String -> Abort
AbortNotNumber :: [SourceLine] -> String -> Abort
AbortOddRelation :: [SourceLine] -> Abort
AbortRequireFlatname :: [SourceLine] -> String -> Abort
AbortUnknownClause :: [SourceLine] -> Abort
AbortUnknownContent :: [SourceLine] -> String -> Abort
AbortUnknownRelmap :: [SourceLine] -> String -> Abort
AbortUnknownSymbol :: [SourceLine] -> String -> Abort
AbortUsage :: [SourceLine] -> String -> [String] -> Abort

-- | Abortable type
type AbortOr a = Either Abort a

-- | Lookup association list. This function may abort on AbortLookup.
(<!!>) :: [(String, a)] -> String -> AbortOr a

-- | Stop on error ''bug in koshucode''
bug :: a
class IntValue v
intValue :: IntValue v => Int -> v

-- | Relations on type v. Heading of relation and body of relation as a
--   list of tuples.
data Rel v :: * -> *
Rel :: Relhead -> Relbody v -> Rel v
class RelValue v
relValue :: RelValue v => Rel v -> v

-- | Heading of relation as a list of terms
data Relhead :: *
Relhead :: [Relterm] -> Relhead
headTerms :: Relhead -> [Relterm]

-- | Relation-to-relation mapping
type RelmapFun v = Rel v -> Rel v

-- | Term in heading of relation
data Relterm :: *
Term :: String -> Relterm
Nest :: String -> [Relterm] -> Relterm
class StringValue v
stringValue :: StringValue v => String -> v

-- | Make head from term names
headFrom :: [String] -> Relhead

-- | Positions of given (sub)head in a head
headPosh :: Relhead -> Relhead -> [TermPos]

-- | Positions of given names in a head
headPoss :: Relhead -> [[String]] -> [TermPos]
intValue :: IntValue v => Int -> v

-- | Indicies
posPoss :: [TermPos] -> [Int]

-- | Pick an inner part.
possInner :: [TermPos] -> [[String]]

-- | Pick an outer part.
possOuter :: [TermPos] -> [[String]]

-- | Pick values
possPick :: [TermPos] -> [v] -> [v]

-- | Reconstruct head
rehead :: ([String] -> [String]) -> Relhead -> Relhead
relValue :: RelValue v => Rel v -> v

-- | Relational constant that has no terms and the empty tuple
reldee :: Rel v

-- | Relational constant that has no terms and no tuples
reldum :: Rel v
stringValue :: StringValue v => String -> v
type Map a = a -> a
type Listmap a = forall a. Map [a]

-- | Gather (key,value) to a Map key [value]
gatherToMap :: Ord k => [(k, v)] -> Map k [v]

-- | Cut indexed elements
--   
--   <pre>
--   &gt;&gt;&gt; indexCut [1,3] "abcdefg"
--   "acefg"
--   </pre>
indexCut :: [Int] -> [a] -> [a]

-- | Pick indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; indexPick [1,3] "abcdefg"
--   "bd"
--   </pre>
indexPick :: [Int] -> [a] -> [a]
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Constructor of relational operator <a>Relmap</a>. <a>Relmap</a> is
--   constructed from <a>HalfRelmap</a> and subrelmaps in it.
type Relop v = OpUse v -> AbortOr (Relmap v)

-- | Implementation of relmap operator. It consists of (1) operator name,
--   (2) operand parser, (3) constructor of operator, and (4) usage of
--   operator.
data OpImplement v :: * -> *
OpImplement :: String -> OpParser -> Relop v -> [String] -> OpImplement v

-- | Parser for operand of relational operator. This parsers docompose
--   operand trees, and give a name to suboperand.
type OpParser = [TokenTree] -> [Named [TokenTree]]
type OpParser' = [Named [TokenTree]] -> [Named [TokenTree]]

-- | Use of operator
data OpUse v :: * -> *
OpUse :: HalfRelmap -> [Relmap v] -> OpUse v

-- | Syntactic data of operator use
opHalf :: OpUse v -> HalfRelmap

-- | Subrelmaps
opSubmap :: OpUse v -> [Relmap v]

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator.
data Relmap v :: * -> *

-- | Retrieve a relation from a dataset
RelmapSource :: HalfRelmap -> String -> [String] -> Relmap v

-- | Constant relation
RelmapConst :: HalfRelmap -> String -> Rel v -> Relmap v

-- | Equavalent relmap
RelmapAlias :: HalfRelmap -> Relmap v -> Relmap v

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> String -> RelmapSub v -> [Relmap v] -> Relmap v

-- | Connect two relmaps
RelmapAppend :: Relmap v -> Relmap v -> Relmap v

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap v

-- | Half and full relmap constructor
data RelmapCons v :: * -> *
RelmapCons :: RelmapHalfCons -> RelmapFullCons v -> RelmapCons v
consHalf :: RelmapCons v -> RelmapHalfCons
consFull :: RelmapCons v -> RelmapFullCons v

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>HalfRelmap</a>.
type RelmapFullCons v = HalfRelmap -> AbortOr (Relmap v)

-- | First step of constructing relmap, make <a>HalfRelmap</a> from use of
--   relational operator.
type RelmapHalfCons = [SourceLine] -> [TokenTree] -> HalfRelmap

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> [Named [TokenTree]]

-- | Alias relmap.
relmapAlias :: OpUse v -> Relmap v -> Relmap v

-- | Make a non-confluent relmap.
relmapCalc :: OpUse v -> String -> RelmapSub v -> Relmap v

-- | Make a confluent relmap.
relmapConfl :: OpUse v -> String -> RelmapSub v -> [Relmap v] -> Relmap v

-- | Make half and full relmap constructors.
relmapCons :: [OpImplement v] -> RelmapCons v

-- | Constant relmap.
relmapConst :: OpUse v -> String -> Rel v -> Relmap v

-- | Retrieve relation from dataset.
relmapSource :: OpUse v -> String -> [String] -> Relmap v

-- | Calculator combining values into a single value
type Calc v = [v] -> v
data QuasiQuoter :: *

-- | Set of operators
type Ripen x v = x -> [v] -> Calc v

-- | Calculate a value of tree
crop :: Ripen x v -> Tree x -> Calc v

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapHalfCons -> ExpQ -> QuasiQuoter

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; operandGroup $ tokenTrees $ tokens "a b -x c 'd' -y e"
--   [("",   [TreeL (Word 0 "a"), TreeL (Word 0 "b")]),
--    ("-x", [TreeL (Word 0 "c"), TreeL (Word 1 "d")]),
--    ("-y", [TreeL (Word 0 "e")])]
--   </pre>
operandGroup :: [TokenTree] -> [Named [TokenTree]]

-- | Extract a list of name-and-name pairs.
--   
--   <pre>
--   &gt;&gt;&gt; termNamePairs $ tokenTrees $ tokens "/a /x /b /y"
--   Right [("/a","/x"), ("/b","/y")]
--   </pre>
termNamePairs :: [TokenTree] -> AbortOr [(String, String)]

-- | Extract a list of term names.
--   
--   <pre>
--   &gt;&gt;&gt; termNames $ tokenTrees $ tokens "/a /b /c"
--   Right ["/a","/b","/c"]
--   </pre>
termNames :: [TokenTree] -> AbortOr [String]

-- | Extract a list of name-and-tree pairs.
--   
--   <pre>
--   &gt;&gt;&gt; termTreePairs $ tokenTrees $ tokens "/a 'A3' /b 10"
--   Right [("/a", TreeL (Word 1 "A3")), ("/b", TreeL (Word 0 "10"))]
--   </pre>
termTreePairs :: [TokenTree] -> AbortOr [(String, TokenTree)]
data Token :: *

-- | Word. <tt>Int</tt> represents quotation level, e.g., 0 for non-quoted,
--   1 for single-quoted, 2 for double-quoted.
TWord :: TNumber -> Int -> String -> Token

-- | Term name
TTermN :: TNumber -> [String] -> Token

-- | Term position in particular relation. This is translate from
--   <a>TTermN</a>.
TTermP :: TNumber -> [Int] -> Token

-- | Open paren
TOpen :: TNumber -> String -> Token

-- | Close paren
TClose :: TNumber -> String -> Token

-- | <i>N</i> space characters
TSpace :: TNumber -> Int -> Token

-- | Comment text
TComment :: TNumber -> String -> Token

-- | Tree of tokens.
type TokenTree = Tree Token

-- | Tree of leaf and branch
data Tree a :: * -> *

-- | Leaf. Terminal of tree.
TreeL :: a -> Tree a

-- | Branch. Paren-type and subtrees.
TreeB :: Int -> [Tree a] -> Tree a

-- | Split branches in a given tree at infixed binary operators
binaryTree :: Show a => (a -> BinaryHeight) -> Tree a -> Tree a

-- | Make the height function from a height table of operators.
heightTable :: Ord a => [(BinaryHeight, [a])] -> a -> BinaryHeight
heightTableUnbox :: Ord a => (b -> a) -> [(BinaryHeight, [a])] -> b -> BinaryHeight


-- | Extract suboperand
module Koshucode.Baala.Minimal.Relmap.Get

-- | Abortable <a>head</a>
getHead :: [a] -> AbortOr a
type OpGet v a = OpUse v -> String -> AbortOr a
getTree :: OpGet v TokenTree
getTrees :: OpGet v [TokenTree]

-- | Get word from named operand.
--   
--   <pre>
--   consXxx :: Relop v
--   consXxx use = do
--     sign &lt;- getWord use "-sign"
--     ...
--   </pre>
getWord :: OpGet v String
getInt :: OpGet v Int

-- | Get a term name from named operand.
getTerm :: OpGet v String

-- | Get list of term names from named operand.
getTerms :: OpGet v [String]

-- | Get list of term-name pairs from named operand.
getTermPairs :: OpGet v [(String, String)]

-- | Get a relmap from operator use.
--   
--   <pre>
--   consMeet :: (Ord v) =&gt; Relop v
--   consMeet use = do
--     m &lt;- getRelmap use
--     Right $ relmapMeet use m
--   </pre>
getRelmap :: OpUse v -> AbortOr (Relmap v)

-- | Get relmaps from operator use.
getRelmaps :: OpUse v -> AbortOr [Relmap v]


-- | Class for operand patterns
module Koshucode.Baala.Minimal.Relmap.Pattern

-- | Class for operand pattern.
class OpPattern p where opParser p = opParser' p . operandGroup opParser' _ = id
opParser :: OpPattern p => p -> OpParser
opParser' :: OpPattern p => p -> OpParser'
opPart :: OpPattern p => p -> [String]
opUsage :: OpPattern p => p -> [String]

-- | Make implementations of relational operators.
operators :: OpPattern p => [(String, p, Relop v)] -> [OpImplement v]


-- | Operand patterns
module Koshucode.Baala.Minimal.Relmap.Operand

-- | <a>OpPattern</a> for minimal operators
data MinimalOperand

-- | no operand
LikeEmpty :: MinimalOperand

-- | { <tt>-relmap</tt> } relmap [ <tt>-share</tt> /name ... ]
LikeMeet :: MinimalOperand

-- | { <tt>-term</tt> } /name ...
LikePick :: MinimalOperand

-- | { <tt>-term</tt> } /new /old ...
LikeRename :: MinimalOperand

-- | { <tt>-sign</tt> } relsign { <tt>-term</tt> } /name ...
LikeSource :: MinimalOperand
likePick :: OpParser'
likeMeet :: OpParser'
likeRename :: OpParser'
likeSource :: OpParser'
instance Show MinimalOperand
instance Eq MinimalOperand
instance Enum MinimalOperand
instance OpPattern MinimalOperand


-- | Restrict by relation
module Koshucode.Baala.Minimal.Relmap.Restrict
relopSome :: Ord v => Relop v
relmapSome :: Ord v => OpUse v -> Map (Relmap v)
relSome :: Ord v => Rel v -> Map (Rel v)
relopMinus :: Ord v => Relop v
relmapMinus :: Ord v => OpUse v -> Map (Relmap v)
relMinus :: Ord v => Rel v -> Map (Rel v)


-- | Fundamental operators in relational algebra.
--   
--   Tropashko's relational lattice is a kind of relational algebra.
--   Relational algebra is an algebraic formulation for relational model.
--   In constrast to Codd's original relational algebra, Tropashko lattice
--   is in more conventional and strict ways. The lattice has fundamental
--   operators from which other operators are derived.
module Koshucode.Baala.Minimal.Relmap.Tropashko
relopMeet :: Ord v => Relop v

-- | Meet two relations.
relmapMeet :: Ord v => OpUse v -> Relmap v -> Relmap v

-- | Meet two relations.
relMeet :: Ord v => Rel v -> Rel v -> Rel v
relopJoin :: Ord v => Relop v

-- | Join two relations.
relmapJoin :: Ord v => OpUse v -> Relmap v -> Relmap v

-- | Join two relations.
relJoin :: Ord v => Rel v -> Rel v -> Rel v


-- | Unary relational operators.
module Koshucode.Baala.Minimal.Relmap.Unary
relopId :: Relop v
relmapId :: OpUse v -> Relmap v

-- | Identity mapping, i.e., do nothing.
relId :: Map (Rel v)
relopEmpty :: Relop v
relmapEmpty :: OpUse v -> Relmap v

-- | Throw away all tuples in a relation.
relEmpty :: Map (Rel v)
relopCut :: Ord v => Relop v
relmapCut :: Ord v => OpUse v -> [String] -> Relmap v
relCut :: Ord v => [String] -> Map (Rel v)
relopPick :: Ord v => Relop v
relmapPick :: Ord v => OpUse v -> [String] -> Relmap v
relPick :: Ord v => [String] -> Map (Rel v)
relopRename :: Relop v
relmapRename :: OpUse v -> [(String, String)] -> Relmap v

-- | Change terms names
relRename :: [(String, String)] -> Map (Rel v)


-- | Minimal implementations of relmaps
module Koshucode.Baala.Minimal.Relmap.Implement

-- | Minimal implementations of relmaps
minimalOperators :: Ord v => [OpImplement v]

module Koshucode.Baala.Vanilla.Calc.Ripen
calcRipen :: Ripen Token Val

-- | Convert infix form to prefix form.
calcBinary :: Map TokenTree

module Koshucode.Baala.Vanilla.Calc

-- | Prepare calculation. <tt>makeCalc</tt> <i>H E</i> is a calculator from
--   an expression <i>E</i> on a head <i>H</i>. Terms in <i>E</i> must be
--   terms in <i>H</i>. If not in <i>H</i>, an error is reported.
makeCalc :: Relhead -> TokenTree -> Calc Val

-- | Prepare named calculators
makeHeadCalcs :: Relhead -> [TokenTree] -> (Relhead, [Calc Val])


-- | Minimal relational operators.
module Koshucode.Baala.Minimal.Relmap


-- | Minimal relational operators
module Koshucode.Baala.Minimal

module Koshucode.Baala.Vanilla.Relmap.Binary
relopMaybe :: Relop Val
relmapMaybe :: (Ord v, Nil v) => OpUse v -> Relmap v

-- | like SQL's left join
relMaybe :: (Ord v, Nil v) => Rel v -> Rel v -> Rel v
relopMaybeBoth :: Relop Val

-- | like SQL's full join
relmapMaybeBoth :: (Ord v, Nil v) => OpUse v -> Relmap v
relopHang :: Relop Val
relmapHang :: (Ord v, RelValue v) => OpUse v -> String -> Relmap v

-- | Hanging relation, like grouping.
relHang :: (Ord v, RelValue v) => String -> Rel v -> Map (Rel v)


-- | Relational mappers
module Koshucode.Baala.Vanilla.Relmap.Calc
relopHold :: Relop Val

-- | Make relmap function for <tt>hold</tt> operator.
relmapHold :: OpUse Val -> (Val -> Val -> Bool) -> TokenTree -> Relmap Val
relHold :: (Val -> Val -> Bool) -> TokenTree -> Map (Rel Val)
relopUnhold :: Relop Val
relopVal :: Relop Val

-- | Make relmap function for <tt>val</tt> operator.
relmapVal :: OpUse Val -> [TokenTree] -> Relmap Val
relVal :: [TokenTree] -> Map (Rel Val)
relopRange :: Relop Val
relmapRange :: IntValue v => OpUse v -> String -> Int -> Int -> Relmap v

-- | Keep leading tuples.
limit :: Ord v => OpUse v -> Int -> String -> Relmap v

module Koshucode.Baala.Vanilla.Relmap.Naming
relopPrefix :: Relop Val
relmapPrefix :: OpUse v -> String -> [String] -> Relmap v

-- | Add prefix to terms.
relPrefix :: String -> [String] -> Map (Rel v)
relopUnprefix :: Relop Val
relmapUnprefix :: OpUse v -> String -> Relmap v

-- | Remove prefix
relUnprefix :: String -> Map (Rel v)
relopPrefixChange :: Relop Val
relmapPrefixChange :: OpUse v -> String -> String -> Relmap v

-- | Change prefix
relPrefixChange :: String -> String -> Map (Rel v)

module Koshucode.Baala.Vanilla.Relmap.Operand

-- | <a>OpPattern</a> for relational operations.
data VanillaOperand

-- | Boolean expression
LikeHold :: VanillaOperand

-- | List of new term and expression
LikeVal :: VanillaOperand

-- | Relmap and maybe shared terms
LikeMeet :: VanillaOperand

-- | Prefix. <tt>-prefix</tt>, <tt>-term</tt>
LikePrefix :: VanillaOperand

-- | Relsign and list of terms
LikeSource :: VanillaOperand

-- | Prefix. <tt>-prefix</tt>
LikeUnprefix :: VanillaOperand

-- | Prefix. <tt>-new</tt>, <tt>-old</tt>
LikePrefixChange :: VanillaOperand

-- | Size. <tt>-term</tt>
LikeSize :: VanillaOperand
likePrefix :: OpParser'
likeUnprefix :: OpParser'
likePrefixChange :: OpParser'
likeSize :: OpParser'
instance Show VanillaOperand
instance Eq VanillaOperand
instance Enum VanillaOperand
instance OpPattern VanillaOperand

module Koshucode.Baala.Vanilla.Relmap.Unary
relopSize :: Relop Val
relmapSize :: IntValue v => OpUse v -> String -> Relmap v

-- | Change terms names
relSize :: IntValue v => String -> Map (Rel v)
relopConf :: Relop Val
relmapConf :: StringValue v => OpUse v -> String -> Relmap v

-- | Change terms names
relConf :: StringValue v => String -> Map (Rel v)
relopEnclose :: Relop Val
relmapEnclose :: RelValue v => OpUse v -> String -> Relmap v

-- | Enclose the current relation in a term.
relEnclose :: RelValue v => String -> Map (Rel v)

module Koshucode.Baala.Vanilla.Relmap.Implement

-- | Implementation of relational operators.
vanillaOperators :: [OpImplement Val]


-- | Quasiquoter of Koshucode
module Koshucode.Baala.Vanilla.Quoter

-- | Quasiquoter for <tt>[koshu| ... |]</tt>.
koshu :: QuasiQuoter

module Koshucode.Baala.Vanilla
