-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Relational operators in Koshucode
--   
--   This is a library for processing relational data. Relational
--   expressions are written in Koshucode. Koshucode is a notation for both
--   of descriptions and calculations of data.
@package koshucode-baala-operator
@version 0.13.0.0


-- | Term values
module Koshucode.Baala.Vanilla.Value.Val

-- | Type for values
data Val

-- | String value
Stringv :: String -> Val

-- | Integer value
Intv :: Int -> Val

-- | Boolean value
Boolv :: Bool -> Val

-- | List of values
Listv :: [Val] -> Val

-- | Relational value
Relv :: (Rel Val) -> Val

-- | Sign of no ordinary values
Nov :: Val
stringv :: String -> Val
intv :: Int -> Val
listv :: [Val] -> Val
relv :: Rel Val -> Val
nov :: Val
binv :: (Int -> Int -> Int) -> Val -> Val -> Val
toInt :: Val -> Int
toString :: Val -> String
valRangeMinMax :: Val -> Val -> [Val]
instance Show Val
instance Eq Val
instance Ord Val
instance Value Val
instance Pretty Val
instance Nil Val
instance RelValue Val
instance ListValue Val
instance StringValue Val
instance IntValue Val
instance BoolValue Val


-- | Relation on type <a>Val</a>
module Koshucode.Baala.Vanilla.Value.Relval
terms :: [String] -> [Relterm]
unionUpTerm :: Name a => [String] -> [a] -> [Relterm]


-- | Kit for implementing relational operators
module Koshucode.Baala.Minimal.OpKit

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | Abort symbols
data Abort :: *
AbortLookup :: [SourceLine] -> String -> Abort
AbortMalformedOperand :: [SourceLine] -> String -> Abort
AbortMalformedTerms :: [SourceLine] -> String -> Abort
AbortMissingTermName :: [SourceLine] -> String -> Abort
AbortUnknownClause :: [SourceLine] -> Abort
AbortUnknownRelmap :: [SourceLine] -> String -> Abort
AbortUsage :: [SourceLine] -> [String] -> Abort

-- | Abortable type
type AbortOr a = Either Abort a

-- | Lookup association list. This function may abort on AbortLookup.
(<!!>) :: [(String, a)] -> String -> AbortOr a

-- | Stop on error ''bug in koshucode''
bug :: a
class IntValue v
intValue :: IntValue v => Int -> v

-- | Relations on type v. Heading of relation and body of relation as a
--   list of tuples.
data Rel v :: * -> *
Rel :: Relhead -> Relbody v -> Rel v
class RelValue v
relValue :: RelValue v => Rel v -> v

-- | Heading of relation as a list of terms
data Relhead :: *
Relhead :: [Relterm] -> Relhead
headTerms :: Relhead -> [Relterm]

-- | Relation-to-relation mapping
type RelmapFun v = Rel v -> Rel v

-- | Term in heading of relation
data Relterm :: *
Term :: String -> Relterm
Nest :: String -> [Relterm] -> Relterm
class StringValue v
stringValue :: StringValue v => String -> v

-- | Make head from term names
headFrom :: [String] -> Relhead

-- | Positions of given (sub)head in a head
headPosh :: Relhead -> Relhead -> [TermPos]

-- | Positions of given names in a head
headPoss :: Relhead -> [[String]] -> [TermPos]
intValue :: IntValue v => Int -> v

-- | Indicies
posPoss :: [TermPos] -> [Int]

-- | Pick an inner part.
possInner :: [TermPos] -> [[String]]

-- | Pick an outer part.
possOuter :: [TermPos] -> [[String]]

-- | Pick values
possPick :: [TermPos] -> [v] -> [v]

-- | Reconstruct head
rehead :: ([String] -> [String]) -> Relhead -> Relhead
relValue :: RelValue v => Rel v -> v

-- | Relational constant that has no terms and the empty tuple
reldee :: Rel v

-- | Relational constant that has no terms and no tuples
reldum :: Rel v
stringValue :: StringValue v => String -> v
orders :: String -> [OrderCap [Char]]
sortByName :: (Ord v, Eq n) => [OrderCap n] -> [n] -> [[v]] -> [[v]]
type Map a = a -> a
type Listmap a = forall a. Map [a]

-- | Gather (key,value) to a Map key [value]
gatherToMap :: Ord k => [(k, v)] -> Map k [v]

-- | Cut indexed elements
--   
--   <pre>
--   &gt;&gt;&gt; indexCut [1,3] "abcdefg"
--   "acefg"
--   </pre>
indexCut :: [Int] -> [a] -> [a]

-- | Pick indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; indexPick [1,3] "abcdefg"
--   "bd"
--   </pre>
indexPick :: [Int] -> [a] -> [a]
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Constructor of relational operator <a>Relmap</a>. <a>Relmap</a> is
--   constructed from <tt>HalfRelmap</tt> and subrelmaps in it.
type OpCons v = OpUse v -> AbortOr (Relmap v)

-- | Implementation of relmap operator. It consists of (1) operator name,
--   (2) operand parser, (3) constructor of operator, and (4) usage of
--   operator.
data OpImplement v :: * -> *
OpImplement :: String -> OpParser -> OpCons v -> [String] -> OpImplement v

-- | Parser for operand of relational operator. This parsers docompose
--   operand trees, and give a name to suboperand.
type OpParser = [TokenTree] -> [Named [TokenTree]]
type OpParser' = [Named [TokenTree]] -> [Named [TokenTree]]
data OpUse v :: * -> *
OpUse :: HalfRelmap -> [Relmap v] -> OpUse v
opHalf :: OpUse v -> HalfRelmap
opSub :: OpUse v -> [Relmap v]

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator, that is pair of operator and its operand.
data Relmap v :: * -> *

-- | Relmap that retrieves a relation from a dataset
RelmapSource :: HalfRelmap -> String -> [String] -> Relmap v

-- | Relmap that has a constant relation
RelmapConst :: HalfRelmap -> String -> Rel v -> Relmap v

-- | Relmap that has equavalent relmap
RelmapAlias :: HalfRelmap -> Relmap v -> Relmap v

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> String -> RelmapSub v -> [Relmap v] -> Relmap v

-- | Relmap that joints two relmaps
RelmapAppend :: Relmap v -> Relmap v -> Relmap v

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap v

-- | Half and full relmap constructor
data RelmapCons v :: * -> *
RelmapCons :: RelmapHalfCons -> RelmapFullCons v -> RelmapCons v
consHalf :: RelmapCons v -> RelmapHalfCons
consFull :: RelmapCons v -> RelmapFullCons v

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>HalfRelmap</a>.
type RelmapFullCons v = HalfRelmap -> AbortOr (Relmap v)

-- | First step of constructing relmap, make <a>HalfRelmap</a> from use of
--   relational operator.
type RelmapHalfCons = [SourceLine] -> [TokenTree] -> HalfRelmap

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> [Named [TokenTree]]

-- | Make a non-confluent relmap
relmapCalc :: OpUse v -> String -> RelmapSub v -> Relmap v

-- | Make a confluent relmap
relmapConfl :: OpUse v -> String -> RelmapSub v -> [Relmap v] -> Relmap v

-- | Make half and full relmap constructors.
relmapCons :: [OpImplement v] -> RelmapCons v

-- | Retrieve relation from dataset
relmapSource :: OpUse v -> String -> [String] -> Relmap v
data QuasiQuoter :: *

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapHalfCons -> ExpQ -> QuasiQuoter

-- | Calculator combining values into a single value
type Calc v = [v] -> v

-- | Set of operators
type Ripen x v = x -> [v] -> Calc v
data Token :: *

-- | Text
Word :: Int -> String -> Token

-- | Term name
TermN :: [String] -> Token

-- | Term position
TermP :: [Int] -> Token

-- | Open paren
Open :: String -> Token

-- | Close paren
Close :: String -> Token

-- | N space chars
Space :: Int -> Token

-- | Comment text
Comment :: String -> Token

-- | Source infomation
Line :: SourceLine -> Token

-- | Tree of tokens
type TokenTree = Tree Token

-- | Tree of leaf and branch
data Tree a :: * -> *

-- | Terminal of a tree
TreeL :: a -> Tree a

-- | Paren-type and subtrees
TreeB :: Int -> [Tree a] -> Tree a

-- | Split branches in a given tree at infixed binary operators
binaryTree :: Show a => (a -> BinaryHeight) -> Tree a -> Tree a

-- | Calculate a value of tree
crop :: Ripen x v -> Tree x -> Calc v

-- | Make the height function from a height table of operators
heightTable :: Ord a => [(BinaryHeight, [a])] -> a -> BinaryHeight

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; operandGroup $ tokenTrees $ tokens "a b -x c 'd' -y e"
--   [("",   [TreeL (Word 0 "a"), TreeL (Word 0 "b")]),
--    ("-x", [TreeL (Word 0 "c"), TreeL (Word 1 "d")]),
--    ("-y", [TreeL (Word 0 "e")])]
--   </pre>
operandGroup :: [TokenTree] -> [Named [TokenTree]]

-- | Extract a list of name-and-tree pairs.
--   
--   <pre>
--   &gt;&gt;&gt; termTreePairs $ tokenTrees $ tokens "/a 'A3' /b 10"
--   Right [("/a", TreeL (Word 1 "A3")), ("/b", TreeL (Word 0 "10"))]
--   </pre>
termTreePairs :: [TokenTree] -> AbortOr [(String, TokenTree)]

-- | Call a relmap function with new term names.
withN1 :: WithTerms v

-- | Call a relmap function with present term names.
withP :: WithTerms v

-- | Call a relconfl function with present term names.
withP2 :: ([String] -> [Rel v] -> RelmapFun v) -> String -> [Rel v] -> RelmapFun v


-- | Extract suboperand
module Koshucode.Baala.Minimal.Relmap.Get
type OpGet v a = OpUse v -> String -> AbortOr a

-- | Abortable <a>head</a>
getHead :: [a] -> AbortOr a

-- | Get word from named operand.
getWord :: OpGet v String
getTerm1 :: OpGet v String

-- | Get list of term names from named operand.
getTerms :: OpGet v [String]

-- | Get list of term-name pairs from named operand.
getTermPairs :: OpGet v [(String, String)]
getRelmap1 :: OpUse v -> AbortOr (Relmap v)


-- | Class for operand patterns
module Koshucode.Baala.Minimal.Relmap.Pattern

-- | Class for operand pattern.
class OpPattern p where operandParser p = operandParser' p . operandGroup operandParser' _ = id operandUsage _ = []
operandParser :: OpPattern p => p -> OpParser
operandParser' :: OpPattern p => p -> OpParser'
operandUsage :: OpPattern p => p -> [String]

-- | Make relmap implementations.
operators :: OpPattern p => [(String, p, OpCons v)] -> [OpImplement v]


-- | Operand patterns
module Koshucode.Baala.Minimal.Relmap.Operand

-- | <a>OpPattern</a> for minimal operators
data MinimalOperand

-- | No operand
LikeEmpty :: MinimalOperand

-- | Relmap and maybe shared terms
LikeMeet :: MinimalOperand

-- | List of present terms
LikePick :: MinimalOperand

-- | List of new term and present term. <tt>-term</tt> pairs of new and
--   present terms
LikeRename :: MinimalOperand

-- | Relsign and list of terms. <tt>-sign</tt> relsign <tt>-term</tt> term
--   names
LikeSource :: MinimalOperand
likePick :: OpParser'
likeMeet :: OpParser'
likeRename :: OpParser'
likeSource :: OpParser'
instance Show MinimalOperand
instance Eq MinimalOperand
instance Enum MinimalOperand
instance OpPattern MinimalOperand


-- | Restrict by relation
module Koshucode.Baala.Minimal.Relmap.Restrict
relmapSome :: Ord v => OpUse v -> Map (Relmap v)
relSome :: Ord v => Rel v -> Map (Rel v)
relmapMinus :: Ord v => OpUse v -> Map (Relmap v)
relMinus :: Ord v => Rel v -> Map (Rel v)


-- | Fundamental operators in relational algebra.
--   
--   Tropashko's relational lattice is a kind of relational algebra.
--   Relational algebra is an algebraic formulation for relational model.
--   In constrast to Codd's original relational algebra, Tropashko lattice
--   is in more conventional and strict ways. The lattice has fundamental
--   operators from which other operators are derived.
module Koshucode.Baala.Minimal.Relmap.Tropashko

-- | Meet two relations.
relmapMeet :: Ord v => OpUse v -> Relmap v -> Relmap v

-- | Meet two relations.
relMeet :: Ord v => Rel v -> Rel v -> Rel v

-- | Join two relations.
relmapJoin :: Ord v => OpUse v -> Relmap v -> Relmap v

-- | Join two relations.
relJoin :: Ord v => Rel v -> Rel v -> Rel v


-- | Unary relational operators.
module Koshucode.Baala.Minimal.Relmap.Unary
relmapEmpty :: OpUse v -> Relmap v

-- | Throw away all tuples in a relation.
relEmpty :: Map (Rel v)
relmapCut :: Ord v => OpUse v -> [String] -> Relmap v
relCut :: Ord v => [String] -> Map (Rel v)
relmapPick :: Ord v => OpUse v -> [String] -> Relmap v
relPick :: Ord v => [String] -> Map (Rel v)

-- | Change term names
relmapRename :: OpUse v -> [(String, String)] -> Relmap v

-- | Change terms names
relRename :: [(String, String)] -> Map (Rel v)

-- | Enclose the current relation in a term.
enclose :: RelValue v => String -> Relmap v

-- | Current term configuration.
conf :: StringValue v => String -> Relmap v

-- | Current cardinality.
size :: IntValue v => String -> Relmap v


-- | Minimal implementations of relmaps
module Koshucode.Baala.Minimal.Relmap.Implement

-- | Minimal implementations of relmaps
minimalOperators :: Ord v => [OpImplement v]

module Koshucode.Baala.Vanilla.Calc.Ripen
calcRipen :: Ripen Token Val

-- | Convert infix form to prefix form
calcBinary :: TokenTree -> TokenTree

module Koshucode.Baala.Vanilla.Calc

-- | Prepare calculation. <tt>makeCalc</tt> <i>H E</i> is a calculator from
--   an expression <i>E</i> on a head <i>H</i>. Terms in <i>E</i> must be
--   terms in <i>H</i>. If not in <i>H</i>, an error is reported.
makeCalc :: Relhead -> TokenTree -> Calc Val

-- | Prepare named calculators
makeHeadCalcs :: Relhead -> [TokenTree] -> (Relhead, [Calc Val])


-- | Relational mappers
module Koshucode.Baala.Vanilla.Relmap.Calc

-- | Make relmap function for <tt>hold</tt> operator.
holdBody :: (Val -> Val -> Bool) -> TokenTree -> a -> RelmapFun Val

-- | Make relmap function for <tt>val</tt> operator.
valBody :: [TokenTree] -> a -> RelmapFun Val

-- | Keep leading tuples.
limit :: Ord v => OpUse v -> Int -> String -> Relmap v

module Koshucode.Baala.Vanilla.Relmap.Naming
relmapPrefix :: OpUse v -> String -> [String] -> Relmap v

-- | Add prefix to terms.
relPrefix :: String -> [String] -> Map (Rel v)
relmapUnprefix :: OpUse v -> String -> Relmap v

-- | Remove prefix
relUnprefix :: String -> Map (Rel v)
relmapPrefixChange :: OpUse v -> String -> String -> Relmap v

-- | Change prefix
relPrefixChange :: String -> String -> Map (Rel v)


-- | Minimal relational operators.
module Koshucode.Baala.Minimal.Relmap


-- | Minimal relational operators
module Koshucode.Baala.Minimal

module Koshucode.Baala.Vanilla.Relmap.Operand

-- | <a>OpPattern</a> for relational operations.
data VanillaOperand

-- | Boolean expression
LikeHold :: VanillaOperand

-- | List of new term and expression
LikeVal :: VanillaOperand

-- | Relmap and maybe shared terms
LikeMeet :: VanillaOperand

-- | Prefix
LikePrefix :: VanillaOperand

-- | Relsign and list of terms
LikeSource :: VanillaOperand

-- | Prefix
LikeUnprefix :: VanillaOperand

-- | Prefix
LikePrefixChange :: VanillaOperand
instance Show VanillaOperand
instance Eq VanillaOperand
instance Enum VanillaOperand
instance OpPattern VanillaOperand

module Koshucode.Baala.Vanilla.Relmap.Implement

-- | Implementation of relational operators.
vanillaOperators :: [OpImplement Val]

-- | like SQL's left join
relMaybe :: (Ord v, Nil v) => Rel v -> Rel v -> Rel v

-- | Hanging relation, like grouping.
hang :: (Ord v, RelValue v) => OpUse v -> String -> Relmap v -> Relmap v
relHang :: (Ord v, RelValue v) => [String] -> [Rel v] -> Rel v -> Rel v
selfhang :: a


-- | Quasiquoter of Koshucode
module Koshucode.Baala.Vanilla.Quoter

-- | Quasiquoter for <tt>[koshu| ... |]</tt>.
koshu :: QuasiQuoter

module Koshucode.Baala.Vanilla
