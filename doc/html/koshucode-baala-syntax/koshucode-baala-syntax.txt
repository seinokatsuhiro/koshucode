-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Syntax for Koshucode
--   
--   Syntax for Koshucode
@package koshucode-baala-syntax
@version 0.133.0.0

module Koshucode.Baala.Syntax.Symbol.Term

-- | Name of term, e.g., <tt>"file"</tt> for the term name <tt>/file</tt>.
type TermName = String
type TermName2 = (String, String)
type TermName3 = (String, String, String)
type TermName4 = (String, String, String, String)
type TermName5 = (String, String, String, String, String)
type TermName6 = (String, String, String, String, String, String)

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]
type SignedTermName = (Ordering, TermName)
showTermName :: TermName -> String
showTermPath :: TermPath -> String
type Term c = (TermName, c)
term :: TermName -> c -> Term c

-- | Check present term.
termP :: Int -> Bool

-- | Check new term.
termN :: Int -> Bool
termPN :: Int -> Int -> Bool
termsP :: [Int] -> Bool
termsN :: [Int] -> Bool
termsPN :: [Int] -> [Int] -> Bool


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Syntax.Symbol.AngleText

-- | Convert string into double-quoted and angle-quoted form.
angleQuote :: Map String

-- | Table of coresspondences of angle text and its replacement.
angleTexts :: [(String, String)]

module Koshucode.Baala.Syntax.Attr.Para
type Para a = ParaBody String a
data ParaBody n a
ParaBody :: [a] -> [a] -> ParaMap n a -> ParaBody n a
[paraAll] :: ParaBody n a -> [a]
[paraPos] :: ParaBody n a -> [a]
[paraName] :: ParaBody n a -> ParaMap n a
type ParaMap n a = Map n [[a]]

-- | Parse list into parameter.
para :: (Ord n) => (a -> Maybe n) -> [a] -> ParaBody n a
paraEmpty :: ParaBody n a

-- | Association list of named parameters.
paraNameList :: ParaBody n a -> [(n, [[a]])]

-- | Add named parameter.
paraNameAdd :: (Ord n) => n -> [a] -> Map (ParaBody n a)

-- | Give names to positional parameters.
paraPosName :: (Ord n, Monad m) => ([a] -> m [(n, [a])]) -> ParaBody n a -> m (ParaBody n a)

-- | List of names which appear more than once.
paraMultipleNames :: ParaBody n a -> [n]

-- | Map names of named parameters.
paraNameMapKeys :: (Ord n2) => (n1 -> n2) -> ParaBody n1 a -> ParaBody n2 a
paraLookupSingle :: (Ord n) => n -> ParaBody n a -> Maybe [a]
data ParaType n
ParaType :: ParaPosType -> [n] -> [n] -> [n] -> ParaType n
[paraTypePos] :: ParaType n -> ParaPosType
[paraTypeReq] :: ParaType n -> [n]
[paraTypeOpt] :: ParaType n -> [n]
[paraTypeMult] :: ParaType n -> [n]
data ParaPosType
ParaPosJust :: Int -> ParaPosType
ParaPosMin :: Int -> ParaPosType
ParaPosMax :: Int -> ParaPosType
ParaPosRange :: Int -> Int -> ParaPosType
paraType :: ParaType n
paraJust :: (Show n, Ord n) => ParaType n -> Int -> ParaType n
paraMin :: (Show n, Ord n) => ParaType n -> Int -> ParaType n
paraMax :: (Show n, Ord n) => ParaType n -> Int -> ParaType n
paraRange :: (Show n, Ord n) => ParaType n -> (Int, Int) -> ParaType n
paraReq :: (Show n, Ord n) => ParaType n -> [n] -> ParaType n
paraOpt :: (Show n, Ord n) => ParaType n -> [n] -> ParaType n
paraMult :: (Show n, Ord n) => ParaType n -> [n] -> ParaType n
data ParaUnmatch n
ParaOutOfRange :: Int -> ParaPosType -> ParaUnmatch n
ParaUnknown :: [n] -> ParaUnmatch n
ParaMissing :: [n] -> ParaUnmatch n
ParaMultiple :: [n] -> ParaUnmatch n
paraSelect :: (Eq n) => b -> [(ParaBody n a -> b, ParaType n)] -> ParaBody n a -> b
paraMatch :: (Eq n) => ParaBody n a -> ParaType n -> Bool
paraUnmatch :: (Eq n) => ParaBody n a -> ParaType n -> Maybe (ParaUnmatch n)
paraGet :: (Ord n) => ParaBody n a -> n -> Ab [a]
paraGetOpt :: (Ord n) => [a] -> ParaBody n a -> n -> Ab [a]
paraGetList :: (Ord n) => ParaBody n a -> n -> Ab [[a]]
paraGetSwitch :: (Ord n) => ParaBody n a -> n -> Ab Bool
paraGetPos :: ParaBody n a -> Ab [a]
paraGetFst :: ParaBody n a -> Ab a
paraGetSnd :: ParaBody n a -> Ab a
paraGetTrd :: ParaBody n a -> Ab a
paraGetRest :: ParaBody n a -> Ab [a]
paraGetRRest :: ParaBody n a -> Ab [a]
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Attr.Para.ParaUnmatch n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Attr.Para.ParaUnmatch n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Attr.Para.ParaUnmatch n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Koshucode.Baala.Syntax.Attr.Para.ParaType n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Koshucode.Baala.Syntax.Attr.Para.ParaType n)
instance GHC.Show.Show n => GHC.Show.Show (Koshucode.Baala.Syntax.Attr.Para.ParaType n)
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.Para.ParaPosType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.Para.ParaPosType
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Para.ParaPosType
instance (Data.Data.Data n, Data.Data.Data a, GHC.Classes.Ord n) => Data.Data.Data (Koshucode.Baala.Syntax.Attr.Para.ParaBody n a)
instance (GHC.Classes.Ord n, GHC.Classes.Ord a) => GHC.Classes.Ord (Koshucode.Baala.Syntax.Attr.Para.ParaBody n a)
instance (GHC.Classes.Eq n, GHC.Classes.Eq a) => GHC.Classes.Eq (Koshucode.Baala.Syntax.Attr.Para.ParaBody n a)
instance (GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Koshucode.Baala.Syntax.Attr.Para.ParaBody n a)
instance GHC.Classes.Ord n => GHC.Base.Monoid (Koshucode.Baala.Syntax.Attr.Para.ParaBody n a)

module Koshucode.Baala.Syntax.Token.Message
abToken :: (CodePtr cp) => [cp] -> Map (Ab b)

-- | Forbidden input
forbiddenInput :: String -> Ab a

-- | Unexpedted section delimiter
unexpSect :: [String] -> Ab a

-- | Unknown bracket text
unkAngleText :: String -> Ab a

module Koshucode.Baala.Syntax.Symbol.Message

-- | Expect ordinary symbol
expOrdSym :: Ab a

-- | Quotation not end in line
quotNotEnd :: Ab a


-- | Next character sequence.
module Koshucode.Baala.Syntax.Symbol.Next

-- | Input data type.
type InputText = String

-- | Split next character sequence from input text.
type Next a = InputText -> (InputText, a)

-- | Split next character sequence from input text.
type AbNext a = InputText -> Ab (InputText, a)

-- | Get next spaces.
nextSpace :: Next Int

-- | Get next double-quoted text.
nextQQ :: AbNext String

-- | Symbol class.
--   
--   Relation between character classes and symbol classes. The char class
--   <tt>number'</tt> means Unicode number except for <tt>0-9</tt>.
--   <tt>G</tt> for general symbol, <tt>P</tt> for plain, <tt>N</tt> for
--   numeric.
--   
--   <pre>
--   Char class   Symbol class
--   ------------ -----------------
--   "0-9"        ( G ) ( P ) ( N )
--   "-"          ( G ) ( P ) ( N )
--   letter       ( G )   P
--   mark         ( G )   P
--   number'      ( G )   P
--   "_?"         ( G )   P
--   "+"          ( G )         N
--   "*=&lt;&gt;~"        G
--   ".#"                       N
--   </pre>
--   
--   Partial order of symbol classes.
--   
--   <pre>
--                     ( GPN ) Common
--                    /      |
--           Plain ( GP )  ( GN ) Numeric
--                /  |    /  |
--   Short ( P.P )   |   /   |
--            :      |  /    |
--         General ( G )     |
--            :      :     ( N ) Numeric
--            :      :       :
--            ................ Unknown
--   </pre>
data Symbol

-- | General-ordinary-numeric symbol
SymbolCommon :: String -> Symbol

-- | General symbol
SymbolGeneral :: String -> Symbol

-- | Plain symbol
SymbolPlain :: String -> Symbol

-- | Numeric symbol
SymbolNumeric :: String -> Symbol

-- | Short symbol (Plain <tt>"."</tt> Plain)
SymbolShort :: String -> String -> Symbol

-- | Unknown symbol
SymbolUnknown :: String -> Symbol

-- | Test symbol is general, in other words, <a>SymbolCommon</a>,
--   <a>SymbolPlain</a> or <a>SymbolGeneral</a>.
isGeneralSymbol :: Symbol -> Bool

-- | Test symbol is plain, in other words, <a>SymbolCommon</a> or
--   <a>SymbolPlain</a>.
isPlainSymbol :: Symbol -> Bool

-- | Test symbol is numeric, in other words, <a>SymbolCommon</a> or
--   <a>SymbolNumeric</a>.
isNumericSymbol :: Symbol -> Bool

-- | Test symbol is <a>SymbolShort</a>.
isShortSymbol :: Symbol -> Bool

-- | Test character is a symbol component.
isSymbolChar :: Char -> Bool

-- | Test character is a general-symbol component.
isGeneralChar :: Char -> Bool

-- | Test character is a plain-symbol component.
isPlainChar :: Char -> Bool

-- | Test character is a numeric-symbol component.
isNumericChar :: Char -> Bool

-- | Get next symbol.
nextSymbol :: Next Symbol
nextSymbolPlain :: AbNext String
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Symbol.Next.Symbol
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Symbol.Next.Symbol
instance GHC.Show.Show Koshucode.Baala.Syntax.Symbol.Next.Symbol


-- | Short sign.
module Koshucode.Baala.Syntax.Symbol.Short

-- | Something with short definition.
data Short a
Short :: [CodePt] -> [ShortDef] -> a -> Short a
[shortSource] :: Short a -> [CodePt]
[shortHead] :: Short a -> [ShortDef]
[shortBody] :: Short a -> a

-- | Short prefix and replacement.
type ShortDef = Named String
shortTrim :: Map [Short [a]]
shortM :: (Monad m) => Short (m a) -> m (Short a)
shortListM :: (Monad m) => [Short (m a)] -> m [Short a]
shortGroup :: [Short a] -> [Short [a]]

-- | String shortener.
shortText :: [ShortDef] -> Shortener
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Symbol.Short.Short a)
instance GHC.Base.Functor Koshucode.Baala.Syntax.Symbol.Short.Short


-- | Symbols
module Koshucode.Baala.Syntax.Symbol


-- | Tokens in Koshucode.
module Koshucode.Baala.Syntax.Token.Token

-- | There are nine types of tokens.
data Token

-- | Text.
TText :: CodePt -> TextForm -> String -> Token

-- | Blank name.
TName :: CodePt -> BlankName -> Token

-- | Slot name. <a>Int</a> represents slot level, i.e., 0 for local
--   positional slots, 1 for local named slots, 2 for global slots.
TSlot :: CodePt -> Int -> String -> Token

-- | Prefixed shorten text.
TShort :: CodePt -> String -> String -> Token

-- | Term name.
TTermN :: CodePt -> Ordering -> TermName -> Token

-- | Term path.
TTerm :: CodePt -> TermType -> TermPath -> Token

-- | Local name.
TLocal :: CodePt -> (Local String) -> Int -> [Token] -> Token

-- | Opening bracket.
TOpen :: CodePt -> String -> Token

-- | Closing bracket.
TClose :: CodePt -> String -> Token

-- | <i>N</i> space characters.
TSpace :: CodePt -> Int -> Token

-- | Comment.
TComment :: CodePt -> String -> Token
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName
textToken :: String -> Token
nameToken :: String -> Token
data Local a
LocalSymbol :: a -> Local a
LocalNest :: a -> Local a
unlocal :: Local a -> a
data TextForm

-- | Unknown keyword
TextUnk :: TextForm

-- | Naked text
TextRaw :: TextForm

-- | Single-quoted text
TextQ :: TextForm

-- | Double-quoted text
TextQQ :: TextForm

-- | Keyword literal
TextKey :: TextForm

-- | Text enclosed in bars
TextBar :: TextForm

-- | Text used as name
TextName :: TextForm

-- | Text ins license section
TextLicense :: TextForm
data TermType

-- | Normal term path
TermTypePath :: TermType

-- | Quoted term name
TermTypeQuoted :: TermType

-- | Get the content of token.
tokenContent :: Token -> String
untoken :: Token -> String

-- | Text of token type, e.g., <tt>"text"</tt>, <tt>"open"</tt>.
tokenTypeText :: Token -> String
tokenSubtypeText :: Token -> Maybe String
tokenParents :: Token -> [Token]

-- | Test the token is blank, i.e., comment or space.
isBlankToken :: Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]
isShortToken :: Pred Token
isTermToken :: Pred Token
isOpenToken :: Pred Token
isCloseToken :: Pred Token

-- | Check token is a <a>TOpen</a> of the specific bracket.
isOpenTokenOf :: String -> Pred Token

-- | Check token is a <a>TClose</a> of the specific bracket.
isCloseTokenOf :: String -> Pred Token
instance Data.Data.Data Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.Token
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.Token
instance Data.Data.Data Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.BlankName
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.BlankName
instance Data.Data.Data Koshucode.Baala.Syntax.Token.Token.TermType
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TermType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TermType
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TermType
instance Data.Data.Data Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Token.TextForm
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Token.TextForm
instance Data.Data.Data a => Data.Data.Data (Koshucode.Baala.Syntax.Token.Token.Local a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Token.Token.Local a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Token.Token.Local a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Token.Token.Local a)
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Text.CodePt.CodePtr Koshucode.Baala.Syntax.Token.Token.Token
instance Koshucode.Baala.Base.Prelude.Class.Name Koshucode.Baala.Syntax.Token.Token.BlankName
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Syntax.Token.Token.BlankName


-- | Bracket type.
module Koshucode.Baala.Syntax.Token.Bracket

-- | Type of bracket.
data BracketType

-- | Round brackets for grouping: <tt>( E ... )</tt>
BracketGroup :: BracketType

-- | Square brackets for lists: <tt>[ C | ... ]</tt>
BracketList :: BracketType

-- | Curely braces for sets: <tt>{ C | .... }</tt>
BracketSet :: BracketType

-- | Curely-single braces for ties: <tt>{- /N C ... -}</tt>
BracketTie :: BracketType

-- | Curely-double braces for relations: <tt>{= /N ... [ C | ... ][ C | ...
--   ] =}</tt>
BracketRel :: BracketType

-- | Curely-bar braces for data interpretation: <tt>{| ... /N ... |}</tt>
BracketInterp :: BracketType

-- | Square-single brackets for type: <tt>[- ... -]</tt>
BracketType :: BracketType

-- | Round-bar brackets for form with blanks: <tt>(| V ... | E ... |)</tt>
BracketForm :: BracketType

-- | Unknown bracket
BracketUnknown :: BracketType

-- | Bracket type of token.
getBracketType :: GetBracketType BracketType Token

-- | Open group: <tt>"("</tt>
groupOpen :: String

-- | Close group: <tt>")"</tt>
groupClose :: String

-- | Open list: <tt>"["</tt>
listOpen :: String

-- | Close list: <tt>"]"</tt>
listClose :: String

-- | Open set: <tt>"{"</tt>
setOpen :: String

-- | Close set: <tt>"}"</tt>
setClose :: String

-- | Open tie: <tt>"{-"</tt>
tieOpen :: String

-- | Close tie: <tt>"-}"</tt>
tieClose :: String

-- | Open relation: <tt>"{="</tt>
relOpen :: String

-- | Close relation: <tt>"=}"</tt>
relClose :: String

-- | Open interpreation: <tt>"{|"</tt>
interpOpen :: String

-- | Close interpreation: <tt>"|}"</tt>
interpClose :: String

-- | Open type: <tt>"[-"</tt>
typeOpen :: String

-- | Close type: <tt>"-]"</tt>
typeClose :: String
instance Data.Data.Data Koshucode.Baala.Syntax.Token.Bracket.BracketType
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Token.Bracket.BracketType
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Token.Bracket.BracketType
instance GHC.Show.Show Koshucode.Baala.Syntax.Token.Bracket.BracketType


-- | Tokenizer of koshucode.
module Koshucode.Baala.Syntax.Token.TokenLine

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Tokenize text.
tokenLines :: CodePiece -> InputText -> Ab [TokenLine]

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: CodePiece -> InputText -> Ab [Token]

-- | Abbreviated tokenizer.
toks :: InputText -> Ab [Token]
isShortPrefix :: Pred String

module Koshucode.Baala.Syntax.Token.TokenClause
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]
instance Koshucode.Baala.Base.Text.Write.Write Koshucode.Baala.Syntax.Token.TokenClause.TokenClause


-- | Tree of tokens
module Koshucode.Baala.Syntax.Token.TokenTree

-- | Tree of tokens.
type TTree = CodeTree BracketType Token

-- | Pair of token tree and its name.
type NamedTree = Named TTree

-- | Pair of token trees and its name.
type NamedTrees = Named [TTree]

-- | Convert token tree to something.
type TTreeTo a = TTree -> a

-- | Convert list of token tree to sometning.
type TTreesTo a = [TTree] -> a

-- | Convert token tree to something, abortable.
type TTreeToAb a = TTree -> Ab a

-- | Convert list of token tree to sometning, abortable.
type TTreesToAb a = [TTree] -> Ab a

-- | Parse tokens with brackets into trees. Blank tokens and comments are
--   excluded.
ttrees :: [Token] -> Ab [TTree]

-- | Wrap trees in group.
ttreeGroup :: TTreesTo TTree

-- | Text leaf.

-- | Text leaf of <a>TextRaw</a>.

-- | Text leaf beginning with single hyphen.

-- | Text leaf beginning with double hyphens.

-- | Text leaf of <a>TextQ</a>.

-- | Text leaf of <a>TextQQ</a>.

-- | Text leaf of <a>TextKey</a>.

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "b c"
--   Left [ TText 1 0 "b", TSpace 2 1, TText 3 0 "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "a | b | c"
--   Right ( [ TText 1 0 "a", TSpace 2 1 ]
--           , TText 3 0 "|"
--           , [ TSpace 4 1, TText 5 0 "b", TSpace 6 1
--             , TText 7 0 "|", TSpace 8 1, TText 9 0 "c" ] )
--   </pre>
splitTokensBy :: Pred String -> [Token] -> Either [Token] ([Token], Token, [Token])

-- | Divide token trees by quoteless token of given string.
divideTreesBy :: String -> TTreesTo [[TTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
divideTreesByBar :: TTreesTo [[TTree]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: TTreesTo [[TTree]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: TTreesTo [[TTree]]

-- | Convert text to token trees.
tt :: String -> Ab [TTree]

-- | Parse string and group it.
tt1 :: String -> Ab TTree

-- | Parse string and print it.
ttPrint :: String -> IO ()

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: TTreesTo Doc


-- | Tokens in Koshucode.
module Koshucode.Baala.Syntax.Token

module Koshucode.Baala.Syntax.Attr.Message
abAttr :: (CodePtr cp) => [cp] -> Map (Ab b)
abAttrTrees :: TTreesTo (Map (Ab b))
abSlot :: (CodePtr cp) => [cp] -> Map (Ab b)
abSlotTree :: TTreeTo (Map (Ab b))

-- | Same as <tt>abortable</tt> except for using <a>TTree</a> instead of
--   list of <a>Token</a>.
abortableTree :: String -> TTreeTo (Map (Ab b))

-- | Same as <tt>abortable</tt> except for using list of <a>TTree</a>
--   instead of list of <a>Token</a>.
abortableTrees :: String -> TTreesTo (Map (Ab b))

-- | Unexpected attribute / Duplicate
dupAttr :: [String] -> Ab a

-- | Extra attribute
extraAttr :: Ab a

-- | No slot content
noSlotName :: Int -> String -> Ab a

-- | No slot content
noSlotIndex :: [String] -> Int -> Ab a

-- | Require attribute
reqAttr :: String -> Ab a

-- | Require attribute
reqAttrName :: String -> Ab a

-- | Unexpected attribute
unexpAttr :: String -> Ab a
unexpAttr0 :: Ab a
unexpAttr1 :: Ab a
unexpAttr2 :: Ab a
unexpAttr3 :: Ab a
unexpAttr4 :: Ab a
unexpAttr1V :: Ab a
unexpAttr1Q :: Ab a

module Koshucode.Baala.Syntax.Message


-- | Positional attributes.
module Koshucode.Baala.Syntax.Attr.AttrPos

-- | Positional attribute.
data AttrPos a

-- | No attributes
AttrPos0 :: AttrPos a

-- | Single attribute
AttrPos1 :: a -> AttrPos a

-- | Two attributes
AttrPos2 :: a -> a -> AttrPos a

-- | Three attributes
AttrPos3 :: a -> a -> a -> AttrPos a

-- | Four attributes
AttrPos4 :: a -> a -> a -> a -> AttrPos a

-- | Enumerated attributes
AttrPosE :: [a] -> AttrPos a

-- | Variable-length attributes
AttrPosV :: a -> AttrPos a

-- | Single-and-variable-length attributes
AttrPos1V :: a -> a -> AttrPos a

-- | Single-and-optional attributes
AttrPos1Q :: a -> a -> AttrPos a

-- | Name list of positional attributes.
attrPosNameList :: AttrPos a -> [a]

-- | Attribute name of relmap.
data AttrName

-- | Normal attribute
AttrNormal :: String -> AttrName

-- | Attribute for submap
AttrRelmapNormal :: String -> AttrName

-- | Attribute for submap with local relation references
AttrRelmapLocal :: String -> AttrName

-- | Test attribute name is for subrelmap.
isAttrNameRelmap :: AttrName -> Bool

-- | String part of attribute names.
attrNameText :: AttrName -> String

-- | Constant for attribute name <tt>@trunk</tt>.
attrNameTrunk :: AttrName

-- | Positional attribute
type AttrNamePos = AttrPos AttrName

-- | Attribute name and its contents.
type AttrTree = (AttrName, [TTree])

-- | Positional attribute sorter.
type AttrSortTree = [TTree] -> Ab [AttrTree]

-- | Sort token trees by positional attributes.
sortAttrTree :: AttrNamePos -> AttrSortTree
instance Data.Data.Data Koshucode.Baala.Syntax.Attr.AttrPos.AttrName
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrPos.AttrName
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrPos.AttrName
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrPos.AttrName
instance GHC.Classes.Ord a => GHC.Classes.Ord (Koshucode.Baala.Syntax.Attr.AttrPos.AttrPos a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Koshucode.Baala.Syntax.Attr.AttrPos.AttrPos a)
instance GHC.Show.Show a => GHC.Show.Show (Koshucode.Baala.Syntax.Attr.AttrPos.AttrPos a)


-- | Attributes of relmap operator.
module Koshucode.Baala.Syntax.Attr.Attr

-- | Attribute layout.
data AttrLayout
AttrLayout :: AttrSortTree -> Map AttrName -> AttrNamePos -> [AttrName] -> [AttrName] -> AttrLayout

-- | Sorter for positional attributes (derived from <tt>attrPos</tt>)
[attrPosSorter] :: AttrLayout -> AttrSortTree

-- | Attribute classifier (derived from <tt>attrNamesP</tt> and
--   <tt>attrNamesN</tt>)
[attrClassifier] :: AttrLayout -> Map AttrName

-- | Positional attribute
[attrPos] :: AttrLayout -> AttrNamePos

-- | Names of positional attributes (derived from <tt>attrPos</tt>)
[attrNamesP] :: AttrLayout -> [AttrName]

-- | Names of named attributes
[attrNamesN] :: AttrLayout -> [AttrName]

-- | Construct attribute layout from positional and named attributes.
attrLayout :: AttrNamePos -> [AttrName] -> AttrLayout

-- | Attribute set.
type AttrSet = ParaBody AttrName TTree

-- | Sorter for attribute of relmap operator. Sorters docompose attribute
--   trees, and give a name to subattribute.
type AttrSetSort = [TTree] -> Ab AttrSet

-- | Sort attributes.
attrSetSort :: AttrLayout -> AttrSetSort

-- | Sort named part of attribute.
attrSetSortNamed :: AttrSetSort

-- | Take out hyphened text (like <tt>"-x"</tt>) from token tree.
maybeSingleHyphen :: TTreeTo (Maybe String)

-- | Take out double-hyphened text (like <tt>"--xyz"</tt>) from token tree.
maybeDoubleHyphen :: TTreeTo (Maybe String)
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.Attr.AttrLayout


-- | Parser for attribute sorter.
module Koshucode.Baala.Syntax.Attr.Parse

-- | Parse attribute sorter string.
--   
--   <pre>
--   &gt;&gt;&gt; parseAttrLayout "0 | -c"
--   AttrLayout { positional = AttrPos0,
--                     named = [AttrNormal "c"] }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseAttrLayout "2 -a -b | -c"
--   AttrLayout { positional = AttrPos2 (AttrNormal "a") (AttrNormal "b"),
--                     named = [AttrNormal "c"] }
--   </pre>
parseAttrLayout :: String -> AttrLayout


-- | Slot substitution.
module Koshucode.Baala.Syntax.Attr.Slot
type GlobalSlot = NamedTrees

-- | Substitute slots by global and attribute slots.
substSlot :: [GlobalSlot] -> [AttrTree] -> AbMap [TTree]


-- | Attribute editor.
module Koshucode.Baala.Syntax.Attr.AttrEd

-- | Attribute editor with source code information.
type AttrEd = Sourced AttrEdBody

-- | Operators for attribute editors.
data AttrEdBody

-- | Identity editor
AttrEdId :: AttrEdBody

-- | Add attribute
AttrEdAdd :: Bool -> String -> [TTree] -> AttrEdBody

-- | Rename attribute keyword
AttrEdRename :: (String, String) -> AttrEdBody

-- | Fill positional attributes
AttrEdFill :: [Maybe TTree] -> AttrEdBody

-- | Make term name
AttrEdTerm :: String -> [TTree] -> AttrEdBody

-- | Nested relation reference
AttrEdNest :: String -> [TTree] -> AttrEdBody

-- | Append editors
AttrEdAppend :: [AttrEd] -> AttrEdBody

-- | Construct attribute editor.
consAttrEd :: [TTree] -> Ab AttrEd

-- | Edit relmap attributes.
runAttrEd :: AttrEd -> AbMap [AttrTree]
instance Data.Data.Data Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Classes.Ord Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Classes.Eq Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody
instance GHC.Show.Show Koshucode.Baala.Syntax.Attr.AttrEd.AttrEdBody

module Koshucode.Baala.Syntax.Attr

module Koshucode.Baala.Syntax
