-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational data
--   
--   Koshucode is a notation for people who read, write, and calculate
--   relational data. This library provides functions for handling
--   koshucode on computers.
@package koshucode-baala-base
@version 0.10.0.0


-- | General utilities
module Koshucode.Baala.Base.Prelude.Utility
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
cons1 :: a -> ([a], b) -> ([a], b)
mapmapFst :: (a -> c) -> [(a, b)] -> [(c, b)]
mapmapSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
maybePairs :: [a] -> Maybe [(a, a)]

-- | Entry in association list.
type Named a = (String, a)

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]
unionUp :: Eq a => [a] -> [a] -> [a]

-- | Singleton list
singleton :: a -> [a]
divideBy :: Eq a => a -> [a] -> [[a]]

-- | Gather what is gotten by splitter.
gather :: ([a] -> (b, [a])) -> [a] -> [b]

-- | Gather (key,value) to a Map key [value]
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]


-- | Position in list.
module Koshucode.Baala.Base.Prelude.Position
ap :: ((Int -> v) -> [v] -> a) -> [v] -> a
like :: [Int] -> [Char] -> Bool

-- | Indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; "bdk" `sharedIndex` "abcdefg"
--   [1,3]
--   </pre>
sharedIndex :: Eq a => [a] -> [a] -> [Int]

-- | Pick indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; indexPick [1,3] "abcdefg"
--   "bd"
--   </pre>
indexPick :: [Int] -> [a] -> [a]

-- | Cut indexed elements
--   
--   <pre>
--   &gt;&gt;&gt; indexCut [1,3] "abcdefg"
--   "acefg"
--   </pre>
indexCut :: [Int] -> [a] -> [a]

module Koshucode.Baala.Base.Prelude.Pretty
class Pretty a where docv = vcat . map doc doch = hsep . map doc
doc :: Pretty a => a -> Doc
docv, doch :: Pretty a => [a] -> Doc
docTag :: String -> Doc -> Doc
docParen :: Doc -> Doc
docBracket :: Doc -> Doc
docBrace :: Doc -> Doc
docAngle :: Doc -> Doc
docQuote :: Doc -> Doc
docComment :: Doc -> Doc
instance Pretty Doc


-- | Source information
module Koshucode.Baala.Base.Prelude.Abort.Source

-- | Line number and content in source code
data SourceLine
SourceLine :: Int -> String -> SourceLine

-- | Class that represents abort reason.
class AbortSymbol a where abortSub _ = empty
abortSymbol :: AbortSymbol a => a -> String
abortTitle :: AbortSymbol a => a -> String
abortMain :: AbortSymbol a => a -> Doc
abortSub :: AbortSymbol a => a -> Doc
abortLines :: AbortSymbol a => a -> [SourceLine]
instance Typeable SourceLine
instance Show SourceLine
instance Eq SourceLine
instance Ord SourceLine
instance Data SourceLine
instance Pretty SourceLine


-- | Abort symbol
module Koshucode.Baala.Base.Prelude.Abort.Symbol

-- | Abortable type
type AbortOr a = Either Abort a

-- | Abort symbols
data Abort
AbortLookup :: [SourceLine] -> String -> Abort
AbortMalformedOperand :: [SourceLine] -> String -> Abort
AbortMalformedTerms :: [SourceLine] -> String -> Abort
AbortMissingTermName :: [SourceLine] -> String -> Abort
AbortUnknownClause :: [SourceLine] -> Abort
AbortUnknownRelmap :: [SourceLine] -> String -> Abort
AbortUsage :: [SourceLine] -> [String] -> Abort
instance Show Abort
instance Eq Abort
instance Ord Abort
instance AbortSymbol Abort
instance Name Abort


-- | Abort utility
module Koshucode.Baala.Base.Prelude.Abort.Utility

-- | Lookup association list. This function may abort on AbortLookup.
(<!!>) :: [(String, a)] -> String -> AbortOr a

-- | Stop on error ''bug in koshucode''
bug :: a

-- | Stop program execution abnormally.
abort :: AbortSymbol a => a -> IO ()
addAbort :: AbortSymbol a => a -> Either a b -> Either a b
abortIO :: AbortSymbol a => (b -> IO ()) -> Either a b -> IO ()


-- | Abort symbols
module Koshucode.Baala.Base.Prelude.Abort

module Koshucode.Baala.Base.Prelude


-- | Terms in heading of relation
module Koshucode.Baala.Base.Data.Rel.Relterm

-- | Term in heading of relation
data Relterm
Term :: String -> Relterm
Nest :: String -> [Relterm] -> Relterm
termLook :: [[String]] -> [Relterm] -> [[Int]]

-- | Term path to term position
termLook1 :: [String] -> [Relterm] -> [Int]
instance Show Relterm
instance Eq Relterm
instance Ord Relterm
instance Pretty Relterm
instance Name Relterm


-- | Heading of relations
module Koshucode.Baala.Base.Data.Rel.Relhead

-- | Heading of relation as a list of terms
data Relhead
Relhead :: [Relterm] -> Relhead
headTerms :: Relhead -> [Relterm]

-- | Term position
data TermPos

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Make head from term names
headFrom :: [String] -> Relhead

-- | Number of terms
headDegree :: Relhead -> Int

-- | List of term names
headNames :: Relhead -> [String]

-- | Reconstruct head
rehead :: ([String] -> [String]) -> Relhead -> Relhead

-- | Positions of given names in a head
headPoss :: Relhead -> [[String]] -> [TermPos]

-- | Positions of given (sub)head in a head
headPosh :: Relhead -> Relhead -> [TermPos]

-- | Indicies
posPoss :: [TermPos] -> [Int]

-- | Pick values
possPick :: [TermPos] -> [v] -> [v]

-- | Pick an inner part.
possInner :: [TermPos] -> [[String]]

-- | Pick an outer part.
possOuter :: [TermPos] -> [[String]]
instance Show Relhead
instance Eq Relhead
instance Ord Relhead
instance Show TermPos
instance Eq TermPos
instance Ord TermPos
instance Name TermPos
instance Pretty Relhead
instance Monoid Relhead

module Koshucode.Baala.Base.Kit.Order
data OrderCap v
orders :: String -> [OrderCap [Char]]
sortByName :: (Ord v, Eq n) => [OrderCap n] -> [n] -> [[v]] -> [[v]]
instance Show v => Show (OrderCap v)
instance Eq v => Eq (OrderCap v)
instance Ord v => Ord (OrderCap v)

module Koshucode.Baala.Base.Syntax.Tree

-- | Get a paren type
type ParenType a = a -> Int

-- | Get paren from type
type TypeParen a = Int -> (a, a)

-- | Make <a>ParenType</a> and <a>TypeParen</a> functions from a
--   type-open-close table.
--   
--   Make paren/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (pt, tp) = parenTable [(1,'(',')'), (2,'[',']')]
--   </pre>
--   
--   Get paren types for each chars. Types of open parens are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0,0,1,0,0,2,0,0,-2,-1,0]
--   </pre>
--   
--   Get an open-close pair of parens from its type.
--   
--   <pre>
--   &gt;&gt;&gt; tp 2
--   ('[', ']')
--   </pre>
parenTable :: Eq a => [(Int, a, a)] -> (ParenType a, TypeParen a)

-- | Tree of leaf and branch
data Tree a

-- | Terminal of a tree
TreeL :: a -> Tree a

-- | Paren-type and subtrees
TreeB :: Int -> [Tree a] -> Tree a

-- | Convert a list of elements to a single tree
tree :: Show a => ParenType a -> [a] -> Tree a

-- | Convert a list of elements to trees
trees :: Show a => ParenType a -> [a] -> [Tree a]

-- | Convert tree to list of tokens
untree :: TypeParen a -> Tree a -> [a]

-- | Convert tree to list of tokens
untrees :: TypeParen a -> [Tree a] -> [a]

-- | Simplify tree by removing double parens, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
undouble :: Tree a -> Tree a
instance Typeable1 Tree
instance Show a => Show (Tree a)
instance Eq a => Eq (Tree a)
instance Ord a => Ord (Tree a)
instance Data a => Data (Tree a)
instance Functor Tree


-- | Convert infixed-operator trees into prefixed-operator trees
module Koshucode.Baala.Base.Syntax.Binary

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type BinaryHeight = Either Int Int

-- | Split branches in a given tree at infixed binary operators
binaryTree :: Show a => (a -> BinaryHeight) -> Tree a -> Tree a

-- | Make the height function from a height table of operators
heightTable :: Ord a => [(BinaryHeight, [a])] -> (a -> BinaryHeight)


-- | Tokens in Koshucode
module Koshucode.Baala.Base.Syntax.Token
data Token

-- | Text
Word :: Int -> String -> Token

-- | Term name
TermN :: [String] -> Token

-- | Term position
TermP :: [Int] -> Token

-- | Open paren
Open :: String -> Token

-- | Close paren
Close :: String -> Token

-- | N space chars
Space :: Int -> Token

-- | Comment text
Comment :: String -> Token

-- | Source infomation
Line :: SourceLine -> Token

-- | Test the token is blank, i.e., <a>Comment</a>, <a>Line</a>, or
--   <a>Space</a>.
isBlank :: Token -> Bool
isLineToken :: Token -> Bool

-- | Test the token is a term, i.e., <a>TermN</a> or <a>TermP</a>
isTerm :: Token -> Bool

-- | Split string into list of tokens
--   
--   <pre>
--   &gt;&gt;&gt; tokens "|-- R  /a A0 /b 31"
--   [Line 1 "|-- R  /a A0 /b 31",
--    Word 0 "|--", Space 1, Word 0 "R", Space 2,
--    TermN ["/a"], Space 1, Word 0 "A0", Space 1,
--    TermN ["/b"], Space 1, Word 0 "31"]
--   </pre>
tokens :: String -> [Token]

-- | Convert back a token list to a source string
untokens :: [Token] -> String

-- | Remove blank tokens.
sweepToken :: [Token] -> [Token]

-- | Skip leading blank tokens.
sweepLeft :: [Token] -> [Token]
instance Typeable Token
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance Show SrcLine
instance Eq SrcLine
instance Name Token


-- | Parened tree of tokens
module Koshucode.Baala.Base.Syntax.TokenTree

-- | Tree of tokens
type TokenTree = Tree Token

-- | Parse tokens into parened trees. Blank tokens are excluded.
--   
--   <pre>
--   &gt;&gt;&gt; tokenTrees $ tokens $ "meet (R | pick /a /b)"
--   [TreeL (Word 0 "meet"),
--    TreeB 1 [
--      TreeL (Word 0 "R"),
--      TreeL (Word 0 "|"),
--      TreeL (Word 0 "pick"),
--      TreeL (TermN ["/a"]),
--      TreeL (TermN ["/b"])]]
--   </pre>
tokenTrees :: [Token] -> [TokenTree]

-- | Convert back tree to source string
tokenTreesSource :: [TokenTree] -> String


-- | Syntax utilities
module Koshucode.Baala.Base.Syntax.Utility

-- | Extract a list of term names.
--   
--   <pre>
--   &gt;&gt;&gt; termNames $ tokenTrees $ tokens "/a /b /c"
--   Right ["/a","/b","/c"]
--   </pre>
termNames :: [TokenTree] -> AbortOr [String]

-- | Extract a list of name-and-name pairs.
--   
--   <pre>
--   &gt;&gt;&gt; termNamePairs $ tokenTrees $ tokens "/a /x /b /y"
--   Right [("/a","/x"), ("/b","/y")]
--   </pre>
termNamePairs :: [TokenTree] -> AbortOr [(String, String)]

-- | Extract a list of name-and-tree pairs.
--   
--   <pre>
--   &gt;&gt;&gt; termTreePairs $ tokenTrees $ tokens "/a 'A3' /b 10"
--   Right [("/a", TreeL (Word 1 "A3")), ("/b", TreeL (Word 0 "10"))]
--   </pre>
termTreePairs :: [TokenTree] -> AbortOr [(String, TokenTree)]
liner :: [Token] -> [[Token]]
sourceLines :: [Token] -> [SourceLine]

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; operandGroup $ tokenTrees $ tokens "a b -x c 'd' -y e"
--   [("",   [TreeL (Word 0 "a"), TreeL (Word 0 "b")]),
--    ("-x", [TreeL (Word 0 "c"), TreeL (Word 1 "d")]),
--    ("-y", [TreeL (Word 0 "e")])]
--   </pre>
operandGroup :: [TokenTree] -> [(String, [TokenTree])]

-- | Calculator combining values into a single value
type Calc v = [v] -> v

-- | Set of operators
type Ripen x v = x -> [v] -> Calc v

-- | Calculate a value of tree
crop :: Ripen x v -> Tree x -> Calc v


-- | Modules on syntax
module Koshucode.Baala.Base.Syntax


-- | Type for relations
module Koshucode.Baala.Base.Data.Rel

-- | Relations on type v. Heading of relation and body of relation as a
--   list of tuples.
data Rel v
Rel :: Relhead -> (Relbody v) -> Rel v

-- | List of positional args
type Relbody v = [[v]]

-- | Relation-to-relation mapping
type RelmapFun v = Rel v -> Rel v

-- | Relational constant that has no terms and no tuples
reldum :: Rel v

-- | Relational constant that has no terms and the empty tuple
reldee :: Rel v
instance Show v => Show (Rel v)
instance Eq v => Eq (Rel v)
instance Ord v => Ord (Rel v)
instance Pretty v => Pretty (Rel v)

module Koshucode.Baala.Base.Data.ValueClass
class BoolValue v
boolValue :: BoolValue v => Bool -> v
isBoolValue :: BoolValue v => v -> Bool
class IntValue v
intValue :: IntValue v => Int -> v
isIntValue :: IntValue v => v -> Bool
class StringValue v
stringValue :: StringValue v => String -> v
isStringValue :: StringValue v => v -> Bool
class ListValue v
listValue :: ListValue v => [v] -> v
isListValue :: ListValue v => v -> Bool
class RelValue v
relValue :: RelValue v => Rel v -> v
isRelValue :: RelValue v => v -> Bool

-- | Types that can be nil
class Nil v
nil :: Nil v => v
isNil :: Nil v => v -> Bool
class (Ord v, Pretty v, Nil v, StringValue v) => Value v


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Base.Data.Judge

-- | Judgement on type <tt>v</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, sign of relation, and argument. <a>Bool</a> value of logical
--   quality corresponds to affirmed or denied judge. <a>String</a> value
--   of sign represents certain sentence pattern that gives intepretation
--   of data. Sentence pattern has placeholders filled by (<a>String</a>,
--   <tt>v</tt>) values of argument.
data Judge v
Judge :: Bool -> Relsign -> (Relarg v) -> Judge v

-- | Sign of relation, or relation name.
type Relsign = String

-- | List of terms.
type Relarg v = [(String, v)]

-- | Sort terms in alphabetical order.
abcJudge :: Ord v => Judge v -> Judge v
instance Show v => Show (Judge v)
instance Eq v => Eq (Judge v)
instance Ord v => Ord (Judge v)
instance (Ord v, Pretty v) => Pretty (Judge v)
instance Functor Judge


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Base.Data.Dataset

-- | Dataset is a set of judges.
data Dataset v

-- | Dataset that has no judges
emptyDataset :: Dataset v

-- | Gather judges into a dataset
dataset :: [Judge v] -> Dataset v

-- | Add judges to dataset.
addJudges :: [Judge v] -> Dataset v -> Dataset v

-- | Select relation from dataset. If a giving term is not in judges,
--   <a>Nil</a> sign is used.
selectRelation :: (Ord v, Nil v) => Dataset v -> Relsign -> [String] -> Rel v


-- | Data on value type <tt>v</tt>
module Koshucode.Baala.Base.Data

module Koshucode.Baala.Base.Kit.WithName

-- | Call a relmap function with present term names.
withP :: WithTerms v

-- | Call a relconfl function with present term names.
withP2 :: ([String] -> [Rel v] -> RelmapFun v) -> String -> [Rel v] -> RelmapFun v

-- | Call a relmap function with new-and-present term names.
withNP :: WithTerms2 v

-- | Call a relmap function with new term names.
withN1 :: WithTerms v
type WithTerms v = ([String] -> RelmapFun v) -> String -> RelmapFun v
type WithTerms2 v = ([(String, String)] -> RelmapFun v) -> String -> RelmapFun v


-- | Data structures for relation-to-relation mappings
module Koshucode.Baala.Base.Struct.Full.Relmap

-- | Relation-to-relation mapping. A Relmap is correspond to a pair of
--   operator and its operands, that is a use of relational operator.
--   Calculations for relations are done by <a>runRelmap</a>.
--   
--   This picture represents calculation of mapping input relation to
--   output relation.
--   
--   <pre>
--   input -[ relmap ]- output
--   </pre>
--   
--   Relmap <i>A</i> maps relation <i>R1</i> to relation <i>R2</i>. Another
--   relmap <i>B</i> maps <i>R2</i> to <i>R3</i>.
--   
--   <pre>
--   R1 -[ A ]- R2
--   R2 -[ B ]- R3
--   </pre>
--   
--   Two relmaps <i>A</i> and <i>B</i> are jointed with intermidiate
--   relation <i>R2</i>.
--   
--   <pre>
--   R1 -[ A ]- R2 -[ B ]- R3
--   </pre>
--   
--   Or, we can draw a directly jointed picture. This whole structure is
--   also <a>Relmap</a> of <a>RelmapAppend</a> <i>A B</i>.
--   
--   <pre>
--   R1 -[ A ]--[ B ]- R3
--   </pre>
data Relmap v

-- | Relmap that retrieves a relation from a dataset
RelmapSource :: HalfRelmap -> String -> [String] -> Relmap v

-- | Relmap that has a constant relation
RelmapConst :: HalfRelmap -> String -> (Rel v) -> Relmap v

-- | Relmap that has equavalent relmap
RelmapAlias :: HalfRelmap -> (Relmap v) -> Relmap v

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> String -> (RelmapSub v) -> [Relmap v] -> Relmap v

-- | Relmap that joints two relmaps
RelmapAppend :: (Relmap v) -> (Relmap v) -> Relmap v

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap v

-- | Function of relmap
type RelmapSub v = [Rel v] -> Rel v -> Rel v

-- | Confluent operator, like binary operator
type RelmapBin v = Relmap v -> Relmap v

-- | Retrieve relation from dataset
relmapSource :: HalfRelmap -> String -> [String] -> (Relmap v)

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap v -> [Relmap v]

-- | Expand <a>RelmapAppend</a> to list of <a>Relmap</a>
relmapAppendList :: Relmap v -> [Relmap v]

-- | Make a non-confluent relmap
relmapCalc :: HalfRelmap -> String -> RelmapSub v -> Relmap v

-- | Make a confluent relmap
relmapConfl :: HalfRelmap -> String -> RelmapSub v -> [Relmap v] -> Relmap v

-- | Make a flow relmap
flow :: String -> RelmapFun v -> Relmap v

-- | Intermediate data that represents use of relational operator.
--   
--   <a>HalfRelmap</a> is constructed from list of <a>TokenTree</a>, and
--   (full) <a>Relmap</a> is constructed from <a>HalfRelmap</a>.
data HalfRelmap
HalfRelmap :: [String] -> [SourceLine] -> String -> [Named [TokenTree]] -> [HalfRelmap] -> HalfRelmap

-- | Usages description
halfUsage :: HalfRelmap -> [String]

-- | Source information
halfLines :: HalfRelmap -> [SourceLine]

-- | Operator name of relmap operation
halfOperator :: HalfRelmap -> String

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> [Named [TokenTree]]

-- | Subrelmaps in the operand
halfSubmap :: HalfRelmap -> [HalfRelmap]

-- | Calculate <a>Relmap</a> for <a>Rel</a>.
runRelmap :: (Ord v, Nil v) => Dataset v -> Relmap v -> Rel v -> AbortOr (Rel v)
instance Typeable HalfRelmap
instance Show HalfRelmap
instance Data HalfRelmap
instance Pretty HalfRelmap
instance Pretty (Relmap v)
instance Name (Relmap v)
instance Monoid (Relmap v)
instance Show (Relmap v)


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Base.Struct.Full.Assert

-- | Affirm or deny a relation. It consists of logical quality, relsign,
--   and relmap.
data Assert v
Assert :: Bool -> Relsign -> Relmap v -> Assert v
assertQuality :: Assert v -> Bool
assertRelsign :: Assert v -> Relsign
assertRelmap :: Assert v -> Relmap v

-- | Make affirmed judges from a relation.
affirm :: Relsign -> Relmap v -> Assert v

-- | Make denied judges from a relation.
deny :: Relsign -> Relmap v -> Assert v

-- | Calculate assertion list.
runAssertJudges :: (Ord v, Nil v) => [Assert v] -> [Judge v] -> AbortOr [Judge v]

-- | Calculate assertion list.
runAssertDataset :: (Ord v, Nil v) => [Assert v] -> Dataset v -> AbortOr [Judge v]
instance Show (Assert v)
instance Pretty (Assert v)
instance Name (Assert v)

module Koshucode.Baala.Base.Struct.Half.HalfRelmap

-- | Make half and full relmap constructors.
makeConsRelmap :: [RelmapImplement v] -> (ConsRelmap v)

-- | Half and full relmap constructor
data ConsRelmap v
ConsRelmap :: RelmapHalfCons -> RelmapWholeCons v -> ConsRelmap v
consHalf :: ConsRelmap v -> RelmapHalfCons
consFull :: ConsRelmap v -> RelmapWholeCons v

-- | Implementation of relmap operator. It consists of (1) operator name,
--   (2) operand parser, (3) full constructor, and (4) usage of operator.
data RelmapImplement v
RelmapImplement :: String -> OperandParser -> (RelmapFullCons v) -> [String] -> RelmapImplement v

-- | Parser for operand of relational operator. This parsers docompose
--   operand trees, and give a name to suboperand.
type OperandParser = [TokenTree] -> [Named [TokenTree]]

-- | First step of relmap construction, make <a>HalfRelmap</a> from use of
--   relational operator.
type RelmapHalfCons = String -> [SourceLine] -> [TokenTree] -> HalfRelmap

-- | Construct half relmaps from source trees.
consHalfRelmap :: RelmapHalfCons -> [SourceLine] -> [TokenTree] -> HalfRelmap

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>HalfRelmap</a>.
type RelmapWholeCons v = HalfRelmap -> AbortOr (Relmap v)
type RelmapFullCons v = [Relmap v] -> HalfRelmap -> AbortOr (Relmap v)
instance Show (ConsRelmap v)


-- | Data structure for relational calculations. There are three types of
--   section: (1) <i>editing sections</i> that output judges and read other
--   sections, (2) <i>library sections</i> that make relmaps reusable, (3)
--   <i>data sections</i> that provide data.
module Koshucode.Baala.Base.Struct.Full.Section
data Section v
Section :: Maybe String -> [Section v] -> [String] -> [Assert v] -> [Named (Relmap v)] -> [Judge v] -> ConsRelmap v -> Section v

-- | Section name
sectionName :: Section v -> Maybe String

-- | Importing section
sectionImport :: Section v -> [Section v]

-- | Exporting relmap names
sectionExport :: Section v -> [String]

-- | Assertions of relmaps
sectionAssert :: Section v -> [Assert v]

-- | Relmaps and its name
sectionRelmap :: Section v -> [Named (Relmap v)]

-- | Here data
sectionJudge :: Section v -> [Judge v]

-- | Readers and writers for this section
sectionCons :: Section v -> ConsRelmap v

-- | Select assertions like <a>sectionAssert</a>. It returns relmap-liked
--   assertions. We can run these assertions using <a>runAssertJudges</a>.
sectionLinkedAssert :: Section v -> [Assert v]

-- | Section that has no contents.
makeEmptySection :: ConsRelmap v -> Section v

-- | Section that has no contents.
emptySection :: Section v

-- | Section that has only here data.
dataSection :: [Judge v] -> Section v
instance Show v => Show (Section v)
instance (Ord v, Pretty v) => Pretty (Section v)

module Koshucode.Baala.Base.Struct.SectionUnion
sectionUnion :: Section v -> Section v -> Section v
sectionUse :: Section v -> Section v -> Section v


-- | Intermidiate structure between <a>String</a> and <a>Section</a>.
module Koshucode.Baala.Base.Struct.Half.Clause
data Clause

-- | Section name
CSection :: [SourceLine] -> (Maybe String) -> Clause

-- | Importing section name
CImport :: [SourceLine] -> [Token] -> (Maybe Clause) -> Clause

-- | Exporting relmap name
CExport :: [SourceLine] -> String -> Clause

-- | Relmap and its name
CRelmap :: [SourceLine] -> String -> HalfRelmap -> Clause

-- | Not include HalfRelmap
TRelmap :: [SourceLine] -> String -> [TokenTree] -> Clause

-- | Assertions of relmaps
CAssert :: [SourceLine] -> Bool -> String -> HalfRelmap -> Clause

-- | Not include HalfRelmap
TAssert :: [SourceLine] -> Bool -> String -> [TokenTree] -> Clause

-- | Here data
CJudge :: [SourceLine] -> Bool -> String -> [Token] -> Clause

-- | Unknown clause
CUnknown :: [SourceLine] -> Clause

-- | Construct <a>Clause</a> list from <a>Token</a> list. This is a first
--   step of constructing <a>Section</a>.
consClause :: RelmapHalfCons -> [Token] -> [Clause]

-- | Second step of constructing <a>Section</a>.
consSection :: StringValue v => RelmapWholeCons v -> [Clause] -> AbortOr (Section v)
instance Typeable Clause
instance Show Clause
instance Data Clause

module Koshucode.Baala.Base.Struct.Half.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapHalfCons -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *

module Koshucode.Baala.Base.Struct.SectionIO
sectionRead :: StringValue v => Section v -> String -> AbortOr (Section v)

-- | Read section from file.
sectionFile :: StringValue v => Section v -> FilePath -> IO (AbortOr (Section v))

-- | Convert input judges into output judges by editing section. This
--   function calls <tt>runAssert</tt> for list of assertions in section,
--   and <tt>runAssert</tt> calls <a>runRelmap</a> for relmap in assertion.
runSectionJudges :: Value v => Section v -> [Judge v] -> AbortOr [Judge v]

-- | Convert input data into output data by editing section.
runSectionString :: Value v => Section v -> String -> AbortOr String

-- | Run editing section.
runSectionIO :: Value v => Section v -> IO ()


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
--   
--   Dependencies of significant data types.
--   
--   <ul>
--   <li><a>Section</a> uses <a>Section</a>, <a>Assert</a>, <a>Relmap</a>,
--   <a>Judge</a> and <a>ConsRelmap</a>.</li>
--   <li><a>Assert</a> uses <a>Relmap</a>.</li>
--   <li><a>Relmap</a> uses <a>Relmap</a> and <a>Rel</a>.</li>
--   <li><a>ConsRelmap</a> uses <tt>ConsHalfRelmap</tt> and
--   <a>RelmapFullCons</a>.</li>
--   <li><tt>ConsHalfRelmap</tt> uses <a>HalfRelmap</a> and
--   <a>TokenTree</a>.</li>
--   <li><a>RelmapFullCons</a> uses <a>Relmap</a> and
--   <a>TokenTree</a>.</li>
--   <li><a>Clause</a> uses <a>HalfRelmap</a>, <a>Clause</a>, and
--   <a>Token</a>.</li>
--   <li><a>HalfRelmap</a> uses <a>HalfRelmap</a> and
--   <a>TokenTree</a>.</li>
--   </ul>
module Koshucode.Baala.Base.Struct


-- | Kit for implementing relmaps.
module Koshucode.Baala.Base.Kit
type Livmap a = [a] -> [a]
type Livmap2 a = forall a. [a] -> [a]

module Koshucode.Baala.Base
