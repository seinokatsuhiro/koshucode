-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational data
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.28.0.0

module Koshucode.Baala.Base.Syntax.HashWord
hashWordTable :: [(String, String)]
hashWord :: String -> Maybe String
hashWordInvert :: String -> Maybe String
hashSplit :: String -> [String]


-- | General utilities
module Koshucode.Baala.Base.Prelude.Utility
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
cons1 :: a -> ([a], b) -> ([a], b)
mapmapFst :: (a -> c) -> [(a, b)] -> [(c, b)]
mapmapSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
maybePairs :: [a] -> Maybe [(a, a)]

-- | Entry in association list.
type Named a = (String, a)

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]
unionUp :: Eq a => [a] -> [a] -> [a]

-- | Singleton list
singleton :: a -> [a]
divideBy :: Eq a => a -> [a] -> [[a]]
divideByP :: Eq a => (a -> Bool) -> [a] -> [[a]]
rpad :: Int -> Map String

-- | Gather what is gotten by splitter.
gather :: ([a] -> (b, [a])) -> [a] -> [b]
gatherWith :: (c -> [a] -> (b, [a])) -> [c] -> [a] -> [b]

-- | Gather (key,value) to a Map key [value]
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]
type Map a = a -> a
type Listmap a = forall a. Map [a]

module Koshucode.Baala.Base.Prelude.Pretty
class Pretty a where docv = vcat . map doc doch = hsep . map doc
doc :: Pretty a => a -> Doc
docv, doch :: Pretty a => [a] -> Doc
docTag :: String -> Doc -> Doc
docParen :: Doc -> Doc
docBracket :: Doc -> Doc
docBrace :: Doc -> Doc
docAngle :: Doc -> Doc
docQuote :: Doc -> Doc
docComment :: Doc -> Doc
instance Pretty Doc


-- | Position in list.
module Koshucode.Baala.Base.Prelude.Position
ap :: ((Int -> v) -> [v] -> a) -> [v] -> a
like :: [Int] -> [Char] -> Bool

-- | Indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; "bdk" `sharedIndex` "abcdefg"
--   [1,3]
--   </pre>
sharedIndex :: Eq a => [a] -> [a] -> [Int]

-- | Pick indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; indexPick [1,3] "abcdefg"
--   "bd"
--   </pre>
indexPick :: [Int] -> [a] -> [a]

-- | Cut indexed elements
--   
--   <pre>
--   &gt;&gt;&gt; indexCut [1,3] "abcdefg"
--   "acefg"
--   </pre>
indexCut :: [Int] -> [a] -> [a]

module Koshucode.Baala.Base.Prelude


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Base.Data.Judge

-- | Judgement on type <tt>v</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, sign of relation, and argument. <a>Bool</a> value of logical
--   quality corresponds to affirmed or denied judge. <a>String</a> value
--   of sign represents certain sentence pattern that gives intepretation
--   of data. Sentence pattern has placeholders filled by (<a>String</a>,
--   <tt>v</tt>) values of argument.
data Judge v
Judge :: Bool -> Relsign -> (Relarg v) -> Judge v

-- | Sign of relation, or relation name.
type Relsign = String

-- | List of terms.
type Relarg v = [Named v]
putJudges :: (Ord v, Pretty v) => [Judge v] -> IO ()
hPutJudges :: (Ord v, Pretty v) => Handle -> [Judge v] -> IO ()

-- | Sort terms in alphabetical order.
abcJudge :: Ord v => Judge v -> Judge v

-- | Affirm judge, i.e., change logical quality to <a>True</a>.
affirmJudge :: Map (Judge v)

-- | Deny judge, i.e., change logical quality to <a>False</a>.
denyJudge :: Map (Judge v)
isAffirmed :: Judge t -> Bool
isDenied :: Judge t -> Bool
instance Show v => Show (Judge v)
instance Eq v => Eq (Judge v)
instance Ord v => Ord (Judge v)
instance (Ord v, Pretty v) => Pretty (Judge v)
instance Functor Judge


-- | Terms in heading of relation
module Koshucode.Baala.Base.Data.Relterm

-- | Term in heading of relation
data Relterm
Term :: String -> Relterm
Nest :: String -> [Relterm] -> Relterm
termLook :: [[String]] -> [Relterm] -> [[Int]]

-- | Term path to term position
termLook1 :: [String] -> [Relterm] -> [Int]
instance Show Relterm
instance Eq Relterm
instance Ord Relterm
instance Pretty Relterm
instance Name Relterm


-- | Heading of relations
module Koshucode.Baala.Base.Data.Relhead

-- | Heading of relation as a list of terms
data Relhead
Relhead :: [Relterm] -> Relhead
headTerms :: Relhead -> [Relterm]

-- | Term position
data TermPos

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Make head from term names
headFrom :: [String] -> Relhead

-- | Number of terms
headDegree :: Relhead -> Int

-- | List of term names
headNames :: Relhead -> [String]

-- | Reconstruct head
rehead :: ([String] -> [String]) -> Relhead -> Relhead

-- | Positions of given names in a head
headPoss :: Relhead -> [[String]] -> [TermPos]

-- | Positions of given (sub)head in a head
headPosh :: Relhead -> Relhead -> [TermPos]

-- | Indicies
posPoss :: [TermPos] -> [Int]

-- | Pick values
possPick :: [TermPos] -> [v] -> [v]

-- | Pick an inner part.
possInner :: [TermPos] -> [[String]]

-- | Pick an outer part.
possOuter :: [TermPos] -> [[String]]
instance Show Relhead
instance Eq Relhead
instance Ord Relhead
instance Show TermPos
instance Eq TermPos
instance Ord TermPos
instance Name TermPos
instance Pretty Relhead
instance Monoid Relhead


-- | Type for relations
module Koshucode.Baala.Base.Data.Rel

-- | Relations on type v. Heading of relation and body of relation as a
--   list of tuples.
data Rel v
Rel :: Relhead -> (Relbody v) -> Rel v

-- | List of positional args
type Relbody v = [[v]]

-- | Relational constant that has no terms and no tuples
reldum :: Rel v

-- | Relational constant that has no terms and the empty tuple
reldee :: Rel v
instance Show v => Show (Rel v)
instance Eq v => Eq (Rel v)
instance Ord v => Ord (Rel v)
instance Pretty v => Pretty (Rel v)


-- | Tokens in Koshucode
module Koshucode.Baala.Base.Syntax.Token

-- | Token number.
type TNumber = Int
data Token

-- | Word. <tt>Int</tt> represents quotation level, e.g., 0 for non-quoted,
--   1 for single-quoted, 2 for double-quoted.
TWord :: TNumber -> Int -> String -> Token

-- | Term name
TTerm :: TNumber -> [String] -> Token

-- | Open paren
TOpen :: TNumber -> String -> Token

-- | Close paren
TClose :: TNumber -> String -> Token

-- | <i>N</i> space characters
TSpace :: TNumber -> Int -> Token

-- | Comment text
TComment :: TNumber -> String -> Token

-- | Test the token is blank, i.e., <a>TComment</a> or <a>TSpace</a>.
isBlankToken :: Token -> Bool

-- | Test the token is a term, i.e., <a>TTerm</a>.
isTermToken :: Token -> Bool
isOpenTokenOf :: String -> Token -> Bool
isCloseTokenOf :: String -> Token -> Bool

-- | Text of token type, one of <tt>"Word"</tt>, <tt>"Term"</tt>,
--   <tt>"Open"</tt>, <tt>"Close"</tt>, <tt>"Space"</tt>, or
--   <tt>"Comment"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; tokenTypeText $ TWord 1 0 "flower"
--   "Word"
--   </pre>
tokenTypeText :: Token -> String
tokenContent :: Token -> String
tokenNumber :: Token -> TNumber

-- | Remove blank tokens.
sweepToken :: Map [Token]

-- | Skip leading blank tokens.
sweepLeft :: Map [Token]
instance Typeable Token
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance Name Token


-- | Tokenizer of koshucode.
module Koshucode.Baala.Base.Syntax.Tokenizer

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: String -> [Token]

-- | Convert back a token list to a source string.
untokens :: [Token] -> String
untoken :: Token -> String
divideByToken :: String -> [Token] -> [[Token]]
data SourceLine
SourceLine :: Int -> String -> [Token] -> SourceLine

-- | Line number, from 1.
sourceLineNumber :: SourceLine -> Int

-- | Line content without newline.
sourceLineContent :: SourceLine -> String

-- | Tokens from line.
sourceLineTokens :: SourceLine -> [Token]

-- | Split source text into <a>SourceLine</a> list.
--   
--   <ol>
--   <li>Split source code into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>)</li>
--   <li>Numbering line numbers. Internally, this is represented as a list
--   of pairs (<i>line#</i>, <i>content</i>).</li>
--   <li>Tokenize each lines. This is represented as a list of
--   <a>SourceLine</a> <i>line#</i> <i>content</i> <i>tokens</i>.</li>
--   </ol>
sourceLines :: String -> [SourceLine]
instance Typeable SourceLine
instance Show SourceLine
instance Eq SourceLine
instance Ord SourceLine
instance Data SourceLine
instance Pretty SourceLine

module Koshucode.Baala.Base.Syntax.Tree

-- | Tree of leaf and branch
data Tree a

-- | Leaf. Terminal of tree.
TreeL :: a -> Tree a

-- | Branch. Paren-type and subtrees.
TreeB :: Int -> [Tree a] -> Tree a

-- | Convert a list of elements to a single tree.
tree :: Show a => ParenType a -> [a] -> Tree a

-- | Convert a list of elements to trees.
trees :: Show a => ParenType a -> [a] -> [Tree a]

-- | Convert tree to list of tokens.
untree :: TypeParen a -> Tree a -> [a]

-- | Convert tree to list of tokens.
untrees :: TypeParen a -> [Tree a] -> [a]

-- | Simplify tree by removing double parens, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble $ TreeB 0 [Tree 0 [TreeL "A", TreeL "B"]]
--   Tree 0 [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Map (Tree a)

-- | Get a paren type.
type ParenType a = a -> Int

-- | Get parens from a type.
type TypeParen a = Int -> (a, a)

-- | Make <a>ParenType</a> and <a>TypeParen</a> functions from a
--   type-open-close table.
--   
--   Make paren/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (pt, tp) = parenTable [(1,'(',')'), (2,'[',']')]
--   </pre>
--   
--   Get paren types for each chars. Types of open parens are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0,0,1,0,0,2,0,0,-2,-1,0]
--   </pre>
--   
--   Get an open-close pair of parens from its type.
--   
--   <pre>
--   &gt;&gt;&gt; tp 2
--   ('[', ']')
--   </pre>
parenTable :: Eq a => [(Int, a -> Bool, a -> Bool)] -> ParenType a
instance Typeable1 Tree
instance Show a => Show (Tree a)
instance Eq a => Eq (Tree a)
instance Ord a => Ord (Tree a)
instance Data a => Data (Tree a)
instance Functor Tree


-- | Convert infixed-operator trees into prefixed-operator trees
module Koshucode.Baala.Base.Syntax.Binary

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type BinaryHeight = Either Int Int

-- | Split branches in a given tree at infixed binary operators
binaryTree :: Show a => (a -> BinaryHeight) -> Tree a -> Tree a

-- | Make the height function from a height table of operators.
heightTable :: Ord a => [(BinaryHeight, [a])] -> (a -> BinaryHeight)
heightTableUnbox :: Ord a => (b -> a) -> [(BinaryHeight, [a])] -> (b -> BinaryHeight)


-- | Parened tree of tokens
module Koshucode.Baala.Base.Syntax.TokenTree

-- | Tree of tokens.
type TokenTree = Tree Token

-- | Parse tokens into parened trees. Blank tokens and comments are
--   excluded.
--   
--   There are four types of parens -- 1, 2, 3, or 4. Paren type is in
--   <a>TreeB</a> <i>type</i> <i>subtrees</i>.
--   
--   <ol>
--   <li>Round parens <tt>( .. )</tt> for grouping.</li>
--   <li>Squared brackets <tt>[ .. ]</tt> for list.</li>
--   <li>Curely braces <tt>{ .. }</tt> for termset.</li>
--   <li>Curely-bar braces <tt>{| .. |}</tt> for relation.</li>
--   </ol>
tokenTrees :: [Token] -> [TokenTree]
singleTree :: [TokenTree] -> TokenTree
divideByTokenTree :: String -> [TokenTree] -> [[TokenTree]]


-- | Syntactic functions
module Koshucode.Baala.Base.Syntax


-- | Abort utility
module Koshucode.Baala.Base.Abort.Utility

-- | Class that represents abort reason.
class AbortReasonClass a where abortSub _ = empty
abortSymbol :: AbortReasonClass a => a -> String
abortTitle :: AbortReasonClass a => a -> String
abortMain :: AbortReasonClass a => a -> Doc
abortSub :: AbortReasonClass a => a -> Doc

-- | Abort reason and source code information.
type AbortType a = (a, [SourceLine])

-- | Either of (1) right result or (2) abort information.
type AbortOrType a b = Either (AbortType a) b

-- | Stop program execution abnormally.
abort :: AbortReasonClass a => AbortType a -> IO ()
abortIO :: AbortReasonClass a => (b -> IO ()) -> AbortOrType a b -> IO ()
addAbort :: AbortReasonClass a => AbortType a -> Map (AbortOrType a b)

-- | Stop on error ''bug in koshucode''
bug :: a


-- | Abort symbol
module Koshucode.Baala.Base.Abort.Reason

-- | Either of (1) right result, or (2) abort reason (without source code
--   information).
type AbOr b = Either AbortReason b

-- | Abortable mapping.
type AbMap b = b -> AbOr b

-- | Abort reason and source information.
type Abort = AbortType AbortReason

-- | Either of (1) right result, or (2) abort reason with source.
type AbortOr b = AbortOrType AbortReason b

-- | Lookup association list. This function may abort on AbortLookup.
(<!!>) :: [Named a] -> String -> AbortOr a

-- | Abort reasons
data AbortReason
AbortLookup :: String -> AbortReason
AbortMalformedOperand :: String -> AbortReason
AbortMissingTermName :: String -> AbortReason
AbortNotNumber :: String -> AbortReason
AbortOddRelation :: AbortReason
AbortReqBoolean :: String -> AbortReason
AbortRequireFlatname :: String -> AbortReason
AbortUndefined :: String -> AbortReason
AbortUnkCop :: String -> AbortReason
AbortUnknownClause :: AbortReason
AbortUnknownContent :: String -> AbortReason
AbortUnknownRelmap :: String -> AbortReason
AbortUnknownSymbol :: String -> AbortReason
AbortUnmatchArity :: AbortReason
AbortUnmatchType :: AbortReason
AbortUsage :: String -> [String] -> AbortReason
instance Show AbortReason
instance Eq AbortReason
instance Ord AbortReason
instance AbortReasonClass AbortReason
instance Name AbortReason

module Koshucode.Baala.Base.Relmap.HalfRelmap

-- | Intermediate data that represents use of relational operator.
--   
--   <a>HalfRelmap</a> is constructed from list of <a>TokenTree</a>, and
--   (full) <tt>Relmap</tt> is constructed from <a>HalfRelmap</a>.
data HalfRelmap
HalfRelmap :: [String] -> [SourceLine] -> String -> [Named [TokenTree]] -> [HalfRelmap] -> HalfRelmap

-- | Usages description
halfUsage :: HalfRelmap -> [String]

-- | Source information
halfLines :: HalfRelmap -> [SourceLine]

-- | Operator name of relmap operation
halfOperator :: HalfRelmap -> String

-- | Operand of relmap operation
halfOperand :: HalfRelmap -> [Named [TokenTree]]

-- | Subrelmaps in the operand
halfSubmap :: HalfRelmap -> [HalfRelmap]
instance Typeable HalfRelmap
instance Show HalfRelmap
instance Data HalfRelmap
instance Pretty HalfRelmap

module Koshucode.Baala.Base.Section.Clausify
data ClauseSource
ClauseSource :: [Token] -> [SourceLine] -> ClauseSource

-- | Source tokens of clause
clauseTokens :: ClauseSource -> [Token]

-- | Source lines of clause
clauseLines :: ClauseSource -> [SourceLine]

-- | Convert token list into list of token clauses
clausify :: [SourceLine] -> [ClauseSource]

-- | Split operand into named group. Non quoted words beginning with
--   hyphen, e.g., <tt>-x</tt>, are name of group.
--   
--   <pre>
--   &gt;&gt;&gt; operandGroup $ tokenTrees $ tokens "a b -x c 'd' -y e"
--   [("",   [TreeL (Word 0 "a"), TreeL (Word 0 "b")]),
--    ("-x", [TreeL (Word 0 "c"), TreeL (Word 1 "d")]),
--    ("-y", [TreeL (Word 0 "e")])]
--   </pre>
operandGroup :: [TokenTree] -> [Named [TokenTree]]
instance Typeable ClauseSource
instance Show ClauseSource
instance Data ClauseSource


-- | Data on value type <tt>v</tt>
module Koshucode.Baala.Base.Data

module Koshucode.Baala.Base.Content.Class
class PrimContent c
class (Ord c, Pretty c, CBool c, CString c, CInt c, CList c, CNil c, CSet c, CTermset c, CRel c) => CContent c where joinContent = foldr appendContent nil
appendContent :: CContent c => c -> c -> c
joinContent :: CContent c => [c] -> c
class PrimContent c => CBool c
putBool :: CBool c => Bool -> c
getBool :: CBool c => c -> Bool
isBool :: CBool c => c -> Bool
class PrimContent c => CInt c
putInt :: CInt c => Int -> c
getInt :: CInt c => c -> Int
isInt :: CInt c => c -> Bool
class PrimContent c => CString c
putString :: CString c => String -> c
getString :: CString c => c -> String
isString :: CString c => c -> Bool
class PrimContent c => CList c
putList :: CList c => [c] -> c
getList :: CList c => c -> [c]
isList :: CList c => c -> Bool

-- | Types that can be nil
class PrimContent c => CNil c
nil :: CNil c => c
isNil :: CNil c => c -> Bool
class PrimContent c => CSet c
putSet :: CSet c => [c] -> c
getSet :: CSet c => c -> [c]
isSet :: CSet c => c -> Bool
class PrimContent c => CTermset c
putTermset :: CTermset c => [Named c] -> c
getTermset :: CTermset c => c -> [Named c]
isTermset :: CTermset c => c -> Bool
class PrimContent c => CRel c
putRel :: CRel c => Rel c -> c
getRel :: CRel c => c -> Rel c
isRel :: CRel c => c -> Bool


-- | Abort symbols
module Koshucode.Baala.Base.Abort


-- | Literalizer: Make literal contents from token tree.
module Koshucode.Baala.Base.Content.Literalize

-- | Make <tt>a</tt> from <tt>b</tt>.
type LiteralizeFrom b a = b -> AbOr a

-- | Make <tt>a</tt> from list of token trees.
type LiteralizeTrees a = LiteralizeFrom [TokenTree] a

-- | Make <tt>a</tt> from a token tree.
type LiteralizeTree a = LiteralizeFrom TokenTree a

-- | Make <tt>a</tt> from a string.
type LiteralizeString a = LiteralizeFrom String a

-- | Transform <a>TokenTree</a> into internal form of term content.
litContent :: CContent v => LiteralizeTree v

-- | Construct list of term contents.
litList :: CContent v => LiteralizeTrees [v]

-- | Construct judge from token trees. Judges itself are not content type.
--   It can be only used in the top-level of sections.
litJudge :: CContent v => Bool -> Relsign -> LiteralizeTrees (Judge v)


-- | Term calcutation.
module Koshucode.Baala.Base.Content.Run

-- | Term content operator.
data Cop c
CopLit :: String -> (CopLitF c) -> Cop c
CopLazy :: String -> (CopLazyF c) -> Cop c
CopEager :: String -> (CopEagerF c) -> Cop c
type CopLitF c = [TokenTree] -> AbOr c
type CopLazyF c = [ContExp c] -> AbOr c
type CopEagerF c = [c] -> AbOr c

-- | Type for finding term content operator.
type FindCop c = String -> Maybe (Cop c)
namedLit :: String -> CopLitF c -> (String, Cop c)
namedEager :: String -> CopEagerF c -> (String, Cop c)
namedLazy :: String -> CopLazyF c -> (String, Cop c)
data ContExp c

-- | Literal content.
ContLit :: c -> ContExp c

-- | Operator invocation.
ContApp :: (Cop c) -> [ContExp c] -> ContExp c

-- | Term reference. Term names <tt>[String]</tt> and positions
--   <tt>[Int]</tt>. <a>formContent</a> makes positions empty,
--   <a>posContent</a> fills it.
ContTerm :: [String] -> [Int] -> ContExp c

-- | Construct content expression.
formContent :: CContent c => FindCop c -> [SourceLine] -> TokenTree -> AbortOr (ContExp c)
type PosContent c = Relhead -> ContExp c

-- | Put term positions for actural heading.
posContent :: ContExp c -> PosContent c

-- | Calculate content expression.
runContent :: (CList c, CRel c) => ContExp c -> [c] -> AbOr c
instance Show c => Show (ContExp c)
instance Show (Cop c)


-- | Content
module Koshucode.Baala.Base.Content


-- | Dataset as a set of judges.
--   
--   Dataset is like a bridge of judges and relations. We can get a
--   relation from a dataset, that dataset is build from judges.
module Koshucode.Baala.Base.Relmap.Dataset

-- | Dataset is a set of judges.
data Dataset v

-- | Dataset that has no judges
emptyDataset :: Dataset v

-- | Gather judges into a dataset
dataset :: [Judge v] -> Dataset v

-- | Add judges to dataset.
addJudges :: [Judge v] -> Dataset v -> Dataset v

-- | Select relation from dataset. If a giving term is not in judges,
--   <a>CNil</a> sign is used.
selectRelation :: (Ord v, CNil v) => Dataset v -> Relsign -> [String] -> Rel v


-- | Data structures for relation-to-relation mappings
module Koshucode.Baala.Base.Relmap.Relmap

-- | Relation-to-relation mapping. A <a>Relmap</a> is correspond to a use
--   of relational operator.
data Relmap v

-- | Retrieve a relation from a dataset
RelmapSource :: HalfRelmap -> String -> [String] -> Relmap v

-- | Constant relation
RelmapConst :: HalfRelmap -> String -> (Rel v) -> Relmap v

-- | Equavalent relmap
RelmapAlias :: HalfRelmap -> (Relmap v) -> Relmap v

-- | Relmap that maps relations to a relation
RelmapCalc :: HalfRelmap -> String -> (RelmapSub v) -> [Relmap v] -> Relmap v

-- | Connect two relmaps
RelmapAppend :: (Relmap v) -> (Relmap v) -> Relmap v

-- | Relmap reference
RelmapName :: HalfRelmap -> String -> Relmap v

-- | Function of relmap.
type RelmapSub v = [Rel v] -> Rel v -> AbOr (Rel v)

-- | List of <a>RelmapSource</a>
relmapSourceList :: Relmap v -> [Relmap v]

-- | List of name in <a>RelmapName</a>
relmapNameList :: Relmap v -> [String]

-- | Expand <a>RelmapAppend</a> to list of <a>Relmap</a>
relmapAppendList :: Relmap v -> [Relmap v]

-- | Link relmaps by its name.
relmapLinker :: [Named (Relmap v)] -> Relmap v -> Relmap v
instance Pretty (Relmap v)
instance Name (Relmap v)
instance Monoid (Relmap v)
instance Show (Relmap v)


-- | Data structure for mapping relation to judges
module Koshucode.Baala.Base.Relmap.Assert

-- | Assertion of affirming or denying relation. It consists of logical
--   quality, relsign, and relmap.
--   
--   See also <a>Judge</a>
data Assert v
Assert :: Bool -> Relsign -> Relmap v -> Assert v

-- | Logical quality
assertQuality :: Assert v -> Bool

-- | Sign of relation
assertRelsign :: Assert v -> Relsign

-- | Relmap
assertRelmap :: Assert v -> Relmap v

-- | Apply function to relamp in assert.
assertMap :: Map (Relmap v) -> Map (Assert v)

-- | Make affirmed assertion.
affirm :: Relsign -> Relmap v -> Assert v

-- | Make denied assertion.
deny :: Relsign -> Relmap v -> Assert v
instance Show (Assert v)
instance Pretty (Assert v)

module Koshucode.Baala.Base.Relmap.Implement

-- | Implementation of relmap operator. It consists of (1) operator name,
--   (2) operand parser, (3) constructor of operator, and (4) usage of
--   operator.
data OpImplement v
OpImplement :: String -> OpParser -> (Relop v) -> [String] -> OpImplement v

-- | Parser for operand of relational operator. This parsers docompose
--   operand trees, and give a name to suboperand.
type OpParser = [TokenTree] -> [Named [TokenTree]]
type OpParser' = [Named [TokenTree]] -> [Named [TokenTree]]

-- | Constructor of relational operator <a>Relmap</a>. <a>Relmap</a> is
--   constructed from <a>HalfRelmap</a> and subrelmaps in it.
type Relop v = OpUse v -> AbortOr (Relmap v)

-- | Use of operator
data OpUse v
OpUse :: HalfRelmap -> [Relmap v] -> OpUse v

-- | Syntactic data of operator use
opHalf :: OpUse v -> HalfRelmap

-- | Subrelmaps
opSubmap :: OpUse v -> [Relmap v]

-- | Retrieve relation from dataset.
relmapSource :: OpUse v -> String -> [String] -> (Relmap v)

-- | Constant relmap.
relmapConst :: OpUse v -> String -> Rel v -> Relmap v

-- | Alias relmap.
relmapAlias :: OpUse v -> Relmap v -> Relmap v

-- | Make a non-confluent relmap.
relmapCalc :: OpUse v -> String -> RelmapSub v -> Relmap v

-- | Make a confluent relmap.
relmapConfl :: OpUse v -> String -> RelmapSub v -> [Relmap v] -> Relmap v
instance Show (OpUse v)


-- | <a>Relmap</a> construction.
module Koshucode.Baala.Base.Relmap.Construct

-- | Make half and full relmap constructors.
relmapCons :: [OpImplement v] -> (RelmapCons v)

-- | Half and full relmap constructor
data RelmapCons v
RelmapCons :: RelmapHalfCons -> RelmapFullCons v -> RelmapCons v
consHalf :: RelmapCons v -> RelmapHalfCons
consFull :: RelmapCons v -> RelmapFullCons v

-- | First step of constructing relmap, make <a>HalfRelmap</a> from use of
--   relational operator.
type RelmapHalfCons = [SourceLine] -> [TokenTree] -> HalfRelmap

-- | Second step of constructing relmap, make <a>Relmap</a> from contents
--   of <a>HalfRelmap</a>.
type RelmapFullCons v = HalfRelmap -> AbortOr (Relmap v)
instance Show (RelmapCons v)


-- | Running relational calculation.
module Koshucode.Baala.Base.Relmap.Run

-- | Calculate assertion list.
runAssertJudges :: (Ord v, CNil v) => [Assert v] -> [Judge v] -> AbortOr [Judge v]

-- | Calculate assertion list.
runAssertDataset :: (Ord v, CNil v) => [Assert v] -> Dataset v -> AbortOr [Judge v]


-- | Relation-to-relation mapping.
module Koshucode.Baala.Base.Relmap


-- | Data structure for relational calculations. There are three types of
--   section: (1) <i>editing sections</i> that output judges and read other
--   sections, (2) <i>library sections</i> that make relmaps reusable, (3)
--   <i>data sections</i> that provide data.
module Koshucode.Baala.Base.Section.Section
data Section v
Section :: Maybe String -> [Section v] -> [String] -> [Assert v] -> [Named (Relmap v)] -> [Judge v] -> RelmapCons v -> Section v

-- | Section name
sectionName :: Section v -> Maybe String

-- | Importing section
sectionImport :: Section v -> [Section v]

-- | Exporting relmap names
sectionExport :: Section v -> [String]

-- | Assertions of relmaps
sectionAssert :: Section v -> [Assert v]

-- | Relmaps and its name
sectionRelmap :: Section v -> [Named (Relmap v)]

-- | Here data
sectionJudge :: Section v -> [Judge v]

-- | Readers and writers for this section
sectionCons :: Section v -> RelmapCons v

-- | Select assertions like <a>sectionAssert</a>. It returns relmap-liked
--   assertions. We can run these assertions using <a>runAssertJudges</a>.
sectionLinkedAssert :: Section v -> [Assert v]

-- | Section that has no contents.
makeEmptySection :: RelmapCons v -> Section v

-- | Section that has no contents.
emptySection :: Section v

-- | Section that has only here data.
dataSection :: [Judge v] -> Section v
instance Show v => Show (Section v)
instance (Ord v, Pretty v) => Pretty (Section v)

module Koshucode.Baala.Base.Section.SectionUnion
sectionUnion :: Section v -> Section v -> Section v
sectionUse :: Section v -> Section v -> Section v
instance Monoid (Section v)


-- | Intermidiate structure between <a>String</a> and <a>Section</a>.
module Koshucode.Baala.Base.Section.Clause
data Clause

-- | Section name
CSection :: ClauseSource -> (Maybe String) -> Clause

-- | Importing section name
CImport :: ClauseSource -> [Token] -> (Maybe Clause) -> Clause

-- | Exporting relmap name
CExport :: ClauseSource -> String -> Clause

-- | Relmap and its name
CRelmap :: ClauseSource -> String -> HalfRelmap -> Clause

-- | Not include HalfRelmap
TRelmap :: ClauseSource -> String -> [TokenTree] -> Clause

-- | Assertions of relmaps
CAssert :: ClauseSource -> Bool -> String -> HalfRelmap -> Clause

-- | Not include HalfRelmap
TAssert :: ClauseSource -> Bool -> String -> [TokenTree] -> Clause

-- | Judge
CJudge :: ClauseSource -> Bool -> String -> [Token] -> Clause

-- | Caluse comment
CComment :: ClauseSource -> Clause

-- | Unknown clause
CUnknown :: ClauseSource -> Clause
clauseTypeText :: Clause -> String
clauseSource :: Clause -> ClauseSource

-- | Convert token list into clause list. Result clause list does not
--   contain <a>CRelmap</a> and <a>CAssert</a>. Instead of them,
--   <a>TRelmap</a> and <a>TAssert</a> are contained. This function does
--   not depend on <a>RelmapHalfCons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; consPreclause $ tokens "a : source A /x /y"
--   [TRelmap [SourceLine 1 "a : source A /x /y"]
--            "a" [TreeL (Word 0 "source"),
--                 TreeL (Word 0 "A"),
--                 TreeL (TermN ["/x"]),
--                 TreeL (TermN ["/y"])]]
--   </pre>
consPreclause :: [SourceLine] -> [Clause]

-- | Construct <a>Clause</a> list from <a>Token</a> list. This is a first
--   step of constructing <a>Section</a>.
consClause :: RelmapHalfCons -> [SourceLine] -> [Clause]

-- | Second step of constructing <a>Section</a>.
consSection :: CContent v => RelmapFullCons v -> [Clause] -> AbortOr (Section v)
instance Typeable Clause
instance Show Clause
instance Data Clause

module Koshucode.Baala.Base.Section.Quoter

-- | Make quasiquoter for <tt>[koshu| ... |]</tt>.
koshuQuoter :: RelmapHalfCons -> ExpQ -> QuasiQuoter
data QuasiQuoter :: *

module Koshucode.Baala.Base.Section.SectionIO

-- | Read section from text.
sectionRead :: CContent v => Section v -> String -> AbortOr (Section v)

-- | Read section from file.
sectionFile :: CContent v => Section v -> FilePath -> IO (AbortOr (Section v))

-- | Run section. Output section has judges calculated from assertions in
--   input section.
runSection :: CContent v => Section v -> AbortOr (Section v)

-- | Run section and output judges.
runSectionIO :: CContent v => Section v -> IO ()
hRunSectionIO :: CContent v => Handle -> Section v -> IO ()


-- | Runtime structure for calculations written in Koshucode.
--   <a>Section</a> is bundle of calculation stuff.
module Koshucode.Baala.Base.Section

module Koshucode.Baala.Base
