-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.39.0.0

module Koshucode.Baala.Base.Prelude.Unicode
data GeneralCategoryGroup

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: GeneralCategoryGroup

-- | Mn Mc Me
UnicodeMark :: GeneralCategoryGroup

-- | Nd Nl No
UnicodeNumber :: GeneralCategoryGroup

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: GeneralCategoryGroup

-- | Sm Sc Sk So
UnicodeSymbol :: GeneralCategoryGroup

-- | Zs Zl Zp
UnicodeSeperator :: GeneralCategoryGroup

-- | Cc Cf Cs Co Cn
UnicodeOther :: GeneralCategoryGroup
generalCategoryLetter :: GeneralCategoryGroup -> Char
generalCategoryGroup :: Char -> GeneralCategoryGroup
instance Show GeneralCategoryGroup
instance Eq GeneralCategoryGroup
instance Ord GeneralCategoryGroup
instance Bounded GeneralCategoryGroup

module Koshucode.Baala.Base.Prelude.Pretty

-- | Type that has a pretty printer.
class Pretty a where docv = vcat . map doc doch = hsep . map doc
doc :: Pretty a => a -> Doc
docv :: Pretty a => [a] -> Doc
doch :: Pretty a => [a] -> Doc

-- | Colon-seperated document.
--   
--   <pre>
--   &gt;&gt;&gt; docBracket $ docColon [True, False]
--   [ #true : #false ]  
--   </pre>
docColon :: Pretty a => [a] -> Doc

-- | Wrap in open and close brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWrap "(" ")" "abc"
--   (abc)  
--   </pre>
docWrap :: Pretty a => String -> String -> a -> Doc

-- | Wrap in open and close brackets. Put spaces between content and
--   brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWraps "(" ")" "abc"
--   ( abc )  
--   </pre>
docWraps :: Pretty a => String -> String -> a -> Doc

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
docEmpty :: Doc
docHang :: Doc -> Int -> Doc -> Doc
docZero :: String -> Doc
instance Pretty a => Pretty (String, a)
instance Pretty Bool
instance Pretty String
instance Pretty Int
instance Pretty Doc


-- | Lines.
module Koshucode.Baala.Base.Prelude.Line

-- | Line number.
type LineNumber = Int

-- | Line number and its content.
linesCrlfNumbered :: String -> [(LineNumber, String)]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
linesCrlf :: String -> [String]
putLines :: [String] -> IO ()


-- | General utilities
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)
type Map a = a -> a
type Pred a = a -> Bool
data YesNo a
Yes :: a -> YesNo a
No :: a -> YesNo a
instance Show a => Show (YesNo a)
instance Eq a => Eq (YesNo a)
instance Ord a => Ord (YesNo a)


-- | General utilities
module Koshucode.Baala.Base.Prelude.Utility
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
cons1 :: a -> ([a], b) -> ([a], b)
mapmapFst :: (a -> c) -> [(a, b)] -> [(c, b)]
mapmapSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
maybePairs :: [a] -> Maybe [(a, a)]

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Union list to base list.
--   
--   <pre>
--   &gt;&gt;&gt; unionUp "cde" "abc"
--   "deabc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; List.union "cde" "abc"
--   "cdeab"  
--   </pre>
unionUp :: Eq a => [a] -> [a] -> [a]

-- | Make singleton list.
singleton :: a -> [a]
isSingleton :: [a] -> Bool

-- | Split list by predicate. If list contains an element that satisfies
--   the predicate, <tt>(<i>before-list</i>, <i>the-element</i>,
--   <i>after-list</i>)</tt> is returned. Otherwise, original list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "b c"
--   Left "b c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "a | b | c"
--   Right ("a ", '|', " b | c")  
--   </pre>
splitBy :: (a -> Bool) -> [a] -> Either [a] ([a], a, [a])

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divide '|' "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]  
--   </pre>
divide :: Eq a => a -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divideBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]  
--   </pre>
divideBy :: (a -> Bool) -> [a] -> [[a]]

-- | Omit association that has given key.
--   
--   <pre>
--   &gt;&gt;&gt; assocOmit "b" [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]  
--   </pre>
assocOmit :: Eq k => k -> Map [(k, a)]

-- | Omit associations that have given keys.
assocOmitAll :: Eq k => [k] -> Map [(k, a)]

-- | Add spaces to right.
--   
--   <pre>
--   &gt;&gt;&gt; padRight 10 "abc"
--   "abc       "  
--   </pre>
padRight :: Int -> Map String

-- | Add spaces to left.
--   
--   <pre>
--   &gt;&gt;&gt; padLeft 10 "abc"
--   "       abc"  
--   </pre>
padLeft :: Int -> Map String

-- | Gather what is gotten by splitter.
gather :: ([a] -> (b, [a])) -> [a] -> [b]
gatherWith :: (c -> [a] -> (b, [a])) -> [c] -> [a] -> [b]

-- | Gather (<i>key</i>, <i>value</i>) to <a>Map</a> <i>key</i>
--   [<i>value</i>].
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b
lookupMap :: Ord k => k -> Map k a -> Maybe a


-- | Utilities for association lists.
module Koshucode.Baala.Base.Prelude.Assoc
data OnceMore a
Once :: a -> OnceMore a
More :: [a] -> OnceMore a
assocRename :: Eq k => k -> k -> Map [(k, a)]
assocPush :: Eq k => k -> a -> Map [(k, OnceMore a)]
assocGather :: Eq k => [(k, a)] -> [(k, OnceMore a)]
assocBy :: (a -> Maybe k) -> k -> [a] -> [(k, [a])]
assocOnce :: [(k, OnceMore a)] -> [(k, a)]
assocMore :: [(k, OnceMore a)] -> [(k, [a])]
assocExist :: Eq k => k -> [(k, a)] -> Bool
instance Show a => Show (OnceMore a)
instance Eq a => Eq (OnceMore a)
instance Ord a => Ord (OnceMore a)


-- | Arrangement of lists.
module Koshucode.Baala.Base.Prelude.Arrange
type Arrange a = [Int] -> Map [a]

-- | Indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; "bdk" `sharedIndex` "abcdefg"
--   [1,3]  
--   </pre>
sharedIndex :: Eq a => [a] -> [a] -> [Int]

-- | Pick indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; arrangePick [1,3] "abcdefg"
--   "bd"  
--   </pre>
arrangePick :: Arrange a

-- | Cut indexed elements
--   
--   <pre>
--   &gt;&gt;&gt; arrangeCut [1,3] "abcdefg"
--   "acefg"  
--   </pre>
arrangeCut :: [Int] -> Map [a]

-- | Move indexed elements to the front.
--   
--   <pre>
--   &gt;&gt;&gt; arrangeFore [1,3] "abcdefg"
--   "bdacefg"  
--   </pre>
arrangeFore :: [Int] -> Map [a]

module Koshucode.Baala.Base.Data.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec
emacsModeComment :: String
instance Show CommentSec
instance Eq CommentSec
instance Ord CommentSec
instance Show CommentDoc
instance Eq CommentDoc
instance Ord CommentDoc
instance Texts CommentSec
instance Texts CommentDoc

module Koshucode.Baala.Base.Prelude


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Base.Data.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of pattern, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement pattern represents certain sentence pattern
--   that gives intepretation of data. Sentence pattern has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c
Judge :: Bool -> JudgePattern -> [Named c] -> Judge c

-- | Name of judgement pattern.
type JudgePattern = String

-- | Sort terms in alphabetical order.
abcJudge :: Ord c => Map (Judge c)

-- | Construct affirmed judgement.
affirm :: JudgePattern -> [Named c] -> Judge c

-- | Construct denied judgement.
deny :: JudgePattern -> [Named c] -> Judge c

-- | Affirm judgement, i.e., change logical quality to <a>True</a>.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to <a>False</a>.
denyJudge :: Map (Judge c)

-- | Test that judgement is affirmd.
isAffirmed :: Judge c -> Bool

-- | Test that judgement is denied.
--   
--   <pre>
--   &gt;&gt;&gt; isDenied $ Judge True "A" []
--   False  
--   </pre>
isDenied :: Judge c -> Bool

-- | Print judges to <a>stdout</a>.
putJudges :: (Ord c, Pretty c) => [Judge c] -> IO ()

-- | Print judges.
hPutJudges :: (Ord c, Pretty c) => Handle -> [Judge c] -> IO ()

-- | Convert judgements to lines.
judgeLines :: (Ord c, Pretty c) => [Judge c] -> [String]
instance Show c => Show (Judge c)
instance (Ord c, Pretty c) => Pretty (Judge c)
instance Functor Judge
instance Ord c => Ord (Judge c)
instance Ord c => Eq (Judge c)


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <a>CodeLine</a> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <a>CodeLine</a>.
module Koshucode.Baala.Base.Syntax.CodeLine

-- | Tokens per line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
codeLineNumber :: CodeLine a -> LineNumber

-- | Line content without newline.
codeLineContent :: CodeLine a -> String

-- | Tokens in the line.
codeLineTokens :: CodeLine a -> [a]

-- | Type of function that splits a next token from string. Tokens can
--   includes <a>TokenNumber</a>.
type NextToken a = TokenNumber -> String -> (a, String)

-- | Token number, from 1.
type TokenNumber = Int

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><tt>LineNumber</tt><tt>,</tt>
--   <a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeLines :: NextToken a -> String -> [CodeLine a]
instance Typeable1 CodeLine
instance Show a => Show (CodeLine a)
instance Eq a => Eq (CodeLine a)
instance Ord a => Ord (CodeLine a)
instance Data a => Data (CodeLine a)
instance Pretty (CodeLine a)

module Koshucode.Baala.Base.Syntax.Tree

-- | Tree of leaf and branch.
data Tree a

-- | Leaf. Terminal of tree.
TreeL :: a -> Tree a

-- | Branch. Paren-type and subtrees.
TreeB :: ParenType -> [Tree a] -> Tree a

-- | Convert a list of elements to a single tree.
tree :: Show a => GetParenType a -> [a] -> Tree a

-- | Convert a list of elements to trees.
trees :: Show a => GetParenType a -> [a] -> [Tree a]
treeG :: [Tree a] -> Tree a
treeWrap :: [Tree a] -> Tree a

-- | Convert tree to list of tokens.
untree :: GetTypeParen a -> Tree a -> [a]

-- | Convert tree to list of tokens.
untrees :: GetTypeParen a -> [Tree a] -> [a]

-- | Simplify tree by removing double parens, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 [TreeB 0 [TreeL "A", TreeL "B"]]
--   TreeB 0 [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Pred ParenType -> Map (Tree a)
type ParenType = Int

-- | Get a paren type.
type GetParenType a = a -> ParenType

-- | Get parens from a type.
type GetTypeParen a = ParenType -> (a, a)

-- | Make <a>GetParenType</a> functions from a type-open-close table.
--   
--   Make paren/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let paren n [a, b] = (n, (== a), (== b))
--   
--   &gt;&gt;&gt; let pt = parenTable [ paren 1 "()", paren 2 "[]" ]
--   </pre>
--   
--   Get paren types for each chars. Types of open parens are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0, 0, 1, 0, 0, 2, 0, 0, -2, -1, 0]
--   </pre>
parenTable :: Eq a => [(ParenType, Pred a, Pred a)] -> GetParenType a
instance Typeable1 Paren
instance Typeable1 Tree
instance Show a => Show (Paren a)
instance Eq a => Eq (Paren a)
instance Ord a => Ord (Paren a)
instance Data a => Data (Paren a)
instance Show a => Show (Tree a)
instance Eq a => Eq (Tree a)
instance Ord a => Ord (Tree a)
instance Data a => Data (Tree a)
instance Functor Tree


-- | Convert infixed-operator trees into prefixed-operator trees
module Koshucode.Baala.Base.Syntax.Binary

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type BinaryHeight = Either Int Int

-- | Split branches in a given tree at infixed binary operators
binaryTree :: Show a => (a -> BinaryHeight) -> Tree a -> Tree a

-- | Make the height function from a height table of operators.
heightTable :: Ord a => [(BinaryHeight, [a])] -> (a -> BinaryHeight)
heightTableUnbox :: Ord a => (b -> a) -> [(BinaryHeight, [a])] -> (b -> BinaryHeight)

module Koshucode.Baala.Base.Syntax.Token
data Token

-- | Word. <a>Int</a> represents quotation level, e.g., 0 for non-quoted, 1
--   for single-quoted, 2 for double-quoted.
TWord :: TokenNumber -> Int -> String -> Token

-- | Abbreviated word
TShort :: TokenNumber -> String -> String -> Token

-- | Termname
TTerm :: TokenNumber -> [Termname] -> Token

-- | Open paren
TOpen :: TokenNumber -> String -> Token

-- | Close paren
TClose :: TokenNumber -> String -> Token

-- | <i>N</i> space characters
TSpace :: TokenNumber -> Int -> Token

-- | Comment text
TComment :: TokenNumber -> String -> Token

-- | Unknown text
TUnknown :: TokenNumber -> String -> Token

-- | Name of term, e.g., <tt>"/file"</tt> for the term <tt>/file</tt>.
type Termname = String

-- | Get the position of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TWord 25 0 "abc" in tokenNumber tok
--   25  
--   </pre>
tokenNumber :: Token -> TokenNumber

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TTerm 20 ["/r", "/x"] in tokenContent tok
--   "/r/x"  
--   </pre>
tokenContent :: Token -> String

-- | Text of token type, i.e., one of <tt>"Word"</tt>, <tt>"Term"</tt>,
--   <tt>"Open"</tt>, <tt>"Close"</tt>, <tt>"Space"</tt>,
--   <tt>"Comment"</tt>, or <tt>"Unknown"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; tokenTypeText $ TWord 25 0 "flower"
--   "Word"  
--   </pre>
tokenTypeText :: Token -> String

-- | Test the token is blank, i.e., <a>TComment</a> or <a>TSpace</a>.
isBlankToken :: Pred Token

-- | Check token is a <a>TOpen</a> of the specific paren.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "(" in isOpenTokenOf "(" tok
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "{" in isOpenTokenOf "(" tok
--   False 
--   </pre>
isOpenTokenOf :: String -> Pred Token

-- | Check token is a <a>TClose</a> of the specific paren.
isCloseTokenOf :: String -> Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]
instance Typeable Token
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance Pretty Token
instance Name Token


-- | Tokenizer of koshucode.
module Koshucode.Baala.Base.Syntax.Tokenize

-- | Token list on a line.
type TokenLine = CodeLine Token
tokenize :: String -> [TokenLine]
trimLeft :: Map String

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: String -> [Token]
isSimpleWord :: Pred String
isSimpleChar :: Pred Char


-- | Parened tree of tokens
module Koshucode.Baala.Base.Syntax.TokenTree

-- | Tree of tokens.
type TokenTree = Tree Token

-- | Parse tokens into parened trees. Blank tokens and comments are
--   excluded.
--   
--   There are four types of parens -- 1, 2, 3, or 4. Paren type is in
--   <tt>TreeB</tt> <i>type</i> <i>subtrees</i>.
--   
--   <ol>
--   <li>Round parens <tt>( .. )</tt> for grouping.</li>
--   <li>Squared brackets <tt>[ .. ]</tt> for list.</li>
--   <li>Curely braces <tt>{ .. }</tt> for termset.</li>
--   <li>Curely-bar braces <tt>{| .. |}</tt> for relation.</li>
--   </ol>
tokenTrees :: [Token] -> [TokenTree]
treeTokens :: TokenTree -> [Token]
treesTokens :: [TokenTree] -> [Token]
flatname :: TokenTree -> Maybe String
tt :: String -> [TokenTree]
ttDoc :: [TokenTree] -> Doc

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "b c"
--   Left [ TWord 1 0 "b", TSpace 2 1, TWord 3 0 "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "a | b | c"
--   Right ( [ TWord 1 0 "a", TSpace 2 1 ]
--           , TWord 3 0 "|"
--           , [ TSpace 4 1, TWord 5 0 "b", TSpace 6 1
--             , TWord 7 0 "|", TSpace 8 1, TWord 9 0 "c" ] )  
--   </pre>
splitTokensBy :: Pred String -> [Token] -> Either [Token] ([Token], Token, [Token])
divideTreesBy :: String -> [TokenTree] -> [[TokenTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; divideTreesByBar . tokenTrees . tokens $ "a | b | c"
--   [ [TreeL (TWord 1 0 "a")]
--   , [TreeL (TWord 5 0 "b")]
--   , [TreeL (TWord 9 0 "c")] ]  
--   </pre>
divideTreesByBar :: [TokenTree] -> [[TokenTree]]

-- | Divide token trees by colon <tt>":"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; divideTreesByColon . tokenTrees . tokens $ "a : b : c"
--   [ [TreeL (TWord 1 0 "a")]
--   , [TreeL (TWord 5 0 "b")]
--   , [TreeL (TWord 9 0 "c")] ]  
--   </pre>
divideTreesByColon :: [TokenTree] -> [[TokenTree]]


-- | Syntactic functions
module Koshucode.Baala.Base.Syntax


-- | Abort utility
module Koshucode.Baala.Base.Abort.Utility

-- | Class that represents abort reason.
class AbortReasonClass a where abortSub _ = docEmpty
abortSymbol :: AbortReasonClass a => a -> String
abortTitle :: AbortReasonClass a => a -> String
abortMain :: AbortReasonClass a => a -> Doc
abortSub :: AbortReasonClass a => a -> Doc

-- | Abort reason and source code information.
type AbortType a = (a, [Token], [CodeLine Token])

-- | Either of (1) right result or (2) abort information.
type AbortOrType a b = Either (AbortType a) b

-- | Stop program execution abnormally.
abort :: AbortReasonClass a => AbortType a -> IO ()
abortIO :: AbortReasonClass a => (b -> IO ()) -> AbortOrType a b -> IO ()
addAbort :: AbortReasonClass a => AbortType a -> Map (AbortOrType a b)

-- | Stop on error ''bug in koshucode''
bug :: a


-- | Abort symbol
module Koshucode.Baala.Base.Abort.Reason

-- | Either of (1) right result, or (2) abort reason (without source code
--   information).
type Ab b = Either AbortReason b

-- | Abortable mapping.
type AbMap b = b -> Ab b
type AbMap2 b a = b -> Ab a

-- | Abort reason and source information.
type Abort = AbortType AbortReason
type AbortTokens b = Either (AbortReason, [Token]) b

-- | Either of (1) right result, or (2) abort reason with source.
type AbortOr b = AbortOrType AbortReason b

-- | Lookup association list. This function may abort on AbortLookup.
(<!!>) :: [Named a] -> String -> AbortTokens a

-- | Abort reasons
data AbortReason
AbortDivideByZero :: AbortReason
AbortHeteroDecimal :: String -> String -> AbortReason
AbortLookup :: String -> AbortReason
AbortMalformedOperand :: String -> AbortReason
AbortMissingTermname :: String -> AbortReason
AbortNotNumber :: String -> AbortReason
AbortNotText :: String -> AbortReason
AbortNoTerms :: [String] -> AbortReason
AbortOddRelation :: AbortReason
AbortOpeandDuplicate :: [String] -> AbortReason
AbortOpeandUnknown :: [String] -> AbortReason
AbortOpeandUnmatch :: String -> AbortReason
AbortReqBoolean :: String -> AbortReason
AbortReqFlatname :: String -> AbortReason
AbortReqNewTerms :: [String] -> AbortReason
AbortReqText :: String -> AbortReason
AbortUndefined :: String -> AbortReason
AbortUnkCop :: String -> AbortReason
AbortUnkCox :: String -> AbortReason
AbortUnkWord :: String -> AbortReason
AbortUnkClause :: AbortReason
AbortUnkContent :: String -> AbortReason
AbortUnkRelmap :: String -> AbortReason
AbortUnkSymbol :: String -> AbortReason
AbortUnresToken :: AbortReason
AbortUnmatchArity :: AbortReason
AbortUnmatchType :: String -> AbortReason
AbortUsage :: String -> [String] -> AbortReason
instance Show AbortReason
instance Eq AbortReason
instance Ord AbortReason
instance AbortReasonClass AbortReason
instance Name AbortReason


-- | Terms in heading of relation.
module Koshucode.Baala.Base.Data.Relterm

-- | Term in heading of relation
data Relterm

-- | For non-relation
Term :: Termname -> Relterm

-- | For relation
Nest :: Termname -> [Relterm] -> Relterm

-- | Path of term, e.g., term <tt>/r/x</tt> is correspond to path
--   <tt>[<a>/r</a>, <a>/x</a>]</tt>.
type Termpath = [Termname]
termsIndex :: [Relterm] -> [Termpath] -> [[Int]]

-- | Term path to term position
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [Term "/a", Term "/b", Term "/c"] ["/b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [Term "/a", Term "/b", Term "/c"] ["/e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [Nest "/r" [Term "/a", Term "/b"]] ["/r", "/b"]
--   [0, 1]  
--   </pre>
termIndex :: [Relterm] -> Termpath -> [Int]
termExist :: [Relterm] -> Termpath -> Bool
instance Show Relterm
instance Eq Relterm
instance Ord Relterm
instance Pretty Relterm
instance Name Relterm


-- | Heading of relations
module Koshucode.Baala.Base.Data.Relhead

-- | Heading of relation as a list of terms
data Relhead
Relhead :: [Relterm] -> Relhead
headTerms :: Relhead -> [Relterm]

-- | Make head from termnames.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["/a", "/b"]
--   Relhead [Term "/a", Term "/b"]  
--   </pre>
headFrom :: [Termname] -> Relhead
headConsTerm :: Relterm -> Map Relhead

-- | Add term to head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headCons "/c" h
--   Relhead [Term "/c", Term "/a", Term "/b"]  
--   </pre>
headCons :: Termname -> Map Relhead
headCons2 :: Termname -> Termname -> Map Relhead
headCons3 :: Termname -> Termname -> Termname -> Map Relhead

-- | Reconstruct head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headChange reverse h
--   Relhead [Term "/b", Term "/a"]  
--   </pre>
headChange :: (Map [Termname]) -> Map Relhead

-- | List of term names.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headNames h
--   ["/a", "/b"]  
--   </pre>
headNames :: Relhead -> [Termname]

-- | Number of terms.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headDegree h
--   2  
--   </pre>
headDegree :: Relhead -> Int

-- | Filter keeping terms that exist in head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headExistTerms h ["/a", "/c"]
--   ["/a"]  
--   </pre>
headExistTerms :: Relhead -> Map [Termname]

-- | Filter dropping terms that exist in head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headNonExistTerms h ["/a", "/c"]
--   ["/c"]  
--   </pre>
headNonExistTerms :: Relhead -> Map [Termname]

-- | Index of terms.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headIndex h [["/a"], ["/b"], ["/c"]]
--   [[0], [1], [-1]]  
--   </pre>
headIndex :: Relhead -> [Termpath] -> [[Int]]

-- | Index of a term.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headIndex1 h ["/a"]
--   [0]  
--   </pre>
headIndex1 :: Relhead -> Termpath -> [Int]

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a
instance Show Relhead
instance Eq Relhead
instance Ord Relhead
instance Pretty Relhead
instance Monoid Relhead


-- | Functions for term position
module Koshucode.Baala.Base.Data.TermPos

-- | Position of flat term
data TermPos
TermPos :: Termname -> Int -> TermPos

-- | Name of term
posName :: TermPos -> Termname

-- | Position
posIndex :: TermPos -> Int
posHere :: Relhead -> [Termname] -> ([TermPos], [Bool])

-- | Positions of given names in a head
--   
--   <pre>
--   &gt;&gt;&gt; B.headFrom ["/a", "/b", "/c"] `posFor` ["/b", "/c", "/d"]
--   [TermPos "/b" 1, TermPos "/c" 2, TermPos "/d" (-1)]  
--   </pre>
posFor :: Relhead -> [Termname] -> [TermPos]

-- | Positions of given (sub)head in a head
--   
--   <pre>
--   &gt;&gt;&gt; B.headFrom ["/a", "/b", "/c"] `posFrom` B.headFrom ["/b", "/c", "/d"]
--   [TermPos "/b" 1, TermPos "/c" 2, TermPos "/d" (-1)]  
--   </pre>
posFrom :: Relhead -> Relhead -> [TermPos]

-- | <i>h1</i> <tt>`posTo`</tt> <i>h2</i> <tt>==</tt> <i>h2</i>
--   <tt>`posFrom`</tt> <i>h1</i>
posTo :: Relhead -> Relhead -> [TermPos]
posExist :: TermPos -> Bool

-- | Pick inner part.
--   
--   <pre>
--   &gt;&gt;&gt; posInnerNames [TermPos "/a" (-1), TermPos "/b" 1, TermPos "/c" 2]
--   ["/b", "/c"]  
--   </pre>
posInnerNames :: [TermPos] -> [Termname]

-- | Pick outer part.
--   
--   <pre>
--   &gt;&gt;&gt; posOuterNames [TermPos "/a" (-1), TermPos "/b" 1, TermPos "/c" 2]
--   ["/a"]  
--   </pre>
posOuterNames :: [TermPos] -> [Termname]

-- | Sort list of <a>TermPos</a> by the name.
--   
--   <pre>
--   &gt;&gt;&gt; posSortByName [TermPos "/y" 2, TermPos "/x" 0, TermPos "/z" 1]
--   [TermPos "/x" 0, TermPos "/y" 2, TermPos "/z" 1]  
--   </pre>
posSortByName :: Map [TermPos]

-- | Sort list of <a>TermPos</a> by the index.
--   
--   <pre>
--   &gt;&gt;&gt; posSortByIndex [TermPos "/y" 2, TermPos "/x" 0, TermPos "/z" 1]
--   [TermPos "/x" 0, TermPos "/z" 1, TermPos "/y" 2]  
--   </pre>
posSortByIndex :: Map [TermPos]

-- | Pick contents by positions.
--   
--   <pre>
--   &gt;&gt;&gt; posPick [TermPos "/b" 1, TermPos "/c" 2] "abcd"
--   "bc"  
--   </pre>
posPick :: [TermPos] -> Map [c]

-- | Cut contents by positions.
--   
--   <pre>
--   &gt;&gt;&gt; posCut [TermPos "/b" 1, TermPos "/c" 2] "abcd"
--   "ad"  
--   </pre>
posCut :: [TermPos] -> Map [c]
instance Show TermPos
instance Eq TermPos
instance Ord TermPos
instance Name TermPos


-- | Relation type
module Koshucode.Baala.Base.Data.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Relhead -> Relbody c -> Rel c

-- | Heading of relation
relHead :: Rel c -> Relhead

-- | Body of relbody
relBody :: Rel c -> Relbody c

-- | Body of relation, i.e., a list of tuples. Tuple is list of contents.
type Relbody c = [[c]]

-- | Relational version of <a>posHere</a>.
relPosHere :: Rel c -> [Termname] -> ([TermPos], [Bool])

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldum :: Rel Bool)
--   {| |}  
--   </pre>
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldee :: Rel Bool)
--   {| | |}  
--   </pre>
reldee :: Rel c
instance Show c => Show (Rel c)
instance Eq c => Eq (Rel c)
instance Ord c => Ord (Rel c)
instance Pretty c => Pretty (Rel c)


-- | Abort symbols
module Koshucode.Baala.Base.Abort

module Koshucode.Baala.Base.Data.Decimal
data Decimal
Decimal :: (Int, Int) -> Int -> Bool -> Decimal
decimalRatio :: Decimal -> (Int, Int)
decimalLength :: Decimal -> Int
decimalApprox :: Decimal -> Bool
decimalNum :: Decimal -> Int
intDecimal :: Int -> Decimal
decimalSetPoint :: Int -> AbMap Decimal
decimalDenom :: Decimal -> Int
isDecimalZero :: Decimal -> Bool

-- | Make <tt>a</tt> from a string.
type LitString a = AbMap2 String a
type LitDecimal = LitString Decimal
litDecimal :: LitDecimal
decimalString :: Decimal -> String
type DecimalBinary = Decimal -> Decimal -> Ab Decimal
decimalAdd :: DecimalBinary
decimalSub :: DecimalBinary
decimalMul :: DecimalBinary
decimalDiv :: DecimalBinary
decimalQuo :: DecimalBinary
decimalRem :: DecimalBinary
decimalRevsign :: Map Decimal
decimalRevratio :: Map Decimal
decimalAbs :: Map Decimal
decimalSum :: [Decimal] -> Ab Decimal
instance Show Decimal
instance Eq Decimal
instance Ord Decimal


-- | Data on value type <tt>c</tt>
module Koshucode.Baala.Base.Data

module Koshucode.Baala.Base
