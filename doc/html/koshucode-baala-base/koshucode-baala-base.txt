-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.42.0.0


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Syntax.Line

-- | Line number.
type LineNumber = Int
type NumberedLine = (LineNumber, String)

-- | Line number and its content.
linesCrlfNumbered :: String -> [NumberedLine]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
linesCrlf :: String -> [String]

module Koshucode.Baala.Base.Prelude.Unicode
data GeneralCategoryGroup

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: GeneralCategoryGroup

-- | Mn Mc Me
UnicodeMark :: GeneralCategoryGroup

-- | Nd Nl No
UnicodeNumber :: GeneralCategoryGroup

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: GeneralCategoryGroup

-- | Sm Sc Sk So
UnicodeSymbol :: GeneralCategoryGroup

-- | Zs Zl Zp
UnicodeSeperator :: GeneralCategoryGroup

-- | Cc Cf Cs Co Cn
UnicodeOther :: GeneralCategoryGroup
generalCategoryLetter :: GeneralCategoryGroup -> Char
generalCategoryGroup :: Char -> GeneralCategoryGroup
instance Show GeneralCategoryGroup
instance Eq GeneralCategoryGroup
instance Ord GeneralCategoryGroup
instance Bounded GeneralCategoryGroup


-- | Text table
module Koshucode.Baala.Base.Prelude.TextTable
data Position
Front :: Position
Middle :: Position
Rear :: Position
textPos :: String -> [Position]
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
cellText :: Cell -> [String]
cellWidth :: Cell -> Int
cellHeight :: Cell -> Int
cellPos :: Cell -> Position
cellPad :: Cell -> Char
textTable :: [Position] -> [[String]] -> [[Cell]]
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]
textCell :: Position -> String -> Cell
textRuleCell :: Char -> Cell
textBlockCell :: Position -> [String] -> Cell
textBlockCellPlus :: Int -> Position -> [String] -> Cell
alignTable :: [[Cell]] -> [[Cell]]
renderTable :: String -> [[Cell]] -> [String]
instance Show Position
instance Eq Position
instance Ord Position
instance Show Cell
instance Eq Cell
instance Ord Cell

module Koshucode.Baala.Base.Prelude.Pretty

-- | Type that has a pretty printer.
class Pretty a where docv = vcat . map doc doch = hsep . map doc
doc :: Pretty a => a -> Doc
docv :: Pretty a => [a] -> Doc
doch :: Pretty a => [a] -> Doc

-- | Colon-seperated document.
--   
--   <pre>
--   &gt;&gt;&gt; docBracket $ docColon [True, False]
--   [ #true : #false ]  
--   </pre>
docColon :: Pretty a => [a] -> Doc

-- | Wrap in open and close brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWrap "(" ")" "abc"
--   (abc)  
--   </pre>
docWrap :: Pretty a => String -> String -> a -> Doc

-- | Wrap in open and close brackets. Put spaces between content and
--   brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWraps "(" ")" "abc"
--   ( abc )  
--   </pre>
docWraps :: Pretty a => String -> String -> a -> Doc

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
docEmpty :: Doc
docHang :: Doc -> Int -> Doc -> Doc
docZero :: String -> Doc
instance Pretty a => Pretty (String, a)
instance Pretty Bool
instance Pretty String
instance Pretty Int
instance Pretty Doc


-- | General utilities
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)
named :: Name a => a -> Named a
type Map a = a -> a
type Pred a = a -> Bool
data YesNo a
Yes :: a -> YesNo a
No :: a -> YesNo a
instance Show a => Show (YesNo a)
instance Eq a => Eq (YesNo a)
instance Ord a => Ord (YesNo a)


-- | General utilities
module Koshucode.Baala.Base.Prelude.Utility
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
cons1 :: a -> ([a], b) -> ([a], b)
mapmapFst :: (a -> c) -> [(a, b)] -> [(c, b)]
mapmapSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
maybePairs :: [a] -> Maybe [(a, a)]
front :: [a] -> [a]

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Union list to base list.
--   
--   <pre>
--   &gt;&gt;&gt; unionUp "cde" "abc"
--   "deabc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; List.union "cde" "abc"
--   "cdeab"  
--   </pre>
unionUp :: Eq a => [a] -> [a] -> [a]

-- | Make singleton list.
singleton :: a -> [a]
isSingleton :: [a] -> Bool

-- | Split list by predicate. If list contains an element that satisfies
--   the predicate, <tt>(<i>before-list</i>, <i>the-element</i>,
--   <i>after-list</i>)</tt> is returned. Otherwise, original list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "b c"
--   Left "b c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "a | b | c"
--   Right ("a ", '|', " b | c")  
--   </pre>
splitBy :: (a -> Bool) -> [a] -> Either [a] ([a], a, [a])

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divide '|' "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]  
--   </pre>
divide :: Eq a => a -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divideBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]  
--   </pre>
divideBy :: (a -> Bool) -> [a] -> [[a]]

-- | Omit association that has given key.
--   
--   <pre>
--   &gt;&gt;&gt; assocOmit "b" [("a",1), ("b",2), ("c",3)]
--   [("a",1), ("c",3)]  
--   </pre>
assocOmit :: Eq k => k -> Map [(k, a)]

-- | Omit associations that have given keys.
assocOmitAll :: Eq k => [k] -> Map [(k, a)]
maybeEmpty :: Maybe a -> (a -> [b]) -> [b]

-- | Add spaces to right.
--   
--   <pre>
--   &gt;&gt;&gt; padRight 10 "abc"
--   "abc       "  
--   </pre>
padRight :: Int -> Map String

-- | Add spaces to left.
--   
--   <pre>
--   &gt;&gt;&gt; padLeft 10 "abc"
--   "       abc"  
--   </pre>
padLeft :: Int -> Map String
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]
gatherWith :: (c -> Gather [a] b) -> [c] -> [a] -> [b]

-- | Gather (<i>key</i>, <i>value</i>) to <a>Map</a> <i>key</i>
--   [<i>value</i>].
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
putShow :: Show a => a -> IO ()
putShowLn :: Show a => a -> IO ()
putLines :: [String] -> IO ()


-- | Utilities for association lists.
module Koshucode.Baala.Base.Prelude.Assoc
type Lookup a = String -> Maybe a
data OnceMore a
Once :: a -> OnceMore a
More :: [a] -> OnceMore a
assocRename :: Eq k => k -> k -> Map [(k, a)]
assocPush :: Eq k => k -> a -> Map [(k, OnceMore a)]
assocGather :: Eq k => [(k, a)] -> [(k, OnceMore a)]
assocBy :: (a -> Maybe k) -> k -> [a] -> [(k, [a])]
assocOnce :: [(k, OnceMore a)] -> [(k, a)]
assocMore :: [(k, OnceMore a)] -> [(k, [a])]
assocExist :: Eq k => k -> [(k, a)] -> Bool
namedMapM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b
lookupMap :: Ord k => k -> Map k a -> Maybe a
instance Show a => Show (OnceMore a)
instance Eq a => Eq (OnceMore a)
instance Ord a => Ord (OnceMore a)


-- | Arrangement of lists.
module Koshucode.Baala.Base.Prelude.Arrange
type Arrange a = [Int] -> Map [a]

-- | Indices of shared elements.
--   
--   <pre>
--   &gt;&gt;&gt; "bdk" `sharedIndex` "abcdefg"
--   [1,3]  
--   </pre>
sharedIndex :: Eq a => [a] -> [a] -> [Int]

-- | Pick indexed elements.
--   
--   <pre>
--   &gt;&gt;&gt; arrangePick [1,3] "abcdefg"
--   "bd"  
--   </pre>
arrangePick :: Arrange a

-- | Cut indexed elements
--   
--   <pre>
--   &gt;&gt;&gt; arrangeCut [1,3] "abcdefg"
--   "acefg"  
--   </pre>
arrangeCut :: [Int] -> Map [a]

-- | Move indexed elements to the front.
--   
--   <pre>
--   &gt;&gt;&gt; arrangeFore [1,3] "abcdefg"
--   "bdacefg"  
--   </pre>
arrangeFore :: [Int] -> Map [a]

module Koshucode.Baala.Base.Prelude.Order
data OrderCap a
Asc :: a -> OrderCap a
Desc :: a -> OrderCap a
type Ranking n a = Int -> [OrderCap n] -> [n] -> [[a]] -> ([Int], [[a]])
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
instance Show a => Show (OrderCap a)
instance Eq a => Eq (OrderCap a)
instance Ord a => Ord (OrderCap a)

module Koshucode.Baala.Base.Data.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec
emacsModeComment :: String
instance Show CommentSec
instance Eq CommentSec
instance Ord CommentSec
instance Show CommentDoc
instance Eq CommentDoc
instance Ord CommentDoc
instance Texts CommentSec
instance Texts CommentDoc

module Koshucode.Baala.Base.Prelude


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Base.Data.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of pattern, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement pattern represents certain sentence pattern
--   that gives intepretation of data. Sentence pattern has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c
Judge :: Bool -> JudgePattern -> [Named c] -> Judge c

-- | Name of judgement pattern.
type JudgePattern = String

-- | Sort terms in alphabetical order.
abcJudge :: Ord c => Map (Judge c)

-- | Construct affirmed judgement.
affirm :: JudgePattern -> [Named c] -> Judge c

-- | Construct denied judgement.
deny :: JudgePattern -> [Named c] -> Judge c

-- | Affirm judgement, i.e., change logical quality to <a>True</a>.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to <a>False</a>.
denyJudge :: Map (Judge c)

-- | Test that judgement is affirmd.
isAffirmed :: Judge c -> Bool

-- | Test that judgement is denied.
--   
--   <pre>
--   &gt;&gt;&gt; isDenied $ Judge True "A" []
--   False  
--   </pre>
isDenied :: Judge c -> Bool

-- | Print judges to <a>stdout</a>.
putJudges :: (Ord c, Pretty c) => Int -> [Judge c] -> IO Int

-- | Print judges.
hPutJudges :: (Ord c, Pretty c) => Handle -> Int -> [Judge c] -> IO Int

-- | Convert judgements to lines.
judgeLines :: (Ord c, Pretty c) => String -> [Judge c] -> [String]
instance Show c => Show (Judge c)
instance (Ord c, Pretty c) => Pretty (Judge c)
instance Functor Judge
instance Ord c => Ord (Judge c)
instance Ord c => Eq (Judge c)


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <a>CodeLine</a> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <a>CodeLine</a>.
module Koshucode.Baala.Base.Syntax.Code

-- | Tokens in line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
lineNumber :: CodeLine a -> LineNumber

-- | Line content without newline.
lineContent :: CodeLine a -> String

-- | Tokens in the line.
lineTokens :: CodeLine a -> [a]
lineNumberContent :: CodeLine a -> String

-- | Tokens in clause.
data CodeClause a
CodeClause :: [CodeLine a] -> [a] -> CodeClause a

-- | Source lines of clause
clauseLines :: CodeClause a -> [CodeLine a]

-- | Source tokens of clause
clauseTokens :: CodeClause a -> [a]
indentLineBy :: (a -> Int) -> CodeLine a -> (Int, CodeLine a)
splitClause :: Gather [(Int, a)] [a]

-- | Type of function that splits a next token from string. Tokens can
--   includes <tt>TokenNumber</tt>.
type NextToken a = NumberedLine -> Gather String a

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><tt>LineNumber</tt><tt>,</tt>
--   <a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeLines :: NextToken a -> String -> [CodeLine a]
instance Typeable1 CodeLine
instance Typeable1 CodeClause
instance Show a => Show (CodeLine a)
instance Eq a => Eq (CodeLine a)
instance Ord a => Ord (CodeLine a)
instance Data a => Data (CodeLine a)
instance Show a => Show (CodeClause a)
instance Data a => Data (CodeClause a)
instance Pretty (CodeLine a)

module Koshucode.Baala.Base.Syntax.Tree

-- | Tree of leaf and branch.
data CodeTree a

-- | Leaf. Terminal of tree.
TreeL :: a -> CodeTree a

-- | Branch. Paren-type and subtrees.
TreeB :: ParenType -> (Maybe (a, a)) -> [CodeTree a] -> CodeTree a

-- | Convert a list of elements to a single tree.
tree :: Show a => GetParenType a -> [a] -> CodeTree a

-- | Convert a list of elements to trees.
trees :: Show a => GetParenType a -> [a] -> [CodeTree a]
treeG :: [CodeTree a] -> CodeTree a
treeWrap :: [CodeTree a] -> CodeTree a

-- | Convert tree to list of tokens.
untree :: CodeTree a -> [a]

-- | Convert tree to list of tokens.
untrees :: [CodeTree a] -> [a]

-- | Simplify tree by removing double parens, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Pred ParenType -> Map (CodeTree a)
type ParenType = Int

-- | Get a paren type.
type GetParenType a = a -> ParenType

-- | Make <a>GetParenType</a> functions from a type-open-close table.
--   
--   Make paren/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let paren n [a, b] = (n, (== a), (== b))
--   
--   &gt;&gt;&gt; let pt = parenTable [ paren 1 "()", paren 2 "[]" ]
--   </pre>
--   
--   Get paren types for each chars. Types of open parens are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0, 0, 1, 0, 0, 2, 0, 0, -2, -1, 0]
--   </pre>
parenTable :: Eq a => [(ParenType, Pred a, Pred a)] -> GetParenType a
instance Typeable1 Paren
instance Typeable1 CodeTree
instance Show a => Show (Paren a)
instance Eq a => Eq (Paren a)
instance Ord a => Ord (Paren a)
instance Data a => Data (Paren a)
instance Show a => Show (CodeTree a)
instance Eq a => Eq (CodeTree a)
instance Ord a => Ord (CodeTree a)
instance Data a => Data (CodeTree a)
instance Functor CodeTree


-- | Convert infixed-operator trees into prefixed-operator trees
module Koshucode.Baala.Base.Syntax.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
infixHeight :: Ord b => (a -> Maybe b) -> [(b, InfixHeight)] -> a -> InfixHeight

-- | Split branches in a given tree at infixed binary operators
infixToPrefix :: (a -> InfixHeight) -> CodeTree a -> Either [(InfixHeight, a)] (CodeTree a)


-- | Syntactic functions.
module Koshucode.Baala.Base.Syntax

module Koshucode.Baala.Base.Token.TokenPos
data TokenPos
TokenPos :: Resource -> NumberedLine -> String -> TokenPos
tokenPosResource :: TokenPos -> Resource

-- | Line number and content
tokenPosLine :: TokenPos -> NumberedLine

-- | Text at which begins token
tokenPosText :: TokenPos -> String
tokenPosLineNumber :: TokenPos -> Int
tokenPosLineText :: TokenPos -> String
tokenPosColumn :: TokenPos -> Int
tokenPosDisplay :: TokenPos -> [String]
tokenPosZero :: TokenPos
data Resource
ResourceFile :: String -> Resource
ResourceText :: String -> Resource
ResourceURL :: String -> Resource
resourceType :: Resource -> String
resourceName :: Resource -> String
instance Typeable Resource
instance Typeable TokenPos
instance Show Resource
instance Eq Resource
instance Ord Resource
instance Data Resource
instance Show TokenPos
instance Eq TokenPos
instance Data TokenPos
instance Ord TokenPos

module Koshucode.Baala.Base.Token.Token

-- | There are eight types of tokens.
data Token

-- | Word. <a>Int</a> represents quotation level, i.e., 0 for non-quoted, 1
--   for single-quoted, 2 for double-quoted.
TWord :: TokenPos -> Int -> String -> Token

-- | Abbreviated word
TShort :: TokenPos -> String -> String -> Token

-- | Termname
TTerm :: TokenPos -> [Termname] -> Token

-- | Opening paren
TOpen :: TokenPos -> String -> Token

-- | Closing paren
TClose :: TokenPos -> String -> Token

-- | <i>N</i> space characters
TSpace :: TokenPos -> Int -> Token

-- | Comment text
TComment :: TokenPos -> String -> Token

-- | Unknown text
TUnknown :: TokenPos -> String -> Token
class TokenListing a
tokenListing :: TokenListing a => a -> [Token]

-- | Name of term, e.g., <tt>"/file"</tt> for the term <tt>/file</tt>.
type Termname = String
type Termname2 = (String, String)
type Termname3 = (String, String, String)
tokenWord :: String -> Token
tokenPos :: Token -> TokenPos

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TTerm 20 ["/r", "/x"] in tokenContent tok
--   "/r/x"  
--   </pre>
tokenContent :: Token -> String

-- | Text of token type, i.e., one of <tt>"Word"</tt>, <tt>"Term"</tt>,
--   <tt>"Open"</tt>, <tt>"Close"</tt>, <tt>"Space"</tt>,
--   <tt>"Comment"</tt>, or <tt>"Unknown"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; tokenTypeText $ TWord 25 0 "flower"
--   "Word"  
--   </pre>
tokenTypeText :: Token -> String

-- | Test the token is blank, i.e., <a>TComment</a> or <a>TSpace</a>.
isBlankToken :: Pred Token

-- | Check token is a <a>TOpen</a> of the specific paren.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "(" in isOpenTokenOf "(" tok
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "{" in isOpenTokenOf "(" tok
--   False 
--   </pre>
isOpenTokenOf :: String -> Pred Token

-- | Check token is a <a>TClose</a> of the specific paren.
isCloseTokenOf :: String -> Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]
tokenIndent :: Token -> Int
instance Typeable Token
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance TokenListing a => TokenListing (Maybe a)
instance Pretty Token
instance Name Token


-- | Tokenizer of koshucode.
module Koshucode.Baala.Base.Token.TokenLine

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Tokenize text.
tokenLines :: Resource -> String -> [TokenLine]
trimLeft :: Map String

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: Resource -> String -> [Token]
isSimpleWord :: Pred String
isSimpleChar :: Pred Char
commentLine :: String -> String
putCommentLines :: [String] -> IO ()

module Koshucode.Baala.Base.Token.TokenClause
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]
instance Pretty TokenClause


-- | Parened tree of tokens
module Koshucode.Baala.Base.Token.TokenTree
data Sourced a
Sourced :: [Token] -> a -> Sourced a

-- | Tree of tokens.
type TokenTree = CodeTree Token

-- | Parse tokens into parened trees. Blank tokens and comments are
--   excluded.
--   
--   There are four types of parens -- 1, 2, 3, or 4. Paren type is in
--   <tt>TreeB</tt> <i>type</i> <i>parens</i> <i>subtrees</i>.
--   
--   <ol>
--   <li>Round parens <tt>( .. )</tt> for grouping.</li>
--   <li>Squared brackets <tt>[ .. ]</tt> for list.</li>
--   <li>Curely braces <tt>{ .. }</tt> for termset.</li>
--   <li>Curely-bar braces <tt>{| .. |}</tt> for relation.</li>
--   </ol>
tokenTrees :: [Token] -> [TokenTree]
treeTokens :: TokenTree -> [Token]
treesTokens :: [TokenTree] -> [Token]

-- | Convert text to token trees.
tt :: String -> [TokenTree]
tt1 :: String -> TokenTree

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: [TokenTree] -> Doc

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "b c"
--   Left [ TWord 1 0 "b", TSpace 2 1, TWord 3 0 "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "a | b | c"
--   Right ( [ TWord 1 0 "a", TSpace 2 1 ]
--           , TWord 3 0 "|"
--           , [ TSpace 4 1, TWord 5 0 "b", TSpace 6 1
--             , TWord 7 0 "|", TSpace 8 1, TWord 9 0 "c" ] )  
--   </pre>
splitTokensBy :: Pred String -> [Token] -> Either [Token] ([Token], Token, [Token])
divideTreesBy :: String -> [TokenTree] -> [[TokenTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; divideTreesByBar . tokenTrees . tokens $ "a | b | c"
--   [ [TreeL (TWord 1 0 "a")]
--   , [TreeL (TWord 5 0 "b")]
--   , [TreeL (TWord 9 0 "c")] ]  
--   </pre>
divideTreesByBar :: [TokenTree] -> [[TokenTree]]

-- | Divide token trees by colon <tt>":"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; divideTreesByColon . tokenTrees . tokens $ "a : b : c"
--   [ [TreeL (TWord 1 0 "a")]
--   , [TreeL (TWord 5 0 "b")]
--   , [TreeL (TWord 9 0 "c")] ]  
--   </pre>
divideTreesByColon :: [TokenTree] -> [[TokenTree]]
instance Show a => Show (Sourced a)
instance Eq a => Eq (Sourced a)
instance Ord a => Ord (Sourced a)
instance Functor Sourced


-- | Tokens in Koshucode.
module Koshucode.Baala.Base.Token


-- | Class for abort reasons
module Koshucode.Baala.Base.Abort.Class

-- | Class that represents abort reason.
class Show a => AbortReasonClass a where abortSymbol = head . words . show abortReason _ = "" abortDetail _ = [] abortSource _ = []
abortClass :: AbortReasonClass a => a -> String
abortSymbol :: AbortReasonClass a => a -> String
abortReason :: AbortReasonClass a => a -> String
abortDetail :: AbortReasonClass a => a -> [String]
abortSource :: AbortReasonClass a => a -> [String]

-- | Command name and its arguments.
type CommandLine = [String]

-- | Abortable process.
abortableIO :: AbortReasonClass a => CommandLine -> (b -> IO c) -> Either a b -> IO c


-- | Abort reasons
module Koshucode.Baala.Base.Abort.EachReason
data AbortIO
AIONoFile :: String -> AbortIO
data AbortSyntax

-- | Ambiguous infix operators
ASAmbInfixes :: [String] -> AbortSyntax

-- | Can't read as number
ASNotNumber :: String -> AbortSyntax

-- | Can't read as text
ASNotText :: String -> AbortSyntax

-- | Odd relation literal
ASOddRelation :: AbortSyntax

-- | Unknown clause
ASUnkClause :: AbortSyntax

-- | Unknown expression
ASUnkCox :: String -> AbortSyntax

-- | Unknown word
ASUnkWord :: String -> AbortSyntax

-- | Unresolved prefix
ASUnresToken :: AbortSyntax
data AbortAnalysis
AACheckTerms :: [String] -> AbortAnalysis
AAMalformedOperand :: String -> AbortAnalysis
AAMissingTermname :: String -> AbortAnalysis
AANoTerms :: [String] -> AbortAnalysis
AAOpeandDuplicate :: [String] -> AbortAnalysis
AAOpeandUnknown :: [String] -> AbortAnalysis
AAReqBoolean :: String -> AbortAnalysis
AAReqFlatname :: String -> AbortAnalysis
AAReqNewTerms :: [String] -> AbortAnalysis
AAUndefined :: String -> AbortAnalysis
AAUnkCop :: String -> AbortAnalysis
AAUnkRelmap :: String -> AbortAnalysis
data AbortCalc
ACDivideByZero :: AbortCalc
ACUnmatchType :: String -> AbortCalc
ACHeteroDecimal :: String -> String -> AbortCalc
ACNotFound :: String -> AbortCalc
instance Show AbortIO
instance Eq AbortIO
instance Ord AbortIO
instance Show AbortSyntax
instance Eq AbortSyntax
instance Ord AbortSyntax
instance Show AbortAnalysis
instance Eq AbortAnalysis
instance Ord AbortAnalysis
instance Show AbortCalc
instance Eq AbortCalc
instance Ord AbortCalc
instance AbortReasonClass AbortCalc
instance AbortReasonClass AbortAnalysis
instance AbortReasonClass AbortSyntax
instance AbortReasonClass AbortIO


-- | Bundle of abort reasons
module Koshucode.Baala.Base.Abort.Reason

-- | Bundle of abort reasons.
data AbortReason
AbortIO :: AbortIO -> AbortReason
AbortSyntax :: [Token] -> AbortSyntax -> AbortReason
AbortAnalysis :: [Token] -> AbortAnalysis -> AbortReason
AbortCalc :: [Token] -> AbortCalc -> AbortReason

-- | Abortable result, i.e., either of right result or abort reason.
type Ab b = Either AbortReason b

-- | Abortable mapping.
type AbMap b = b -> Ab b

-- | Push source information when process is aborted.
--   
--   <pre>
--   B.ab src $ do ...
--   </pre>
ab :: [Token] -> Map (Ab b)

-- | Same as <a>ab</a> except for using <a>TokenListing</a> instead of list
--   of <a>Token</a>.
abFrom :: TokenListing src => src -> Map (Ab b)
sourcedAbMap :: (a -> Ab b) -> Sourced a -> Ab (Sourced b)

-- | Lookup association list. This function may abort.
(<!!>) :: [Named b] -> String -> Ab b
abortMalformedOperand :: String -> AbortReason
abortNotFound :: String -> AbortReason

-- | Stop on error <tt>'bug in koshucode'</tt>
bug :: a
instance Show AbortReason
instance Eq AbortReason
instance Ord AbortReason
instance AbortReasonClass AbortReason
instance Name AbortReason


-- | Terms in heading of relation.
module Koshucode.Baala.Base.Data.Relterm

-- | Term in heading of relation
data Relterm

-- | For non-relation
Term :: Termname -> Relterm

-- | For relation
Nest :: Termname -> [Relterm] -> Relterm

-- | Path of term, e.g., term <tt>/r/x</tt> is correspond to path
--   <tt>[<a>/r</a>, <a>/x</a>]</tt>.
type Termpath = [Termname]
termsIndex :: [Relterm] -> [Termpath] -> [[Int]]

-- | Term path to term position
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [Term "/a", Term "/b", Term "/c"] ["/b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [Term "/a", Term "/b", Term "/c"] ["/e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [Nest "/r" [Term "/a", Term "/b"]] ["/r", "/b"]
--   [0, 1]  
--   </pre>
termIndex :: [Relterm] -> Termpath -> [Int]
termExist :: [Relterm] -> Termpath -> Bool
instance Show Relterm
instance Eq Relterm
instance Ord Relterm
instance Pretty Relterm
instance Name Relterm


-- | Heading of relations
module Koshucode.Baala.Base.Data.Relhead

-- | Heading of relation as a list of terms
data Relhead
Relhead :: [Relterm] -> Relhead
headTerms :: Relhead -> [Relterm]

-- | Make head from termnames.
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["/a", "/b"]
--   Relhead [Term "/a", Term "/b"]  
--   </pre>
headFrom :: [Termname] -> Relhead
headConsTerm :: Relterm -> Map Relhead

-- | Add term to head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headCons "/c" h
--   Relhead [Term "/c", Term "/a", Term "/b"]  
--   </pre>
headCons :: Termname -> Map Relhead
headCons2 :: Termname -> Termname -> Map Relhead
headCons3 :: Termname -> Termname -> Termname -> Map Relhead

-- | Reconstruct head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headChange reverse h
--   Relhead [Term "/b", Term "/a"]  
--   </pre>
headChange :: (Map [Termname]) -> Map Relhead

-- | List of term names.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headNames h
--   ["/a", "/b"]  
--   </pre>
headNames :: Relhead -> [Termname]

-- | Number of terms.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headDegree h
--   2  
--   </pre>
headDegree :: Relhead -> Int

-- | Keep terms that exist in head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/b"] in headKeepTerms h ["/a", "/b", "/c"]
--   ["/b"]  
--   </pre>
headKeepTerms :: Relhead -> Map [Termname]

-- | Drop terms that exist in head.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/b"] in headDropTerms h ["/a", "/b", "/c"]
--   ["/a","/c"]  
--   </pre>
headDropTerms :: Relhead -> Map [Termname]

-- | Index of terms.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headIndex h [["/a"], ["/b"], ["/c"]]
--   [[0], [1], [-1]]  
--   </pre>
headIndex :: Relhead -> [Termpath] -> [[Int]]

-- | Index of a term.
--   
--   <pre>
--   &gt;&gt;&gt; let h = headFrom ["/a", "/b"] in headIndex1 h ["/a"]
--   [0]  
--   </pre>
headIndex1 :: Relhead -> Termpath -> [Int]

-- | <pre>
--   &gt;&gt;&gt; headFrom ["/a", "/b"] `isSubhead` headFrom ["/a", "/b", "/c"]
--      True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headFrom ["/a", "/d"] `isSubhead` headFrom ["/a", "/b", "/c"]
--   False
--   </pre>
isSubhead :: Relhead -> Relhead -> Bool
isSuperhead :: Relhead -> Relhead -> Bool
isEqvHead :: Relhead -> Relhead -> Bool

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a
instance Show Relhead
instance Eq Relhead
instance Ord Relhead
instance Pretty Relhead
instance Monoid Relhead


-- | Functions for term position
module Koshucode.Baala.Base.Data.TermPos

-- | Position of flat term
data TermPos
TermPos :: Termname -> Int -> TermPos

-- | Name of term
posName :: TermPos -> Termname

-- | Position
posIndex :: TermPos -> Int
posHere :: Relhead -> [Termname] -> ([TermPos], [Bool])

-- | Positions of given names in a head
--   
--   <pre>
--   &gt;&gt;&gt; B.headFrom ["/a", "/b", "/c"] `posFor` ["/b", "/c", "/d"]
--   [TermPos "/b" 1, TermPos "/c" 2, TermPos "/d" (-1)]  
--   </pre>
posFor :: Relhead -> [Termname] -> [TermPos]

-- | Positions of given (sub)head in a head
--   
--   <pre>
--   &gt;&gt;&gt; B.headFrom ["/a", "/b", "/c"] `posFrom` B.headFrom ["/b", "/c", "/d"]
--   [TermPos "/b" 1, TermPos "/c" 2, TermPos "/d" (-1)]  
--   </pre>
posFrom :: Relhead -> Relhead -> [TermPos]

-- | <i>h1</i> <tt>`posTo`</tt> <i>h2</i> <tt>==</tt> <i>h2</i>
--   <tt>`posFrom`</tt> <i>h1</i>
posTo :: Relhead -> Relhead -> [TermPos]
posExist :: TermPos -> Bool

-- | Pick inner part.
--   
--   <pre>
--   &gt;&gt;&gt; posInnerNames [TermPos "/a" (-1), TermPos "/b" 1, TermPos "/c" 2]
--   ["/b", "/c"]  
--   </pre>
posInnerNames :: [TermPos] -> [Termname]

-- | Pick outer part.
--   
--   <pre>
--   &gt;&gt;&gt; posOuterNames [TermPos "/a" (-1), TermPos "/b" 1, TermPos "/c" 2]
--   ["/a"]  
--   </pre>
posOuterNames :: [TermPos] -> [Termname]

-- | Sort list of <a>TermPos</a> by the name.
--   
--   <pre>
--   &gt;&gt;&gt; posSortByName [TermPos "/y" 2, TermPos "/x" 0, TermPos "/z" 1]
--   [TermPos "/x" 0, TermPos "/y" 2, TermPos "/z" 1]  
--   </pre>
posSortByName :: Map [TermPos]

-- | Sort list of <a>TermPos</a> by the index.
--   
--   <pre>
--   &gt;&gt;&gt; posSortByIndex [TermPos "/y" 2, TermPos "/x" 0, TermPos "/z" 1]
--   [TermPos "/x" 0, TermPos "/z" 1, TermPos "/y" 2]  
--   </pre>
posSortByIndex :: Map [TermPos]

-- | Pick contents by positions.
--   
--   <pre>
--   &gt;&gt;&gt; posPick [TermPos "/b" 1, TermPos "/c" 2] "abcd"
--   "bc"  
--   </pre>
posPick :: [TermPos] -> Map [c]

-- | Cut contents by positions.
--   
--   <pre>
--   &gt;&gt;&gt; posCut [TermPos "/b" 1, TermPos "/c" 2] "abcd"
--   "ad"  
--   </pre>
posCut :: [TermPos] -> Map [c]
instance Show TermPos
instance Eq TermPos
instance Ord TermPos
instance Name TermPos


-- | Relation type
module Koshucode.Baala.Base.Data.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Relhead -> Relbody c -> Rel c

-- | Heading of relation
relHead :: Rel c -> Relhead

-- | Body of relbody
relBody :: Rel c -> Relbody c

-- | Body of relation, i.e., a list of tuples. Tuple is list of contents.
type Relbody c = [[c]]

-- | Relational version of <a>posHere</a>.
relPosHere :: Rel c -> [Termname] -> ([TermPos], [Bool])

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldum :: Rel Bool)
--   {| |}  
--   </pre>
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
--   
--   <pre>
--   &gt;&gt;&gt; B.doc (reldee :: Rel Bool)
--   {| | |}  
--   </pre>
reldee :: Rel c
instance Show c => Show (Rel c)
instance Eq c => Eq (Rel c)
instance Ord c => Ord (Rel c)
instance Pretty c => Pretty (Rel c)


-- | Abort symbols
module Koshucode.Baala.Base.Abort

module Koshucode.Baala.Base.Data.Decimal
data Decimal
Decimal :: (Int, Int) -> Int -> Bool -> Decimal
decimalRatio :: Decimal -> (Int, Int)
decimalLength :: Decimal -> Int
decimalApprox :: Decimal -> Bool
decimalNum :: Decimal -> Int
intDecimal :: Int -> Decimal
decimalSetPoint :: Int -> AbMap Decimal
decimalDenom :: Decimal -> Int
isDecimalZero :: Decimal -> Bool

-- | Make <tt>a</tt> from a string.
type LitString a = String -> Ab a
type LitDecimal = LitString Decimal
litDecimal :: LitDecimal
decimalString :: Decimal -> String
type DecimalBinary = Decimal -> Decimal -> Ab Decimal
decimalAdd :: DecimalBinary
decimalSub :: DecimalBinary
decimalMul :: DecimalBinary
decimalDiv :: DecimalBinary
decimalQuo :: DecimalBinary
decimalRem :: DecimalBinary
decimalRevsign :: Map Decimal
decimalRevratio :: Map Decimal
decimalAbs :: Map Decimal
decimalSum :: [Decimal] -> Ab Decimal
instance Show Decimal
instance Eq Decimal
instance Ord Decimal


-- | Data on value type <tt>c</tt>
module Koshucode.Baala.Base.Data

module Koshucode.Baala.Base
