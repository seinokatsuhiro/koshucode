-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.75.0.0

module Koshucode.Baala.Base.Text.Unicode
data GeneralCategoryGroup

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: GeneralCategoryGroup

-- | Mn Mc Me
UnicodeMark :: GeneralCategoryGroup

-- | Nd Nl No
UnicodeNumber :: GeneralCategoryGroup

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: GeneralCategoryGroup

-- | Sm Sc Sk So
UnicodeSymbol :: GeneralCategoryGroup

-- | Zs Zl Zp
UnicodeSeperator :: GeneralCategoryGroup

-- | Cc Cf Cs Co Cn
UnicodeOther :: GeneralCategoryGroup
generalCategoryLetter :: GeneralCategoryGroup -> Char
generalCategoryName :: GeneralCategoryGroup -> String
generalCategoryGroup :: Char -> GeneralCategoryGroup
instance Show GeneralCategoryGroup
instance Eq GeneralCategoryGroup
instance Ord GeneralCategoryGroup
instance Bounded GeneralCategoryGroup

module Koshucode.Baala.Base.Text.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec
emacsModeComment :: String
commentLine :: String -> String
putCommentLines :: [String] -> IO ()
hPutCommentLines :: Handle -> [String] -> IO ()
instance Show CommentSec
instance Eq CommentSec
instance Ord CommentSec
instance Show CommentDoc
instance Eq CommentDoc
instance Ord CommentDoc
instance Texts CommentSec
instance Texts CommentDoc


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Syntax.Line

-- | Line number.
type LineNumber = Int
type NumberedLine = (LineNumber, String)

-- | Line number and its content.
linesCrlfNumbered :: String -> [NumberedLine]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
linesCrlf :: String -> [String]

module Koshucode.Baala.Base.Prelude.Pair
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
cons1 :: a -> ([a], b) -> ([a], b)
mapFstTo :: Functor m => (a -> c) -> m (a, b) -> m (c, b)
mapSndTo :: Functor m => (b -> c) -> m (a, b) -> m (a, c)
maybePairs :: [a] -> Maybe [(a, a)]
sequenceFst :: Monad m => [(m a, b)] -> m [(a, b)]
sequenceSnd :: Monad m => [(a, m b)] -> m [(a, b)]

module Koshucode.Baala.Base.Prelude.Import

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()

-- | <tt><a>guard</a> b</tt> is <tt><a>return</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>mzero</a> if <tt>b</tt> is <a>False</a>.
guard :: MonadPlus m => Bool -> m ()
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | Same as <a>lookup</a> in <tt>Data.Map</tt> module.
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
catMaybes :: [Maybe a] -> [a]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
fromMaybe :: a -> Maybe a -> a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc
docEmpty :: Doc
docHang :: Doc -> Int -> Doc -> Doc
docZero :: String -> Doc


-- | General utilities
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)
named :: Name a => a -> Named a
type Map a = a -> a
type Pred a = a -> Bool
data YesNo a
Yes :: a -> YesNo a
No :: a -> YesNo a
type Index = Int
type Collect a = [a] -> a
class Choose m
(<|>) :: Choose m => m a -> m a -> m a
instance Show a => Show (YesNo a)
instance Eq a => Eq (YesNo a)
instance Ord a => Ord (YesNo a)
instance Choose (Either a)
instance Choose Maybe

module Koshucode.Baala.Base.Prelude.List

-- | Head or empty.
front :: [a] -> [a]

-- | Tails of list.
tails :: [a] -> [[a]]

-- | Test list has single element.
isSingleton :: [a] -> Bool

-- | Test list is not empty.
notNull :: [a] -> Bool
maybeEmpty :: Maybe a -> (a -> [b]) -> [b]
right :: b -> Map (Either a b)

-- | Keep duplicate elements.
duplicates :: Ord a => [a] -> [a]

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Union list to base list.
unionUp :: Eq a => [a] -> [a] -> [a]

-- | Make singleton list.
li1 :: a -> [a]
li2 :: a -> a -> [a]
li3 :: a -> a -> a -> [a]
map2 :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
mapAt :: (Map a) -> Int -> Map [a]
mapWithLast :: (a -> b) -> (a -> b) -> [a] -> [b]
omit :: (a -> Bool) -> Map [a]
squeeze :: (a -> Bool) -> Map [a]
squeezeEmptyLines :: Map [String]
chunks :: Int -> [a] -> [[a]]

-- | Split list by predicate. If list contains an element that satisfies
--   the predicate, <tt>(<i>before-list</i>, <i>the-element</i>,
--   <i>after-list</i>)</tt> is returned. Otherwise, original list is
--   returned.
splitBy :: (a -> Bool) -> [a] -> Either [a] ([a], a, [a])

-- | Divide list.
divide :: Eq a => a -> [a] -> [[a]]

-- | Divide list.
divideBy :: (a -> Bool) -> [a] -> [[a]]


-- | Snipping elements.
module Koshucode.Baala.Base.Prelude.Snip
type Snip a = [Int] -> Map [a]
type SnipPair a b = (Snip a, Snip b)
snipFull :: Eq a => [a] -> [a] -> [Int]

-- | Indices of shared elements.
snipIndex :: Eq a => [a] -> [a] -> [Int]
snipPair :: Ord a => [a] -> [a] -> ([Int], [Int])

-- | Pair of picking-up and cutting-off elements.
snipBoth :: [Int] -> [a] -> ([a], [a])

-- | Pick up indexed elements.
snipFrom :: Snip a

-- | Cut off indexed elements.
snipOff :: Snip a

-- | Move indexed elements to the front.
snipFore :: Snip a
snipFore2 :: SnipPair a b

-- | Take left-side elements.
snipLeft :: Eq a => [a] -> [a] -> [a]

-- | Take shared elements.
snipShare :: Eq a => [a] -> [a] -> [a]

-- | Take right-side elements.
snipRight :: Eq a => [a] -> [a] -> [a]
snipOrder :: Eq a => [a] -> [a] -> Map [c]

-- | Check lengths of two lists are same.
sameLength :: [a] -> [b] -> Bool
notSameLength :: [a] -> [b] -> Bool

-- | Check elements in the first list are non-negative, and elements in the
--   second are negative.
operand :: [Int] -> [Int] -> Bool

module Koshucode.Baala.Base.Prelude.Order
data OrderCap a
Asc :: a -> OrderCap a
Desc :: a -> OrderCap a
type Ranking n a = Int -> [OrderCap n] -> [n] -> [[a]] -> ([Int], [[a]])
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
sortWith :: (Ord a, Ord b) => (a -> b) -> [a] -> [a]
instance Show a => Show (OrderCap a)
instance Eq a => Eq (OrderCap a)
instance Ord a => Ord (OrderCap a)


-- | Utilities for association lists.
module Koshucode.Baala.Base.Prelude.Assoc
type Lookup a = String -> Maybe a

-- | Construct assoc list by splitting base list.
assocBy :: (a -> Maybe k) -> k -> [a] -> [(k, [a])]

-- | Check which given key is there in assoc list.
assocExist :: Eq k => k -> [(k, a)] -> Bool
namedMapM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
lookupBy :: (a -> Bool) -> [(a, b)] -> Maybe b

-- | Lookup assoc list that keys are truth-valued functions.
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b
assocFinder :: Ord k => [(k, v)] -> k -> Maybe v

-- | Pick up associations that have given keys.
assocPick :: Eq k => [k] -> Map [(k, a)]

-- | Cut off associations that have given keys.
assocCut :: Eq k => [k] -> Map [(k, a)]
assocCut1 :: Eq k => k -> Map [(k, a)]
assocRename1 :: Eq k => k -> k -> Map [(k, a)]
assocRehead :: Eq k => [(k, k)] -> [(k, v)] -> [(k, v)]
data OnceMore a
Once :: a -> OnceMore a
More :: [a] -> OnceMore a

-- | Convert general assoc list into once/more assoc list.
assocGather :: Eq k => [(k, a)] -> [(k, OnceMore a)]

-- | Push key and value into once/more assoc list.
assocPush :: Eq k => k -> a -> Map [(k, OnceMore a)]

-- | Extract once part from once/more assoc list.
assocOnce :: [(k, OnceMore a)] -> [(k, a)]

-- | Extract more part from once/more assoc list.
assocMore :: [(k, OnceMore a)] -> [(k, [a])]
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]
gatherWith :: (c -> Gather [a] b) -> [c] -> [a] -> [b]

-- | Gather (<i>key</i>, <i>value</i>) to <tt>Map</tt> <i>key</i>
--   [<i>value</i>].
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
instance Show a => Show (OnceMore a)
instance Eq a => Eq (OnceMore a)
instance Ord a => Ord (OnceMore a)

module Koshucode.Baala.Base.Prelude

module Koshucode.Baala.Base.Text.Resource
data Resource
ResourceFile :: String -> Resource
ResourceText :: String -> Resource
ResourceURL :: String -> Resource

-- | Name of resourcd type, i.e., <tt>"file"</tt>, <tt>"text"</tt>,
--   <tt>"url"</tt>.
resourceType :: Resource -> String
resourceName :: Resource -> String
data CodePt
CodePt :: Resource -> Int -> String -> String -> CodePt

-- | Resource of code
codeResource :: CodePt -> Resource

-- | Line number
codeLineNumber :: CodePt -> Int

-- | Line content
codeLineText :: CodePt -> String

-- | Text at which begins token
codeText :: CodePt -> String

-- | Empty code point, i.e., empty content and zero line number.
codeZero :: CodePt

-- | Column number at which code starts.
codeColumnNumber :: CodePt -> Int
codeDisplay :: (String, CodePt) -> [(String, String)]
class CodePtr a
codePts :: CodePtr a => a -> [CodePt]
data Sourced a
Sourced :: [CodePt] -> a -> Sourced a
source :: Sourced a -> [CodePt]
unsourced :: Sourced a -> a
instance Typeable Resource
instance Typeable CodePt
instance Typeable1 Sourced
instance Show Resource
instance Eq Resource
instance Ord Resource
instance Data Resource
instance Show CodePt
instance Eq CodePt
instance Data CodePt
instance Show a => Show (Sourced a)
instance Eq a => Eq (Sourced a)
instance Ord a => Ord (Sourced a)
instance Data a => Data (Sourced a)
instance CodePtr (Sourced a)
instance Functor Sourced
instance CodePtr CodePt
instance Ord CodePt


-- | Text table
module Koshucode.Baala.Base.Text.TextTable
data Position
Front :: Position
Middle :: Position
Rear :: Position
textPos :: String -> [Position]
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
cellText :: Cell -> [String]
cellWidth :: Cell -> Int
cellHeight :: Cell -> Int
cellPos :: Cell -> Position
cellPad :: Cell -> Char
textTable :: [Position] -> [[String]] -> [[Cell]]
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]
textCell :: Position -> String -> Cell
textRuleCell :: Char -> Cell
textBlockCell :: Position -> [String] -> Cell
textBlockCellPlus :: Int -> Position -> [String] -> Cell
alignTable :: [[Cell]] -> [[Cell]]
renderTable :: String -> [[Cell]] -> [String]
instance Show Position
instance Eq Position
instance Ord Position
instance Show Cell
instance Eq Cell
instance Ord Cell

module Koshucode.Baala.Base.Text.Utility
trimLeft :: Map String
trimRight :: Map String
trimBoth :: Map String

-- | Add spaces to right.
--   
--   <pre>
--   &gt;&gt;&gt; padRight 10 "abc"
--   "abc       "
--   </pre>
padRight :: Int -> Map String

-- | Add spaces to left.
--   
--   <pre>
--   &gt;&gt;&gt; padLeft 10 "abc"
--   "       abc"
--   </pre>
padLeft :: Int -> Map String
putShow :: Show a => a -> IO ()
putShowLn :: Show a => a -> IO ()
putLines :: [String] -> IO ()
readInt :: String -> Maybe Int

module Koshucode.Baala.Base.Text.Write
class Write a
write :: Write a => StringMap -> a -> Doc
type StringMap = Map String
writeH :: Write a => StringMap -> [a] -> Doc
writeV :: Write a => StringMap -> [a] -> Doc

-- | Colon-seperated document.
--   
--   <pre>
--   &gt;&gt;&gt; docBracket $ docColon [True, False]
--   [ #true : #false ]
--   </pre>
writeColon :: Write a => StringMap -> [a] -> Doc
writeBar :: Write a => StringMap -> [a] -> Doc
writeSep :: Write a => String -> StringMap -> [a] -> Doc
doc :: Write a => a -> Doc
doch :: Write a => [a] -> Doc
docv :: Write a => [a] -> Doc

-- | Wrap in open and close brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWrap "(" ")" "abc"
--   (abc)
--   </pre>
docWrap :: Write a => String -> String -> a -> Doc

-- | Wrap in open and close brackets. Put spaces between content and
--   brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWraps "(" ")" "abc"
--   ( abc )
--   </pre>
docWraps :: Write a => String -> String -> a -> Doc
instance Write a => Write (Named a)
instance Write Bool
instance Write String
instance Write Int
instance Write Doc

module Koshucode.Baala.Base.Text


-- | Abort reasons.
module Koshucode.Baala.Base.Abort.Reason
data AbortReason
AbortReason :: String -> [String] -> [String] -> [(String, CodePt)] -> AbortReason

-- | Reason in one line
abortReason :: AbortReason -> String

-- | Detailed description
abortDetail :: AbortReason -> [String]

-- | Additional notes for long description
abortNote :: AbortReason -> [String]

-- | Tag and aborting point
abortPoint :: AbortReason -> [(String, CodePt)]

-- | Abortable result, i.e., either of right result or abort reason.
type Ab a = Either AbortReason a

-- | Abortable mapping.
type AbMap a = a -> Ab a

-- | Construct abort reason with reason text.
abortBecause :: String -> AbortReason

-- | Construct abort reason with reason and detailed text.
abortLine :: String -> String -> AbortReason

-- | Construct abort reason with reason and multilined detailed text.
abortLines :: String -> [String] -> AbortReason

-- | Construct abort reason with reason and note.
abortPage :: String -> [String] -> AbortReason
instance Show AbortReason
instance Eq AbortReason
instance Ord AbortReason


-- | Abortable process
module Koshucode.Baala.Base.Abort.Abortable

-- | Push source information when process is aborted.
abortable :: CodePtr p => String -> [p] -> Map (Ab b)
abortableSourced :: String -> (a -> Ab b) -> Sourced a -> Ab (Sourced b)


-- | Reporting abort reasons.
module Koshucode.Baala.Base.Abort.Report

-- | Command name and its arguments.
type CommandLine = [String]

-- | Stop program execution abnormally.
abort :: CommandLine -> AbortReason -> IO c

-- | Stop on error <tt>'BUG DISCOVERED'</tt>
bug :: String -> a


-- | Text enclosed in angle brackets.
module Koshucode.Baala.Base.Token.AngleText

-- | Convert string into double-quoted and angle-quoted form.
angleQuote :: Map String

-- | Table of coresspondences of angle text and its replacement.
angleTexts :: [(String, String)]

module Koshucode.Baala.Base.Token.Short

-- | Something with short definition.
data Short a
Short :: [CodePt] -> [ShortDef] -> a -> Short a
shortSource :: Short a -> [CodePt]
shortHead :: Short a -> [ShortDef]
shortBody :: Short a -> a

-- | Short prefix and replacement.
type ShortDef = Named String
shortTrim :: Map [Short [a]]
shortM :: Monad m => Short (m a) -> m (Short a)
shortListM :: Monad m => [Short (m a)] -> m [Short a]

-- | String shortener with no short definition.
shortEmpty :: StringMap

-- | String shortener.
shortText :: [ShortDef] -> StringMap
isCodeText :: Pred String
isCodeChar :: Pred Char
instance Show a => Show (Short a)
instance Ord a => Ord (Short a)
instance Eq a => Eq (Short a)
instance Functor Short


-- | Tokens in Koshucode.
module Koshucode.Baala.Base.Token.Token

-- | There are ten types of tokens.
data Token

-- | Text. <a>Int</a> represents quotation level, i.e., 0 for non-quoted, 1
--   for single-quoted, 2 for double-quoted, 3 for <tt>-with</tt> variable.
TText :: CodePt -> Int -> String -> Token

-- | Blank name.
TName :: CodePt -> BlankName -> Token

-- | Slot name. <a>Int</a> represents slot level, i.e., 0 for positional
--   slots, 1 for named slots, 2 for global slots.
TSlot :: CodePt -> Int -> String -> Token

-- | Abbreviated text.
TShort :: CodePt -> String -> String -> Token

-- | Term name.
TTerm :: CodePt -> Int -> TermPath -> Token

-- | Opening bracket.
TOpen :: CodePt -> String -> Token

-- | Closing bracket.
TClose :: CodePt -> String -> Token

-- | <i>N</i> space characters.
TSpace :: CodePt -> Int -> Token

-- | Comment text.
TComment :: CodePt -> String -> Token
textToken :: String -> Token
nameToken :: String -> Token
data BlankName
BlankNormal :: String -> BlankName
BlankInternal :: String -> BlankName
BlankPrefix :: String -> BlankName
BlankInfix :: String -> BlankName
BlankPostfix :: String -> BlankName

-- | Name of term, e.g., <tt>"file"</tt> for the term name <tt>/file</tt>.
type TermName = String
type TermName2 = (String, String)
type TermName3 = (String, String, String)
type TermName4 = (String, String, String, String)

-- | Pair of term name and something.
type Terminal a = (TermName, a)

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TTerm B.codeZero ["r", "x"] in tokenContent tok
--   "/r/x"
--   </pre>
tokenContent :: Token -> String

-- | Text of token type, i.e., one of <tt>"Text"</tt>, <tt>"Term"</tt>,
--   <tt>"Open"</tt>, <tt>"Close"</tt>, <tt>"Space"</tt>, or
--   <tt>"Comment"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; tokenTypeText $ textToken "flower"
--   "Text"
--   </pre>
tokenTypeText :: Token -> String

-- | Test the token is blank, i.e., <a>TComment</a> or <a>TSpace</a>.
isBlankToken :: Pred Token
isShortToken :: Pred Token
isTermToken :: Pred Token
isOpenToken :: Pred Token
isCloseToken :: Pred Token

-- | Check token is a <a>TOpen</a> of the specific bracket.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "(" in isOpenTokenOf "(" tok
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "{" in isOpenTokenOf "(" tok
--   False
--   </pre>
isOpenTokenOf :: String -> Pred Token

-- | Check token is a <a>TClose</a> of the specific bracket.
isCloseTokenOf :: String -> Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]
instance Typeable BlankName
instance Typeable Token
instance Show BlankName
instance Eq BlankName
instance Ord BlankName
instance Data BlankName
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance Write BlankName
instance Name BlankName
instance CodePtr Token
instance Write Token
instance Name Token


-- | Abort symbols
module Koshucode.Baala.Base.Abort

module Koshucode.Baala.Base.Message
abToken :: CodePtr cp => [cp] -> Map (Ab b)

-- | AD-LIB: reason
adlib :: String -> Ab a
adlibs :: [String] -> Ab a

-- | Extra close bracket
extraCloseBracket :: Ab a

-- | Unclosed open bracket
extraOpenBracket :: Ab a

-- | Not found
notFound :: String -> Ab a

-- | Divide by zero
divideByZero :: Ab a

-- | Different decimal length
heteroDecimal :: String -> String -> Ab a

-- | Can't read as number
notNumber :: String -> Ab a

-- | Lookup association list. This function may abort.
(<!!>) :: [Named b] -> String -> Ab b

-- | Forbidden input
forbiddenInput :: String -> Ab a

-- | Forbidden term name
forbiddenTerm :: Ab a

-- | Unknown bracket text
unkAngleText :: String -> Ab a

-- | Quotation not end in line
quotNotEnd :: Ab a

module Koshucode.Baala.Base.Data.Decimal
data Decimal
Decimal :: (Int, Int) -> Int -> Bool -> Decimal
decimalRatio :: Decimal -> (Int, Int)
decimalLength :: Decimal -> Int
decimalApprox :: Decimal -> Bool
decimalNum :: Decimal -> Int
intDecimal :: Int -> Decimal
decimalSetPoint :: Int -> AbMap Decimal
decimalDenom :: Decimal -> Int
isDecimalZero :: Decimal -> Bool

-- | Make <tt>a</tt> from a string.
type LitString a = String -> Ab a
type LitDecimal = LitString Decimal
litDecimal :: LitDecimal
decimalString :: Decimal -> String
type DecimalBinary = Decimal -> Decimal -> Ab Decimal
decimalAdd :: DecimalBinary
decimalSub :: DecimalBinary
decimalMul :: DecimalBinary
decimalDiv :: DecimalBinary
decimalQuo :: DecimalBinary
decimalRem :: DecimalBinary
decimalRevsign :: Map Decimal
decimalRevratio :: Map Decimal
decimalAbs :: Map Decimal
decimalSum :: [Decimal] -> Ab Decimal
instance Show Decimal
instance Eq Decimal
instance Ord Decimal


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <a>CodeLine</a> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <a>CodeLine</a>.
module Koshucode.Baala.Base.Syntax.Code

-- | Tokens in line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
lineNumber :: CodeLine a -> LineNumber

-- | Line content without newline.
lineContent :: CodeLine a -> String

-- | Tokens in the line.
lineTokens :: CodeLine a -> [a]

-- | Tokens in clause.
data CodeClause a
CodeClause :: [CodeLine a] -> [a] -> CodeClause a

-- | Source lines of clause
clauseLines :: CodeClause a -> [CodeLine a]

-- | Source tokens of clause
clauseTokens :: CodeClause a -> [a]
lineIndentPair :: (a -> Int) -> CodeLine a -> (Int, CodeLine a)
splitClause :: Gather [(Int, a)] [a]
data CodeRoll a
CodeRoll :: AbMap (CodeRoll a) -> CodePt -> String -> [a] -> CodeRoll a
codeMap :: CodeRoll a -> AbMap (CodeRoll a)
codeInputPt :: CodeRoll a -> CodePt
codeInput :: CodeRoll a -> String
codeOutput :: CodeRoll a -> [a]

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><a>LineNumber</a><tt>,</tt>
--   <a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeRollUp :: AbMap (CodeRoll a) -> Resource -> String -> Ab [CodeLine a]
codeUpdate :: String -> a -> Map (CodeRoll a)
codeChange :: AbMap (CodeRoll a) -> Map (CodeRoll a)
instance Typeable1 CodeLine
instance Typeable1 CodeClause
instance Show a => Show (CodeLine a)
instance Eq a => Eq (CodeLine a)
instance Ord a => Ord (CodeLine a)
instance Data a => Data (CodeLine a)
instance Show a => Show (CodeClause a)
instance Data a => Data (CodeClause a)
instance CodePtr a => CodePtr (CodeClause a)
instance CodePtr a => CodePtr (CodeLine a)
instance Write (CodeLine a)

module Koshucode.Baala.Base.Syntax.Tree
data Bracket p
BracketNone :: Bracket p
BracketOpen :: p -> Bracket p
BracketClose :: p -> Bracket p

-- | Tree of leaf and branch.
data CodeTree p a

-- | Leaf. Terminal of tree.
TreeL :: a -> CodeTree p a

-- | Branch. Bracket-type and subtrees.
TreeB :: p -> (Maybe (a, a)) -> [CodeTree p a] -> CodeTree p a

-- | Convert a list of elements to a single tree.
tree :: (Ord p, CodePtr a) => GetBracketType p a -> Bracket p -> p -> [a] -> Ab (CodeTree p a)

-- | Convert a list of elements to trees.
trees :: (Ord p, CodePtr a) => GetBracketType p a -> Bracket p -> [a] -> Ab [CodeTree p a]
treeWrap :: p -> [CodeTree p a] -> CodeTree p a

-- | Convert tree to list of tokens.
untree :: CodeTree p a -> [a]

-- | Convert tree to list of tokens.
untrees :: [CodeTree p a] -> [a]

-- | Simplify tree by removing double brackets, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Pred p -> Map (CodeTree p a)

-- | Get a bracket type.
type GetBracketType p a = a -> Bracket p

-- | Make <a>GetBracketType</a> functions from a type-open-close table.
--   
--   Make bracket/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let bracket n [a, b] = (n, (== a), (== b))
--   
--   &gt;&gt;&gt; let pt = bracketTable [ bracket 1 "()", bracket 2 "[]" ]
--   </pre>
--   
--   Get bracket types for each chars. Types of open brackets are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0, 0, 1, 0, 0, 2, 0, 0, -2, -1, 0]
--   </pre>
bracketTable :: Eq a => [(p, Pred a, Pred a)] -> GetBracketType p a
instance Typeable1 Bracket
instance Typeable2 CodeTree
instance Show p => Show (Bracket p)
instance Eq p => Eq (Bracket p)
instance Ord p => Ord (Bracket p)
instance Data p => Data (Bracket p)
instance (Show p, Show a) => Show (CodeTree p a)
instance (Eq p, Eq a) => Eq (CodeTree p a)
instance (Ord p, Ord a) => Ord (CodeTree p a)
instance (Data p, Data a) => Data (CodeTree p a)
instance Functor (CodeTree p)


-- | Convert infixed-operator trees into prefixed-operator trees.
module Koshucode.Baala.Base.Syntax.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
infixHeight :: Ord b => (a -> Maybe b) -> [(b, InfixHeight)] -> a -> InfixHeight

-- | Split branches in a given tree at infixed binary operators.
infixToPrefix :: (Map a, Map a, Map a) -> (a -> InfixHeight) -> Collect (InfixTree p a) -> InfixMapper p a -> InfixAbMap a (CodeTree p a)
type InfixAb a x = Either [(InfixHeight, a)] x
type InfixAbMap a x = x -> InfixAb a x
type InfixTree p a = CodeTree p (InfixHeight, a)
type InfixMapper p a = InfixAbMap a [InfixTree p a] -> InfixAbMap a (InfixTree p a)


-- | Syntactic functions.
module Koshucode.Baala.Base.Syntax


-- | Tokenizer of koshucode.
module Koshucode.Baala.Base.Token.TokenLine

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Tokenize text.
tokenLines :: Resource -> String -> Ab [TokenLine]

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: Resource -> String -> Ab [Token]
isShortPrefix :: Pred String

module Koshucode.Baala.Base.Token.TokenClause
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]
instance Write TokenClause


-- | Tree of tokens
module Koshucode.Baala.Base.Token.TokenTree

-- | Tree of tokens.
type TokenTree = CodeTree BracketType Token

-- | Pair of token tree and its name.
type NamedTree = Named TokenTree

-- | Pair of token trees and its name.
type NamedTrees = Named [TokenTree]

-- | Convert token tree to something.
type TokenTreeTo a = TokenTree -> a

-- | Convert list of token tree to sometning.
type TokenTreesTo a = [TokenTree] -> a

-- | Convert token tree to something, abortable.
type TokenTreeToAb a = TokenTree -> Ab a

-- | Convert list of token tree to sometning, abortable.
type TokenTreesToAb a = [TokenTree] -> Ab a

-- | Parse tokens with brackets into trees. Blank tokens and comments are
--   excluded.
tokenTrees :: [Token] -> Ab [TokenTree]

-- | Wrap trees in group.
wrapTrees :: TokenTreesTo TokenTree

-- | There are six types of brackets
data BracketType

-- | Round brackets for grouping: <tt>( E ... )</tt>
BracketGroup :: BracketType

-- | Round-bar brackets for form with blanks: <tt>(| V ... | E ... |)</tt>
BracketForm :: BracketType

-- | Square brackets for lists: <tt>[ C : ... ]</tt>
BracketList :: BracketType

-- | Curely braces for sets: <tt>{ C : .... }</tt>
BracketSet :: BracketType

-- | Curely-bar braces for relations: <tt>{| /N : ... | C : ... | C : ...
--   |}</tt>
BracketRel :: BracketType

-- | Double-angle brackets for associations etc.: <tt>&lt;&lt; /N C ....
--   &gt;&gt;</tt>
BracketAssn :: BracketType

-- | Triple-angle brackets for data interpretation: <tt>&lt;&lt;&lt; ... /N
--   ... &gt;&gt;&gt;</tt>
BracketInterp :: BracketType

-- | Square-hyphen brackets for data type: <tt>[- ... -]</tt>
BracketType :: BracketType

-- | Unknown bracket
BracketUnknown :: BracketType

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "b c"
--   Left [ TText 1 0 "b", TSpace 2 1, TText 3 0 "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "a | b | c"
--   Right ( [ TText 1 0 "a", TSpace 2 1 ]
--           , TText 3 0 "|"
--           , [ TSpace 4 1, TText 5 0 "b", TSpace 6 1
--             , TText 7 0 "|", TSpace 8 1, TText 9 0 "c" ] )
--   </pre>
splitTokensBy :: Pred String -> [Token] -> Either [Token] ([Token], Token, [Token])

-- | Divide token trees by quoteless token of given string.
divideTreesBy :: String -> TokenTreesTo [[TokenTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
divideTreesByBar :: TokenTreesTo [[TokenTree]]

-- | Divide token trees by colon <tt>":"</tt>.
divideTreesByColon :: TokenTreesTo [[TokenTree]]

-- | Divide token trees by equal sign <tt>"="</tt>.
divideTreesByEqual :: TokenTreesTo [[TokenTree]]

-- | Same as <tt>abortable</tt> except for using <a>TokenTree</a> instead
--   of list of <a>Token</a>.
abortableTree :: String -> TokenTreeTo (Map (Ab b))

-- | Same as <tt>abortable</tt> except for using list of <a>TokenTree</a>
--   instead of list of <a>Token</a>.
abortableTrees :: String -> TokenTreesTo (Map (Ab b))

-- | Convert text to token trees.
tt :: String -> Ab [TokenTree]
tt1 :: String -> Ab TokenTree

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: TokenTreesTo Doc
ttPrint :: String -> IO ()
instance Typeable BracketType
instance Show BracketType
instance Eq BracketType
instance Ord BracketType
instance Data BracketType


-- | Tokens in Koshucode.
module Koshucode.Baala.Base.Token

module Koshucode.Baala.Base.Data.Interp
data Interp
Interp :: [InterpWord] -> [TermName] -> Interp
interpWords :: Interp -> [InterpWord]
interpTerms :: Interp -> [TermName]
data InterpWord
InterpText :: String -> InterpWord
InterpTerm :: TermName -> InterpWord
interp :: [InterpWord] -> Interp
instance Show InterpWord
instance Eq InterpWord
instance Ord InterpWord
instance Show Interp
instance Eq Interp
instance Ord Interp
instance Write InterpWord
instance Write Interp


-- | Term names in relation.
module Koshucode.Baala.Base.Data.Term
data Term

-- | Term name for non-relation
TermFlat :: TermName -> Term

-- | Term name for relation
TermNest :: TermName -> [Term] -> Term

-- | Test that term is nested.
isTermNest :: Term -> Bool

-- | Get name part from term.
termName :: Term -> TermName

-- | Get nested part from term.
termNest :: Term -> [Term]
termExplainDoc :: Term -> Doc
showTermName :: Map String
showNestedTermName :: [String] -> String
termChange :: (Map TermName) -> Map Term
termsIndex :: [Term] -> [TermPath] -> [[Int]]

-- | Term path to term position
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [TermFlat "a", TermFlat "b", TermFlat "c"] ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [TermFlat "a", TermFlat "b", TermFlat "c"] ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [TermNest "r" [TermFlat "a", TermFlat "b"]] ["r", "b"]
--   [0, 1]
--   </pre>
termIndex :: [Term] -> TermPath -> [Int]
instance Show Term
instance Eq Term
instance Ord Term
instance Write Term
instance Name Term


-- | Heading of relations
module Koshucode.Baala.Base.Data.Relhead

-- | Heading of relation as a list of terms
data Relhead
Relhead :: [Term] -> Relhead
headTerms :: Relhead -> [Term]
headExplain :: Relhead -> String
headExplainLines :: Relhead -> [String]
headExplainDoc :: Relhead -> Doc

-- | Empty heading, i.e., no terms in heading.
headEmpty :: Relhead

-- | Make head from term names.
headFrom :: [TermName] -> Relhead
headWords :: String -> Relhead

-- | List of term names.
headNames :: Relhead -> [TermName]

-- | Degree of relation, i.e., number of terms.
headDegree :: Relhead -> Int
headEquiv :: Relhead -> Relhead -> Bool
isSubhead :: Relhead -> Relhead -> Bool
isSuperhead :: Relhead -> Relhead -> Bool
headConsTerm :: Term -> Map Relhead

-- | Add term to head.
headCons :: TermName -> Map Relhead
headCons2 :: TermName2 -> Map Relhead
headCons3 :: TermName3 -> Map Relhead

-- | Add any number of terms to head.
headAppend :: [TermName] -> Map Relhead

-- | Reconstruct head.
headChange :: Map [Term] -> Map Relhead
headRename :: Map TermName -> Map Relhead

-- | Index of a term.
headIndex1 :: Relhead -> TermPath -> [Int]

-- | Indices of terms.
headIndex :: Relhead -> [TermPath] -> [[Int]]
headAlign :: Relhead -> Relhead -> Map [c]
bodyAlign :: Relhead -> Relhead -> Map [[c]]
headNested :: Relhead -> [(String, Relhead)]
instance Show Relhead
instance Eq Relhead
instance Ord Relhead
instance Write Relhead
instance Monoid Relhead


-- | Relation type
module Koshucode.Baala.Base.Data.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Relhead -> Relbody c -> Rel c

-- | Heading of relation
relHead :: Rel c -> Relhead

-- | Body of relation
relBody :: Rel c -> Relbody c

-- | Body of relation, i.e., a list of tuples. Tuple is list of contents.
type Relbody c = [[c]]
type MapRel c = Map (Rel c)
relSort :: Ord c => Map (Rel c)

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c
instance Show c => Show (Rel c)
instance Ord c => Ord (Rel c)
instance Write c => Write (Rel c)
instance Ord c => Eq (Rel c)


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Base.Data.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of pattern, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement pattern represents certain sentence pattern
--   that gives intepretation of data. Sentence pattern has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c
JudgeAffirm :: JudgePat -> [Named c] -> Judge c
JudgeDeny :: JudgePat -> [Named c] -> Judge c
JudgeViolate :: JudgePat -> [Named c] -> Judge c
JudgeAlter :: JudgePat -> [Named c] -> [Named c] -> [Named c] -> Judge c
type JudgeOf c = JudgePat -> [Named c] -> Judge c

-- | Name of judgement pattern.
type JudgePat = String
judgePat :: Judge c -> JudgePat
judgeTerms :: Judge c -> [Named c]
judgeTermsMap :: ([Named a] -> [Named b]) -> Judge a -> Judge b
judgeCons :: Named c -> Map (Judge c)

-- | Convert relation to list of judges.
judgesFromRel :: JudgeOf c -> JudgePat -> Rel c -> [Judge c]

-- | Sort terms in alphabetical order.
abcJudge :: Ord c => Map (Judge c)

-- | Construct affirmative judgement.
affirm :: JudgeOf c

-- | Construct denial judgement.
deny :: JudgeOf c

-- | Affirm judgement, i.e., change logical quality to affirmative.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to denial.
denyJudge :: Map (Judge c)

-- | Test that judgement is affirmd.
isAffirmative :: Judge c -> Bool

-- | Test that judgement is denied.
isDenial :: Judge c -> Bool
isViolative :: Judge c -> Bool
instance Show c => Show (Judge c)
instance (Ord c, Write c) => Write (Judge c)
instance Functor Judge
instance Ord c => Ord (Judge c)
instance Ord c => Eq (Judge c)


-- | Output judgements.
module Koshucode.Baala.Base.Data.Output
type OutputResult c = ([OutputChunks c], [OutputChunks c])
type OutputChunks c = Short [OutputChunk c]
data OutputChunk c
OutputJudge :: [Judge c] -> OutputChunk c
OutputComment :: [String] -> OutputChunk c

-- | Print judges to <a>stdout</a>.
putJudges :: (Ord c, Write c) => Int -> [Judge c] -> IO Int
hPutJudges :: (Ord c, Write c) => Handle -> Int -> [Judge c] -> IO Int

-- | Print result of calculation, and return status.
hPutOutputResult :: (Ord c, Write c) => Handle -> OutputResult c -> IO Int
instance Show c => Show (OutputChunk c)
instance Ord c => Eq (OutputChunk c)
instance Ord c => Ord (OutputChunk c)


-- | Content type for nested relations.
module Koshucode.Baala.Base.Data.Mono
data Mono a
MonoType :: a -> Mono a
MonoNest :: (Rel (Mono a)) -> Mono a
type RelText = Rel (Mono String)
isMonoType :: Mono a -> Bool
isMonoNest :: Mono a -> Bool
gMonoType :: Mono a -> a
gMonoNest :: Mono a -> Rel (Mono a)
pMonoNest :: Rel (Mono a) -> Mono a
pMonoType :: a -> Mono a
instance Show a => Show (Mono a)
instance Ord a => Eq (Mono a)
instance Ord a => Ord (Mono a)

module Koshucode.Baala.Base.Data.Type
data Type
TypeEmpty :: Type
TypeBool :: Type
TypeText :: Type
TypeRel :: [(TermName, Type)] -> Type
TypeSum :: [Type] -> Type
instance Show Type
instance Eq Type
instance Ord Type
instance Write Type


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Base.Data

module Koshucode.Baala.Base
