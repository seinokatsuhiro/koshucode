-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.59.0.0

module Koshucode.Baala.Base.Text.Unicode
data GeneralCategoryGroup

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: GeneralCategoryGroup

-- | Mn Mc Me
UnicodeMark :: GeneralCategoryGroup

-- | Nd Nl No
UnicodeNumber :: GeneralCategoryGroup

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: GeneralCategoryGroup

-- | Sm Sc Sk So
UnicodeSymbol :: GeneralCategoryGroup

-- | Zs Zl Zp
UnicodeSeperator :: GeneralCategoryGroup

-- | Cc Cf Cs Co Cn
UnicodeOther :: GeneralCategoryGroup
generalCategoryLetter :: GeneralCategoryGroup -> Char
generalCategoryGroup :: Char -> GeneralCategoryGroup
instance Show GeneralCategoryGroup
instance Eq GeneralCategoryGroup
instance Ord GeneralCategoryGroup
instance Bounded GeneralCategoryGroup

module Koshucode.Baala.Base.Text.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec
emacsModeComment :: String
commentLine :: String -> String
putCommentLines :: [String] -> IO ()
hPutCommentLines :: Handle -> [String] -> IO ()
instance Show CommentSec
instance Eq CommentSec
instance Ord CommentSec
instance Show CommentDoc
instance Eq CommentDoc
instance Ord CommentDoc
instance Texts CommentSec
instance Texts CommentDoc


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Syntax.Line

-- | Line number.
type LineNumber = Int
type NumberedLine = (LineNumber, String)

-- | Line number and its content.
linesCrlfNumbered :: String -> [NumberedLine]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
linesCrlf :: String -> [String]

module Koshucode.Baala.Base.Prelude.Import

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | Same as <a>lookup</a> in <tt>Data.Map</tt> module.
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
catMaybes :: [Maybe a] -> [a]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
fromMaybe :: a -> Maybe a -> a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc
docEmpty :: Doc
docHang :: Doc -> Int -> Doc -> Doc
docZero :: String -> Doc


-- | General utilities
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)
named :: Name a => a -> Named a
type Map a = a -> a
type Pred a = a -> Bool
data YesNo a
Yes :: a -> YesNo a
No :: a -> YesNo a
instance Show a => Show (YesNo a)
instance Eq a => Eq (YesNo a)
instance Ord a => Ord (YesNo a)


-- | Snipping elements.
module Koshucode.Baala.Base.Prelude.Snip
type Snip a = [Int] -> Map [a]
type SnipPair a b = (Snip a, Snip b)
snipFull :: Eq a => [a] -> [a] -> [Int]

-- | Indices of shared elements.
snipIndex :: Eq a => [a] -> [a] -> [Int]
snipPair :: Ord a => [a] -> [a] -> ([Int], [Int])

-- | Pair of picking-up and cutting-off elements.
snipBoth :: [Int] -> [a] -> ([a], [a])

-- | Pick up indexed elements.
snipFrom :: Snip a

-- | Cut off indexed elements.
snipOff :: Snip a

-- | Move indexed elements to the front.
snipFore :: Snip a
snipFore2 :: SnipPair a b

-- | Take left-side elements.
snipLeft :: Eq a => [a] -> [a] -> [a]

-- | Take shared elements.
snipShare :: Eq a => [a] -> [a] -> [a]

-- | Take right-side elements.
snipRight :: Eq a => [a] -> [a] -> [a]
snipOrder :: Eq a => [a] -> [a] -> Map [c]

-- | Check lengths of two lists are same.
sameLength :: [a] -> [b] -> Bool
notSameLength :: [a] -> [b] -> Bool

-- | Check elements in the first list are non-negative, and elements in the
--   second are negative.
operand :: [Int] -> [Int] -> Bool


-- | General utilities
module Koshucode.Baala.Base.Prelude.Utility
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
cons1 :: a -> ([a], b) -> ([a], b)
mapFstTo :: Functor m => (a -> c) -> m (a, b) -> m (c, b)
mapSndTo :: Functor m => (b -> c) -> m (a, b) -> m (a, c)
maybePairs :: [a] -> Maybe [(a, a)]
sequenceSnd :: Monad m => [(a, m b)] -> m [(a, b)]
front :: [a] -> [a]
omit :: (a -> Bool) -> [a] -> [a]
duplicates :: Ord a => [a] -> [a]

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Union list to base list.
--   
--   <pre>
--   &gt;&gt;&gt; unionUp "cde" "abc"
--   "deabc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; List.union "cde" "abc"
--   "cdeab"
--   </pre>
unionUp :: Eq a => [a] -> [a] -> [a]

-- | Make singleton list.
singleton :: a -> [a]
isSingleton :: [a] -> Bool

-- | Split list by predicate. If list contains an element that satisfies
--   the predicate, <tt>(<i>before-list</i>, <i>the-element</i>,
--   <i>after-list</i>)</tt> is returned. Otherwise, original list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "b c"
--   Left "b c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitBy (== '|') "a | b | c"
--   Right ("a ", '|', " b | c")
--   </pre>
splitBy :: (a -> Bool) -> [a] -> Either [a] ([a], a, [a])

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divide '|' "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divide :: Eq a => a -> [a] -> [[a]]

-- | Divide list.
--   
--   <pre>
--   &gt;&gt;&gt; divideBy (== '|') "a|bb||ccc|"
--   ["a", "bb", "", "ccc", ""]
--   </pre>
divideBy :: (a -> Bool) -> [a] -> [[a]]
maybeEmpty :: Maybe a -> (a -> [b]) -> [b]
squeeze :: (a -> Bool) -> Map [a]
squeezeEmptyLines :: Map [String]
mapWithLast :: (a -> b) -> (a -> b) -> [a] -> [b]
notNull :: [a] -> Bool

module Koshucode.Baala.Base.Prelude.Order
data OrderCap a
Asc :: a -> OrderCap a
Desc :: a -> OrderCap a
type Ranking n a = Int -> [OrderCap n] -> [n] -> [[a]] -> ([Int], [[a]])
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
instance Show a => Show (OrderCap a)
instance Eq a => Eq (OrderCap a)
instance Ord a => Ord (OrderCap a)


-- | Utilities for association lists.
module Koshucode.Baala.Base.Prelude.Assoc
type Lookup a = String -> Maybe a

-- | Construct assoc list by splitting base list.
assocBy :: (a -> Maybe k) -> k -> [a] -> [(k, [a])]

-- | Check which given key is there in assoc list.
assocExist :: Eq k => k -> [(k, a)] -> Bool
namedMapM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)

-- | Lookup assoc list that keys are truth-valued functions.
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b

-- | Pick up associations that have given keys.
assocPick :: Eq k => [k] -> Map [(k, a)]

-- | Cut off associations that have given keys.
assocCut :: Eq k => [k] -> Map [(k, a)]
assocCut1 :: Eq k => k -> Map [(k, a)]
assocRename1 :: Eq k => k -> k -> Map [(k, a)]
assocRehead :: Eq k => [(k, k)] -> [(k, v)] -> [(k, v)]
data OnceMore a
Once :: a -> OnceMore a
More :: [a] -> OnceMore a

-- | Convert general assoc list into once/more assoc list.
assocGather :: Eq k => [(k, a)] -> [(k, OnceMore a)]

-- | Push key and value into once/more assoc list.
assocPush :: Eq k => k -> a -> Map [(k, OnceMore a)]

-- | Extract once part from once/more assoc list.
assocOnce :: [(k, OnceMore a)] -> [(k, a)]

-- | Extract more part from once/more assoc list.
assocMore :: [(k, OnceMore a)] -> [(k, [a])]
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]
gatherWith :: (c -> Gather [a] b) -> [c] -> [a] -> [b]

-- | Gather (<i>key</i>, <i>value</i>) to <tt>Map</tt> <i>key</i>
--   [<i>value</i>].
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
duplicate :: Ord k => [k] -> [k]
instance Show a => Show (OnceMore a)
instance Eq a => Eq (OnceMore a)
instance Ord a => Ord (OnceMore a)

module Koshucode.Baala.Base.Prelude

module Koshucode.Baala.Base.Text.Resource
data Resource
ResourceFile :: String -> Resource
ResourceText :: String -> Resource
ResourceURL :: String -> Resource
resourceType :: Resource -> String
resourceName :: Resource -> String
data CodePoint
CodePoint :: Resource -> Int -> String -> String -> CodePoint

-- | Resource of code
codePointResource :: CodePoint -> Resource

-- | Line number
codePointLineNumber :: CodePoint -> Int

-- | Line content
codePointLineText :: CodePoint -> String

-- | Text at which begins token
codePointText :: CodePoint -> String
class CodePointer a
codePoint :: CodePointer a => a -> [CodePoint]
codePointColumn :: CodePoint -> Int
codePointDisplay :: String -> CodePoint -> [(String, String)]
codePointZero :: CodePoint
data Sourced a
Sourced :: [CodePoint] -> a -> Sourced a
source :: Sourced a -> [CodePoint]
unsourced :: Sourced a -> a
instance Typeable Resource
instance Typeable CodePoint
instance Typeable1 Sourced
instance Show Resource
instance Eq Resource
instance Ord Resource
instance Data Resource
instance Show CodePoint
instance Eq CodePoint
instance Data CodePoint
instance Show a => Show (Sourced a)
instance Eq a => Eq (Sourced a)
instance Ord a => Ord (Sourced a)
instance Data a => Data (Sourced a)
instance CodePointer (Sourced a)
instance Functor Sourced
instance CodePointer CodePoint
instance Ord CodePoint


-- | Text table
module Koshucode.Baala.Base.Text.TextTable
data Position
Front :: Position
Middle :: Position
Rear :: Position
textPos :: String -> [Position]
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
cellText :: Cell -> [String]
cellWidth :: Cell -> Int
cellHeight :: Cell -> Int
cellPos :: Cell -> Position
cellPad :: Cell -> Char
textTable :: [Position] -> [[String]] -> [[Cell]]
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]
textCell :: Position -> String -> Cell
textRuleCell :: Char -> Cell
textBlockCell :: Position -> [String] -> Cell
textBlockCellPlus :: Int -> Position -> [String] -> Cell
alignTable :: [[Cell]] -> [[Cell]]
renderTable :: String -> [[Cell]] -> [String]
instance Show Position
instance Eq Position
instance Ord Position
instance Show Cell
instance Eq Cell
instance Ord Cell

module Koshucode.Baala.Base.Text.Utility
trimLeft :: Map String
trimRight :: Map String
trimBoth :: Map String

-- | Add spaces to right.
--   
--   <pre>
--   &gt;&gt;&gt; padRight 10 "abc"
--   "abc       "
--   </pre>
padRight :: Int -> Map String

-- | Add spaces to left.
--   
--   <pre>
--   &gt;&gt;&gt; padLeft 10 "abc"
--   "       abc"
--   </pre>
padLeft :: Int -> Map String
putShow :: Show a => a -> IO ()
putShowLn :: Show a => a -> IO ()
putLines :: [String] -> IO ()

module Koshucode.Baala.Base.Text.Write
class Write a
write :: Write a => StringMap -> a -> Doc
type StringMap = Map String
writeH :: Write a => StringMap -> [a] -> Doc
writeV :: Write a => StringMap -> [a] -> Doc

-- | Colon-seperated document.
--   
--   <pre>
--   &gt;&gt;&gt; docBracket $ docColon [True, False]
--   [ #true : #false ]
--   </pre>
writeColon :: Write a => StringMap -> [a] -> Doc
doc :: Write a => a -> Doc
doch :: Write a => [a] -> Doc
docv :: Write a => [a] -> Doc

-- | Wrap in open and close brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWrap "(" ")" "abc"
--   (abc)
--   </pre>
docWrap :: Write a => String -> String -> a -> Doc

-- | Wrap in open and close brackets. Put spaces between content and
--   brackets.
--   
--   <pre>
--   &gt;&gt;&gt; docWraps "(" ")" "abc"
--   ( abc )
--   </pre>
docWraps :: Write a => String -> String -> a -> Doc
instance Write a => Write (Named a)
instance Write Bool
instance Write String
instance Write Int
instance Write Doc

module Koshucode.Baala.Base.Text


-- | Abort reasons.
module Koshucode.Baala.Base.Abort.Reason
data AbortReason
AbortReason :: String -> [String] -> [String] -> [(String, CodePoint)] -> AbortReason

-- | Reason in one line
abortReason :: AbortReason -> String

-- | Detailed description
abortDetail :: AbortReason -> [String]

-- | Additional notes for long description
abortNote :: AbortReason -> [String]

-- | Tag and aborting point
abortPoint :: AbortReason -> [(String, CodePoint)]

-- | Abortable result, i.e., either of right result or abort reason.
type Ab a = Either AbortReason a

-- | Abortable mapping.
type AbMap a = a -> Ab a

-- | Construct abort reason with reason text.
abortBecause :: String -> AbortReason

-- | Construct abort reason with reason and detailed text.
abortLine :: String -> String -> AbortReason

-- | Construct abort reason with reason and multilined detailed text.
abortLines :: String -> [String] -> AbortReason

-- | Construct abort reason with reason and note.
abortPage :: String -> [String] -> AbortReason
instance Show AbortReason
instance Eq AbortReason
instance Ord AbortReason


-- | Abortable process
module Koshucode.Baala.Base.Abort.Abortable

-- | Push source information when process is aborted.
abortable :: CodePointer p => String -> [p] -> Map (Ab b)
abortableSourced :: String -> (a -> Ab b) -> Sourced a -> Ab (Sourced b)


-- | Reporting abort reasons.
module Koshucode.Baala.Base.Abort.Report

-- | Command name and its arguments.
type CommandLine = [String]

-- | Stop program execution abnormally.
abort :: CommandLine -> AbortReason -> IO c

-- | Stop on error <tt>'BUG DISCOVERED'</tt>
bug :: String -> a


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <a>CodeLine</a> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <a>CodeLine</a>.
module Koshucode.Baala.Base.Syntax.Code

-- | Tokens in line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
lineNumber :: CodeLine a -> LineNumber

-- | Line content without newline.
lineContent :: CodeLine a -> String

-- | Tokens in the line.
lineTokens :: CodeLine a -> [a]
lineNumberContent :: CodeLine a -> String

-- | Tokens in clause.
data CodeClause a
CodeClause :: [CodeLine a] -> [a] -> CodeClause a

-- | Source lines of clause
clauseLines :: CodeClause a -> [CodeLine a]

-- | Source tokens of clause
clauseTokens :: CodeClause a -> [a]
indentLineBy :: (a -> Int) -> CodeLine a -> (Int, CodeLine a)
splitClause :: Gather [(Int, a)] [a]

-- | Type of function that splits a next token from string. Tokens can
--   includes <tt>TokenNumber</tt>.
type NextToken a = NumberedLine -> Gather String a

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><tt>LineNumber</tt><tt>,</tt>
--   <a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeLines :: NextToken a -> String -> [CodeLine a]
instance Typeable1 CodeLine
instance Typeable1 CodeClause
instance Show a => Show (CodeLine a)
instance Eq a => Eq (CodeLine a)
instance Ord a => Ord (CodeLine a)
instance Data a => Data (CodeLine a)
instance Show a => Show (CodeClause a)
instance Data a => Data (CodeClause a)
instance CodePointer a => CodePointer (CodeClause a)
instance CodePointer a => CodePointer (CodeLine a)
instance Write (CodeLine a)

module Koshucode.Baala.Base.Token.HashWord

-- | Table of coresspondences of hashed sequence and its text.
--   
--   <pre>
--   &gt;&gt;&gt; lookup "lf" hashWordTable
--   Just "\n"
--   </pre>
hashWordTable :: [(String, String)]

-- | Convert string into hashed form.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa"
--   "aaa"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ hashWord "aaa\nbbb"
--   "aaa" #lf "bbb"
--   </pre>
hashWord :: Map String


-- | Tokens in Koshucode.
module Koshucode.Baala.Base.Token.Token

-- | There are nine types of tokens.
data Token

-- | Word. <a>Int</a> represents quotation level, i.e., 0 for non-quoted, 1
--   for single-quoted, 2 for double-quoted, 3 for <tt>-with</tt> variable.
TWord :: CodePoint -> Int -> String -> Token

-- | Slot name. <a>Int</a> represents slot level, i.e., 0 for positional
--   slots, 1 for named slots, 2 for global slots.
TSlot :: CodePoint -> Int -> String -> Token

-- | Abbreviated word.
TShort :: CodePoint -> String -> String -> Token

-- | Term name.
TTerm :: CodePoint -> TermPath -> Token

-- | Opening paren.
TOpen :: CodePoint -> String -> Token

-- | Closing paren.
TClose :: CodePoint -> String -> Token

-- | <i>N</i> space characters.
TSpace :: CodePoint -> Int -> Token

-- | Comment text.
TComment :: CodePoint -> String -> Token

-- | Unknown text.
TUnknown :: CodePoint -> String -> Token
tokenWord :: String -> Token

-- | Name of term, e.g., <tt>"file"</tt> for the term name <tt>/file</tt>.
type TermName = String
type TermName2 = (String, String)
type TermName3 = (String, String, String)
type TermName4 = (String, String, String, String)

-- | Pair of term name and something.
type Terminal a = (TermName, a)

-- | Path of term names, e.g., term name <tt>/r/x</tt> is correspond to
--   path <tt>["r", "x"]</tt>.
type TermPath = [TermName]

-- | Get the content of token.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TTerm 20 ["/r", "/x"] in tokenContent tok
--   "/r/x"
--   </pre>
tokenContent :: Token -> String

-- | Text of token type, i.e., one of <tt>"Word"</tt>, <tt>"Term"</tt>,
--   <tt>"Open"</tt>, <tt>"Close"</tt>, <tt>"Space"</tt>,
--   <tt>"Comment"</tt>, or <tt>"Unknown"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; tokenTypeText $ TWord 25 0 "flower"
--   "Word"
--   </pre>
tokenTypeText :: Token -> String

-- | Test the token is blank, i.e., <a>TComment</a> or <a>TSpace</a>.
isBlankToken :: Pred Token
isShortToken :: Pred Token

-- | Check token is a <a>TOpen</a> of the specific paren.
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "(" in isOpenTokenOf "(" tok
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let tok = TOpen 0 "{" in isOpenTokenOf "(" tok
--   False
--   </pre>
isOpenTokenOf :: String -> Pred Token

-- | Check token is a <a>TClose</a> of the specific paren.
isCloseTokenOf :: String -> Pred Token

-- | Remove blank tokens.
sweepToken :: Map [Token]
tokenIndent :: Token -> Int
instance Typeable Token
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance CodePointer Token
instance Write Token
instance Name Token


-- | Abort symbols
module Koshucode.Baala.Base.Abort

module Koshucode.Baala.Base.Message

-- | AD-LIB: reason
adlib :: String -> Ab a

-- | Extra close paren
extraCloseParen :: Ab a

-- | Unclosed open paren
extraOpenParen :: Ab a

-- | Not found
notFound :: String -> Ab a

-- | Divide by zero
divideByZero :: Ab a

-- | Different decimal length
heteroDecimal :: String -> String -> Ab a

-- | Can't read as number
notNumber :: String -> Ab a

-- | Lookup association list. This function may abort.
(<!!>) :: [Named b] -> String -> Ab b

module Koshucode.Baala.Base.Data.Decimal
data Decimal
Decimal :: (Int, Int) -> Int -> Bool -> Decimal
decimalRatio :: Decimal -> (Int, Int)
decimalLength :: Decimal -> Int
decimalApprox :: Decimal -> Bool
decimalNum :: Decimal -> Int
intDecimal :: Int -> Decimal
decimalSetPoint :: Int -> AbMap Decimal
decimalDenom :: Decimal -> Int
isDecimalZero :: Decimal -> Bool

-- | Make <tt>a</tt> from a string.
type LitString a = String -> Ab a
type LitDecimal = LitString Decimal
litDecimal :: LitDecimal
decimalString :: Decimal -> String
type DecimalBinary = Decimal -> Decimal -> Ab Decimal
decimalAdd :: DecimalBinary
decimalSub :: DecimalBinary
decimalMul :: DecimalBinary
decimalDiv :: DecimalBinary
decimalQuo :: DecimalBinary
decimalRem :: DecimalBinary
decimalRevsign :: Map Decimal
decimalRevratio :: Map Decimal
decimalAbs :: Map Decimal
decimalSum :: [Decimal] -> Ab Decimal
instance Show Decimal
instance Eq Decimal
instance Ord Decimal

module Koshucode.Baala.Base.Syntax.Tree

-- | Tree of leaf and branch.
data CodeTree a

-- | Leaf. Terminal of tree.
TreeL :: a -> CodeTree a

-- | Branch. Paren-type and subtrees.
TreeB :: ParenType -> (Maybe (a, a)) -> [CodeTree a] -> CodeTree a

-- | Convert a list of elements to a single tree.
tree :: CodePointer a => GetParenType a -> [a] -> Ab (CodeTree a)

-- | Convert a list of elements to trees.
trees :: CodePointer a => GetParenType a -> [a] -> Ab [CodeTree a]
treeWrap :: [CodeTree a] -> CodeTree a

-- | Convert tree to list of tokens.
untree :: CodeTree a -> [a]

-- | Convert tree to list of tokens.
untrees :: [CodeTree a] -> [a]

-- | Simplify tree by removing double parens, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Pred ParenType -> Map (CodeTree a)
type ParenType = Int

-- | Get a paren type.
type GetParenType a = a -> ParenType

-- | Make <a>GetParenType</a> functions from a type-open-close table.
--   
--   Make paren/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let paren n [a, b] = (n, (== a), (== b))
--   
--   &gt;&gt;&gt; let pt = parenTable [ paren 1 "()", paren 2 "[]" ]
--   </pre>
--   
--   Get paren types for each chars. Types of open parens are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0, 0, 1, 0, 0, 2, 0, 0, -2, -1, 0]
--   </pre>
parenTable :: Eq a => [(ParenType, Pred a, Pred a)] -> GetParenType a
instance Typeable1 Paren
instance Typeable1 CodeTree
instance Show a => Show (Paren a)
instance Eq a => Eq (Paren a)
instance Ord a => Ord (Paren a)
instance Data a => Data (Paren a)
instance Show a => Show (CodeTree a)
instance Eq a => Eq (CodeTree a)
instance Ord a => Ord (CodeTree a)
instance Data a => Data (CodeTree a)
instance Functor CodeTree


-- | Convert infixed-operator trees into prefixed-operator trees
module Koshucode.Baala.Base.Syntax.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
infixHeight :: Ord b => (a -> Maybe b) -> [(b, InfixHeight)] -> a -> InfixHeight

-- | Split branches in a given tree at infixed binary operators
infixToPrefix :: (a -> InfixHeight) -> CodeTree a -> Either [(InfixHeight, a)] (CodeTree a)


-- | Syntactic functions.
module Koshucode.Baala.Base.Syntax


-- | Tokenizer of koshucode.
module Koshucode.Baala.Base.Token.TokenLine

-- | Token list on a line.
type TokenLine = CodeLine Token

-- | Tokenize text.
tokenLines :: Resource -> String -> [TokenLine]

-- | Split string into list of tokens. Result token list does not contain
--   newline characters.
tokens :: Resource -> String -> [Token]
isSimpleWord :: Pred String
isSimpleChar :: Pred Char
isShortString :: String -> Bool

module Koshucode.Baala.Base.Token.Short
data Short a
Short :: [CodePoint] -> [ShortDef] -> a -> Short a
shortSource :: Short a -> [CodePoint]
shortHead :: Short a -> [ShortDef]
shortBody :: Short a -> a
type ShortDef = Named String
shortMap :: Functor f => (a -> b) -> [f a] -> [f b]
shortMapM :: Monad m => (a -> m b) -> [Short a] -> m [Short b]
shortM :: Monad m => Short (m a) -> m (Short a)
shortTrim :: Map [Short [a]]
shortEmpty :: StringMap
shortText :: [ShortDef] -> StringMap
instance Show a => Show (Short a)
instance Ord a => Ord (Short a)
instance Eq a => Eq (Short a)
instance Functor Short

module Koshucode.Baala.Base.Token.TokenClause
type TokenClause = CodeClause Token

-- | Convert token lines into token clauses
tokenClauses :: [TokenLine] -> [TokenClause]
instance Write TokenClause


-- | Parened tree of tokens
module Koshucode.Baala.Base.Token.TokenTree

-- | Tree of tokens.
type TokenTree = CodeTree Token

-- | Pair of token trees and its name.
type NamedTrees = Named [TokenTree]

-- | Parse tokens into parened trees. Blank tokens and comments are
--   excluded.
--   
--   There are four types of parens -- 1, 2, 3, or 4. Paren type is in
--   <tt>TreeB</tt> <i>type</i> <i>parens</i> <i>subtrees</i>.
--   
--   <ol>
--   <li>Round parens <tt>( .. )</tt> for grouping.</li>
--   <li>Squared brackets <tt>[ .. ]</tt> for list.</li>
--   <li>Curely braces <tt>{ .. }</tt> for termset.</li>
--   <li>Curely-bar braces <tt>{| .. |}</tt> for relation.</li>
--   </ol>
tokenTrees :: [Token] -> Ab [TokenTree]

-- | Convert text to token trees.
tt :: String -> Ab [TokenTree]
tt1 :: String -> Ab TokenTree

-- | Get <a>Doc</a> value of token trees for pretty printing.
ttDoc :: [TokenTree] -> Doc

-- | Split token list by unquoted word. If token list contains the word,
--   pair of <i>before-list</i>, <i>the-word</i> and <i>after-list</i> is
--   returned. If does not contains the word, original token list is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "b c"
--   Left [ TWord 1 0 "b", TSpace 2 1, TWord 3 0 "c" ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitTokensBy (== "|") . tokens $ "a | b | c"
--   Right ( [ TWord 1 0 "a", TSpace 2 1 ]
--           , TWord 3 0 "|"
--           , [ TSpace 4 1, TWord 5 0 "b", TSpace 6 1
--             , TWord 7 0 "|", TSpace 8 1, TWord 9 0 "c" ] )
--   </pre>
splitTokensBy :: Pred String -> [Token] -> Either [Token] ([Token], Token, [Token])
divideTreesBy :: String -> [TokenTree] -> [[TokenTree]]

-- | Divide token trees by vertical bar <tt>"|"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; divideTreesByBar . tokenTrees . tokens $ "a | b | c"
--   [ [TreeL (TWord 1 0 "a")]
--   , [TreeL (TWord 5 0 "b")]
--   , [TreeL (TWord 9 0 "c")] ]
--   </pre>
divideTreesByBar :: [TokenTree] -> [[TokenTree]]

-- | Divide token trees by colon <tt>":"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; divideTreesByColon . tokenTrees . tokens $ "a : b : c"
--   [ [TreeL (TWord 1 0 "a")]
--   , [TreeL (TWord 5 0 "b")]
--   , [TreeL (TWord 9 0 "c")] ]
--   </pre>
divideTreesByColon :: [TokenTree] -> [[TokenTree]]

-- | Same as <tt>abortable</tt> except for using <a>TokenTree</a> instead
--   of list of <a>Token</a>.
abortableTree :: String -> TokenTree -> Map (Ab b)

-- | Same as <tt>abortable</tt> except for using list of <a>TokenTree</a>
--   instead of list of <a>Token</a>.
abortableTrees :: String -> [TokenTree] -> Map (Ab b)


-- | Tokens in Koshucode.
module Koshucode.Baala.Base.Token


-- | Term names in relation.
module Koshucode.Baala.Base.Data.Term
data Term

-- | Term name for non-relation
TermFlat :: TermName -> Term

-- | Term name for relation
TermNest :: TermName -> [Term] -> Term

-- | Test that term is nested.
isTermNest :: Term -> Bool

-- | Get name part from term.
termName :: Term -> TermName

-- | Get nested part from term.
termNest :: Term -> [Term]
termExplainDoc :: Term -> Doc
showTermName :: Map String
showNestedTermName :: [String] -> String
termChange :: (Map TermName) -> Map Term
termsIndex :: [Term] -> [TermPath] -> [[Int]]

-- | Term path to term position
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [TermFlat "a", TermFlat "b", TermFlat "c"] ["b"]
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [TermFlat "a", TermFlat "b", TermFlat "c"] ["e"]
--   [-1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; termIndex [TermNest "r" [TermFlat "a", TermFlat "b"]] ["r", "b"]
--   [0, 1]
--   </pre>
termIndex :: [Term] -> TermPath -> [Int]
instance Show Term
instance Eq Term
instance Ord Term
instance Write Term
instance Name Term


-- | Judgements: a symbolic representations of affirmed or denied
--   statements.
module Koshucode.Baala.Base.Data.Judge

-- | Judgement on type <tt>c</tt>.
--   
--   Judgement (or judge for short) is divided into three parts: logical
--   quality, name of pattern, and argument. Boolean values <a>True</a> or
--   <a>False</a> of logical quality corresponds to affirmed or denied
--   judge. A name of judgement pattern represents certain sentence pattern
--   that gives intepretation of data. Sentence pattern has placeholders
--   filled by <a>Named</a> <tt>c</tt> in argument.
data Judge c
Judge :: Bool -> JudgePat -> [Named c] -> Judge c

-- | Name of judgement pattern.
type JudgePat = String

-- | Sort terms in alphabetical order.
abcJudge :: Ord c => Map (Judge c)

-- | Construct affirmed judgement.
affirm :: JudgePat -> [Named c] -> Judge c

-- | Construct denied judgement.
deny :: JudgePat -> [Named c] -> Judge c

-- | Affirm judgement, i.e., change logical quality to <a>True</a>.
affirmJudge :: Map (Judge c)

-- | Deny judgement, i.e., change logical quality to <a>False</a>.
denyJudge :: Map (Judge c)

-- | Test that judgement is affirmd.
isAffirmed :: Judge c -> Bool

-- | Test that judgement is denied.
--   
--   <pre>
--   &gt;&gt;&gt; isDenied $ Judge True "A" []
--   False
--   </pre>
isDenied :: Judge c -> Bool
instance Show c => Show (Judge c)
instance (Ord c, Write c) => Write (Judge c)
instance Functor Judge
instance Ord c => Ord (Judge c)
instance Ord c => Eq (Judge c)


-- | Output judgements.
module Koshucode.Baala.Base.Data.Output
type OutputResult c = ([OutputChunks c], [OutputChunks c])
type OutputChunks c = Short [OutputChunk c]
data OutputChunk c
OutputJudge :: [Judge c] -> OutputChunk c
OutputComment :: [String] -> OutputChunk c

-- | Print judges to <a>stdout</a>.
putJudges :: (Ord c, Write c) => Int -> [Judge c] -> IO Int
hPutJudges :: (Ord c, Write c) => Handle -> Int -> [Judge c] -> IO Int

-- | Print result of calculation, and return status.
hPutOutputResult :: (Ord c, Write c) => Handle -> OutputResult c -> IO Int
instance Show c => Show (OutputChunk c)
instance Ord c => Eq (OutputChunk c)
instance Ord c => Ord (OutputChunk c)


-- | Heading of relations
module Koshucode.Baala.Base.Data.Relhead

-- | Heading of relation as a list of terms
data Relhead
Relhead :: [Term] -> Relhead
headTerms :: Relhead -> [Term]
headExplain :: Relhead -> String
headExplainLines :: Relhead -> [String]
headExplainDoc :: Relhead -> Doc

-- | Empty heading, i.e., no terms in heading.
headEmpty :: Relhead

-- | Make head from term names.
headFrom :: [TermName] -> Relhead
headWords :: String -> Relhead

-- | List of term names.
headNames :: Relhead -> [TermName]

-- | Degree of relation, i.e., number of terms.
headDegree :: Relhead -> Int
headEquiv :: Relhead -> Relhead -> Bool
isSubhead :: Relhead -> Relhead -> Bool
isSuperhead :: Relhead -> Relhead -> Bool
headConsTerm :: Term -> Map Relhead

-- | Add term to head.
headCons :: TermName -> Map Relhead
headCons2 :: TermName2 -> Map Relhead
headCons3 :: TermName3 -> Map Relhead

-- | Add any number of terms to head.
headAppend :: [TermName] -> Map Relhead

-- | Reconstruct head.
headChange :: Map [Term] -> Map Relhead
headRename :: Map TermName -> Map Relhead

-- | Index of a term.
headIndex1 :: Relhead -> TermPath -> [Int]

-- | Indices of terms.
headIndex :: Relhead -> [TermPath] -> [[Int]]
headAlign :: Relhead -> Relhead -> Map [c]
bodyAlign :: Relhead -> Relhead -> Map [[c]]
headNested :: Relhead -> [(String, Relhead)]
instance Show Relhead
instance Eq Relhead
instance Ord Relhead
instance Write Relhead
instance Monoid Relhead


-- | Relation type
module Koshucode.Baala.Base.Data.Rel

-- | Relations on type <tt>c</tt>. Relation is consist of heading and body.
--   Body is thoretically a set of tuples, but implemented using list of
--   list.
data Rel c
Rel :: Relhead -> Relbody c -> Rel c

-- | Heading of relation
relHead :: Rel c -> Relhead

-- | Body of relation
relBody :: Rel c -> Relbody c

-- | Body of relation, i.e., a list of tuples. Tuple is list of contents.
type Relbody c = [[c]]
relSort :: Ord c => Map (Rel c)

-- | The nullary empty relation. In other words, relational constant that
--   has no terms and no tuples.
reldum :: Rel c

-- | The nullary full relation. In other words, relational constant that
--   has no terms and the empty tuple.
reldee :: Rel c

-- | The empty relation with all terms. This is fake.
reldau :: Rel c
instance Show c => Show (Rel c)
instance Ord c => Ord (Rel c)
instance Write c => Write (Rel c)
instance Ord c => Eq (Rel c)


-- | Content type for nested relations.
module Koshucode.Baala.Base.Data.Mono
data Mono a
MonoType :: a -> Mono a
MonoNest :: (Rel (Mono a)) -> Mono a
type RelText = Rel (Mono String)
isMonoType :: Mono a -> Bool
isMonoNest :: Mono a -> Bool
gMonoType :: Mono a -> a
gMonoNest :: Mono a -> Rel (Mono a)
pMonoNest :: Rel (Mono a) -> Mono a
pMonoType :: a -> Mono a
instance Show a => Show (Mono a)
instance Ord a => Eq (Mono a)
instance Ord a => Ord (Mono a)


-- | Definitions of data for Koshucode.
module Koshucode.Baala.Base.Data

module Koshucode.Baala.Base
