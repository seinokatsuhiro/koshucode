-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A notational system for relational model
--   
--   Koshucode is a notation for people and computers who read, write, and
--   calculate relational data. This library provides functions for
--   handling koshucode on computers.
@package koshucode-baala-base
@version 0.123.0.0

module Koshucode.Baala.Base.Text.Unicode
data GeneralCategoryGroup

-- | Lu Ll Lt Lm Lo
UnicodeLetter :: GeneralCategoryGroup

-- | Mn Mc Me
UnicodeMark :: GeneralCategoryGroup

-- | Nd Nl No
UnicodeNumber :: GeneralCategoryGroup

-- | Pc Pd Ps Pe Pi Pf Po
UnicodePunctuation :: GeneralCategoryGroup

-- | Sm Sc Sk So
UnicodeSymbol :: GeneralCategoryGroup

-- | Zs Zl Zp
UnicodeSeperator :: GeneralCategoryGroup

-- | Cc Cf Cs Co Cn
UnicodeOther :: GeneralCategoryGroup
generalCategoryLetter :: GeneralCategoryGroup -> Char
generalCategoryName :: GeneralCategoryGroup -> String
generalCategoryGroup :: Char -> GeneralCategoryGroup
instance Show GeneralCategoryGroup
instance Eq GeneralCategoryGroup
instance Ord GeneralCategoryGroup
instance Bounded GeneralCategoryGroup

module Koshucode.Baala.Base.Text.Comment

-- | Something that can become a string list.
class Texts a
texts :: Texts a => a -> [String]

-- | Simple document in comment.
--   
--   <pre>
--   &gt;&gt;&gt; texts $ CommentDoc [CommentSec "SAMPLE" ["This is a sample section."]]
--   [ "**"
--   , "**  SAMPLE"
--   , "**    This is a sample section."
--   , "**"
--   ]
--   </pre>
data CommentDoc
CommentDoc :: [CommentSec] -> CommentDoc

-- | Section title and its contents.
data CommentSec
CommentSec :: String -> [String] -> CommentSec
emacsModeComment :: String
commentLine :: String -> String
putCommentLines :: [String] -> IO ()
hPutCommentLines :: Handle -> [String] -> IO ()
instance Show CommentSec
instance Eq CommentSec
instance Ord CommentSec
instance Show CommentDoc
instance Eq CommentDoc
instance Ord CommentDoc
instance Texts CommentSec
instance Texts CommentDoc

module Koshucode.Baala.Base.Prelude.Import

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | Conditional execution of monadic expressions. For example,
--   
--   <pre>
--   when debug (putStr "Debugging\n")
--   </pre>
--   
--   will output the string <tt>Debugging\n</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Monad m => Bool -> m () -> m ()

-- | The reverse of <a>when</a>.
unless :: Monad m => Bool -> m () -> m ()

-- | <tt><a>guard</a> b</tt> is <tt><a>return</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>mzero</a> if <tt>b</tt> is <a>False</a>.
guard :: MonadPlus m => Bool -> m ()
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. Both lists must be
--   finite.
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: Ord a => [a] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]

-- | Test two list has no elements in common.
disjoint :: Eq a => [a] -> [a] -> Bool

-- | Test two list has some common elements.
overlap :: Eq a => [a] -> [a] -> Bool

-- | Same as <a>lookup</a> in <tt>Data.Map</tt> module.
lookupMap :: Ord k => k -> Map k a -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it just <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
fromMaybe :: a -> Maybe a -> a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)
setLocaleUtf8 :: IO ()

-- | Defines the exit codes that a program can return.
data ExitCode :: *

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <tt>Handle</tt>s <tt>stdout</tt>
--   and <tt>stderr</tt> are flushed automatically; any other buffered
--   <tt>Handle</tt>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as it it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is not an <a>IOError</a>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <tt>catch</tt> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a
exitCode :: Int -> ExitCode

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc :: *

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc
docEmpty :: Doc
docHang :: Doc -> Int -> Doc -> Doc
docZero :: String -> Doc


-- | General utilities
module Koshucode.Baala.Base.Prelude.Class

-- | Types that has name
class Name a where names = map name
name :: Name a => a -> String
names :: Name a => [a] -> [String]

-- | Entry in association list.
type Named a = (String, a)
named :: Name a => a -> Named a
type Map a = a -> a
type ManyMap a = a -> [a]
type Pred a = a -> Bool
data YesNo a
Yes :: a -> YesNo a
No :: a -> YesNo a
type Index = Int
type Collect a = [a] -> a
class Choose m
(<|>) :: Choose m => m a -> m a -> m a
instance Show a => Show (YesNo a)
instance Eq a => Eq (YesNo a)
instance Ord a => Ord (YesNo a)
instance Choose (Either a)
instance Choose Maybe

module Koshucode.Baala.Base.Prelude.List
headOr :: a -> [a] -> a

-- | Head or empty.
front :: [a] -> [a]

-- | Tails of list.
tails :: [a] -> [[a]]

-- | Test list has single element.
isSingleton :: [a] -> Bool

-- | Test list is not empty.
notNull :: [a] -> Bool
maybeEmpty :: Maybe a -> (a -> [b]) -> [b]
right :: b -> Map (Either a b)

-- | Keep duplicate elements.
duplicates :: Ord a => [a] -> [a]

-- | Remove duplicate elements.
unique :: Ord a => [a] -> [a]

-- | Union list to base list.
unionUp :: Eq a => [a] -> [a] -> [a]
intersectionFilter :: Ord a => [a] -> [a] -> [a]

-- | Make singleton list.
li1 :: a -> [a]
li2 :: a -> a -> [a]
li3 :: a -> a -> a -> [a]
consIf :: Bool -> a -> [a] -> [a]
type RangeBy a = a -> a -> [a]
rangeBy :: Ord a => Map a -> RangeBy a
zipMaybe :: [Maybe a] -> [b] -> [(a, b)]
zipMaybe2 :: [Maybe a] -> [b] -> [b]
map2 :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
mapAt :: (Map a) -> Int -> Map [a]
mapWithLast :: (a -> b) -> (a -> b) -> [a] -> [b]
omit :: (a -> Bool) -> Map [a]
filterFst :: (a -> Bool) -> Map [(a, b)]
squeeze :: (a -> Bool) -> Map [a]
squeezeEmptyLines :: Map [String]
reverseMap :: Map [a] -> Map [a]
chunks :: Int -> [a] -> [[a]]

-- | Split list by predicate. If list contains an element that satisfies
--   the predicate, <tt>(<i>before-list</i>, <i>the-element</i>,
--   <i>after-list</i>)</tt> is returned. Otherwise, original list is
--   returned.
splitBy :: (a -> Bool) -> [a] -> Either [a] ([a], a, [a])

-- | Divide list.
divide :: Eq a => a -> [a] -> [[a]]

-- | Divide list.
divideBy :: (a -> Bool) -> [a] -> [[a]]

module Koshucode.Baala.Base.Prelude.Pair
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
consFst :: a -> Map ([a], b)
consSnd :: b -> Map (a, [b])
mapFstTo :: Functor m => (a -> c) -> m (a, b) -> m (c, b)
mapSndTo :: Functor m => (b -> c) -> m (a, b) -> m (a, c)
right2 :: (Either a b, Either a c) -> Either a (b, c)
right3 :: (Either a b, Either a c, Either a d) -> Either a (b, c, d)
right4 :: (Either a b, Either a c, Either a d, Either a e) -> Either a (b, c, d, e)
sequenceFst :: Monad m => [(m a, b)] -> m [(a, b)]
sequenceSnd :: Monad m => [(a, m b)] -> m [(a, b)]


-- | Snipping elements.
module Koshucode.Baala.Base.Prelude.Snip

-- | Snipping elements using indicies.
type Snip a = [Int] -> Map [a]

-- | Snip for differenct type values.
type Snip2 a b = (Snip a, Snip b)
type Bin a = a -> a -> a
snipFull :: Eq a => [a] -> [a] -> [Int]

-- | Indices of shared elements.
snipIndex :: Eq a => [a] -> [a] -> [Int]
snipPair :: Ord a => [a] -> [a] -> ([Int], [Int])

-- | Pair of picking-up and cutting-off elements.
snipBoth :: [Int] -> [a] -> ([a], [a])

-- | Pick up indexed elements.
snipFrom :: Snip a

-- | Cut off indexed elements.
snipOff :: Snip a

-- | Move indexed elements to the front.
snipForward :: Snip a

-- | Move indexed elements to the rear.
snipBackward :: Snip a
snipForward2 :: Snip2 a b
snipBackward2 :: Snip2 a b

-- | Take left-side elements.
snipLeft :: Eq a => Bin [a]

-- | Take shared elements.
snipShare :: Eq a => Bin [a]

-- | Take right-side elements.
snipRight :: Eq a => Bin [a]
snipOrder :: Eq a => [a] -> [a] -> Map [c]

-- | Check lengths of two lists are same.
sameLength :: [a] -> [b] -> Bool
notSameLength :: [a] -> [b] -> Bool

-- | Check elements in the first list are non-negative, and elements in the
--   second are negative.
(+-) :: [Int] -> [Int] -> Bool

module Koshucode.Baala.Base.Prelude.Order
data OrderCap a
Asc :: a -> OrderCap a
Desc :: a -> OrderCap a
type Ranking n a = Int -> [OrderCap n] -> [n] -> [[a]] -> ([Int], [[a]])
sortByName :: (Ord a, Eq n) => [OrderCap n] -> [n] -> Map [[a]]
sortByNameDenseRank :: (Ord a, Eq n) => Ranking n a
sortByNameGapRank :: (Ord a, Eq n) => Ranking n a
sortByNameNumbering :: (Ord a, Eq n) => Ranking n a
denseRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
gapRankFrom :: (Ord a, Integral r) => r -> [a] -> [r]
sortWith :: (Ord a, Ord b) => (a -> b) -> [a] -> [a]
instance Show a => Show (OrderCap a)
instance Eq a => Eq (OrderCap a)
instance Ord a => Ord (OrderCap a)


-- | Utilities for association lists.
module Koshucode.Baala.Base.Prelude.Assoc
type Lookup a = String -> Maybe a

-- | Construct assoc list by splitting base list.
assocBy :: (a -> Maybe k) -> [a] -> ([a], [(k, [a])])

-- | Check which given key is there in assoc list.
assocExist :: Eq k => k -> [(k, a)] -> Bool
namedMapM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
lookupBy :: (a -> Bool) -> [(a, b)] -> Maybe b

-- | Lookup assoc list that keys are truth-valued functions.
lookupSatisfy :: a -> [(a -> Bool, b)] -> Maybe b
assocFinder :: Ord k => [(k, v)] -> k -> Maybe v

-- | Pick up associations that have given keys.
assocPick :: Eq k => [k] -> Map [(k, a)]

-- | Cut off associations that have given keys.
assocCut :: Eq k => [k] -> Map [(k, a)]
assocCut1 :: Eq k => k -> Map [(k, a)]
assocRename1 :: Eq k => k -> k -> Map [(k, a)]
assocRehead :: Eq k => [(k, k)] -> [(k, v)] -> [(k, v)]
data OnceMore a
Once :: a -> OnceMore a
More :: [a] -> OnceMore a

-- | Convert general assoc list into once/more assoc list.
assocGather :: Eq k => [(k, a)] -> [(k, OnceMore a)]

-- | Push key and value into once/more assoc list.
assocPush :: Eq k => k -> a -> Map [(k, OnceMore a)]

-- | Extract once part from once/more assoc list.
assocOnce :: [(k, OnceMore a)] -> [(k, a)]

-- | Extract more part from once/more assoc list.
assocMore :: [(k, OnceMore a)] -> [(k, [a])]
type Gather a b = a -> (b, a)

-- | Gather what is gotten by splitter.
gather :: Gather [a] b -> [a] -> [b]
gatherWith :: (c -> Gather [a] b) -> [c] -> [a] -> [b]

-- | Gather (<i>key</i>, <i>value</i>) to <tt>Map</tt> <i>key</i>
--   [<i>value</i>].
gatherToMap :: Ord k => [(k, v)] -> Map k [v]
gatherToAssoc :: Ord k => [(k, v)] -> [(k, [v])]
instance Show a => Show (OnceMore a)
instance Eq a => Eq (OnceMore a)
instance Ord a => Ord (OnceMore a)

module Koshucode.Baala.Base.Prelude

module Koshucode.Baala.Base.Text.IOPoint
data IOPoint

-- | Context directory and target path
IOPointFile :: FilePath -> FilePath -> IOPoint

-- | Universal resource identifier
IOPointUri :: String -> IOPoint

-- | Code itself
IOPointText :: (Maybe String) -> String -> IOPoint

-- | Sandard input
IOPointStdin :: IOPoint

-- | Sandard output
IOPointStdout :: IOPoint

-- | Name of I/O point, i.e., <tt>"file"</tt>, <tt>"url"</tt>,
--   <tt>"text"</tt>, <tt>"stdin"</tt>, or <tt>"stdout"</tt>.
ioPointType :: IOPoint -> String
ioPointText :: IOPoint -> String
ioPointFrom :: FilePath -> FilePath -> IOPoint

-- | Create I/O points from using stdin, texts itself, filenames, and urls.
ioPointList :: Bool -> [String] -> FilePath -> [FilePath] -> [IOPoint]
data CodePiece
CodePiece :: Int -> IOPoint -> CodePiece
codeNumber :: CodePiece -> Int
codeName :: CodePiece -> IOPoint

-- | Empty code.
codeEmpty :: CodePiece

-- | Create text code.
codeTextOf :: String -> CodePiece
instance Typeable IOPoint
instance Typeable CodePiece
instance Show IOPoint
instance Eq IOPoint
instance Ord IOPoint
instance Data IOPoint
instance Show CodePiece
instance Data CodePiece
instance Ord CodePiece
instance Eq CodePiece

module Koshucode.Baala.Base.Text.CodePt
data CodePt
CodePt :: CodePiece -> Int -> String -> String -> CodePt

-- | Source of code
codePtSource :: CodePt -> CodePiece

-- | Line number
codePtLineNo :: CodePt -> Int

-- | Line content
codePtLineText :: CodePt -> String

-- | Text at which begins token
codePtText :: CodePt -> String

-- | Empty code point, i.e., empty content and zero line number.
codePtZero :: CodePt

-- | Column number at which code starts.
codePtColumnNo :: CodePt -> Int
codePtDisplay :: (String, CodePt) -> [(String, String)]
class CodePtr a where codePt p = headOr codePtZero $ codePtList p
codePtList :: CodePtr a => a -> [CodePt]
codePt :: CodePtr a => a -> CodePt
data Sourced a
Sourced :: [CodePt] -> a -> Sourced a
source :: Sourced a -> [CodePt]
unsourced :: Sourced a -> a
instance Typeable CodePt
instance Typeable Sourced
instance Show CodePt
instance Eq CodePt
instance Data CodePt
instance Show a => Show (Sourced a)
instance Eq a => Eq (Sourced a)
instance Ord a => Ord (Sourced a)
instance Data a => Data (Sourced a)
instance CodePtr (Sourced a)
instance Functor Sourced
instance CodePtr CodePt
instance Ord CodePt


-- | Text table
module Koshucode.Baala.Base.Text.TextTable
data Position
Front :: Position
Middle :: Position
Rear :: Position
textPos :: String -> [Position]
data Cell
Cell :: [String] -> Int -> Int -> Position -> Char -> Cell
cellText :: Cell -> [String]
cellWidth :: Cell -> Int
cellHeight :: Cell -> Int
cellPos :: Cell -> Position
cellPad :: Cell -> Char
textTable :: [Position] -> [[String]] -> [[Cell]]
textTableWithHead :: [Position] -> Char -> [String] -> [[String]] -> [[Cell]]
textCell :: Position -> String -> Cell
textRuleCell :: Char -> Cell
textBlockCell :: Position -> [String] -> Cell
textBlockCellPlus :: Int -> Position -> [String] -> Cell
alignTable :: [[Cell]] -> [[Cell]]
renderTable :: String -> [[Cell]] -> [String]
instance Show Position
instance Eq Position
instance Ord Position
instance Show Cell
instance Eq Cell
instance Ord Cell

module Koshucode.Baala.Base.Text.Utility
trimLeft :: Map String
trimRight :: Map String
trimBoth :: Map String

-- | Add spaces to right.
--   
--   <pre>
--   &gt;&gt;&gt; padRight 10 "abc"
--   "abc       "
--   </pre>
padRight :: Int -> Map String

-- | Add spaces to left.
--   
--   <pre>
--   &gt;&gt;&gt; padLeft 10 "abc"
--   "       abc"
--   </pre>
padLeft :: Int -> Map String
stringWidth :: String -> Int
putShow :: Show a => a -> IO ()
putShowLn :: Show a => a -> IO ()
putLines :: [String] -> IO ()
hPutLines :: Handle -> [String] -> IO ()
hPutEmptyLine :: Handle -> IO ()
readInt :: String -> Maybe Int
readInteger :: String -> Maybe Integer

module Koshucode.Baala.Base.Text.Http
type UriText = String

-- | Pair of protocol name and proxy URI.
type HttpProxy = (String, Maybe UriText)
uriContent :: [HttpProxy] -> UriText -> IO (Either (Int, String) String)
httpExceptionSummary :: HttpException -> String

module Koshucode.Baala.Base.Text.Write

-- | Mapping from string to string.
type StringMap = Map String

-- | Writer with string mapping.
class Write a where writeStringWith sh a = show $ writeDocWith sh a writeHtmlWith sh a = toHtml $ writeStringWith sh a
writeDocWith :: Write a => StringMap -> a -> Doc
writeStringWith :: Write a => StringMap -> a -> String
writeHtmlWith :: Write a => StringMap -> a -> Html
writeDoc :: Write a => a -> Doc
writeString :: Write a => a -> String
writeHtml :: Write a => a -> Html
class ToMarkup a
toMarkup :: ToMarkup a => a -> Markup
toMarkup :: ToMarkup a => a -> Markup
toHtml :: ToMarkup a => a -> Html
div :: Html -> Html
div_ :: AttributeValue -> Map Html
span :: Html -> Html
span_ :: AttributeValue -> Map Html
renderHtmlIndented :: Html -> String
renderHtmlCompact :: Html -> String
writeH :: Write a => StringMap -> [a] -> Doc
writeV :: Write a => StringMap -> [a] -> Doc
writeColon :: Write a => StringMap -> [a] -> Doc
writeBar :: Write a => StringMap -> [a] -> Doc
writeSep :: Write a => String -> StringMap -> [a] -> Doc
writeSepsWith :: Write a => (a -> Doc) -> String -> [a] -> [Doc]
writeTerm :: (a -> Doc) -> Named a -> Doc
writeTerms :: (a -> Doc) -> [Named a] -> Doc
doc :: Write a => a -> Doc
doch :: Write a => [a] -> Doc
docv :: Write a => [a] -> Doc
docWrap :: Write a => String -> String -> a -> Doc
docWraps :: Write a => String -> String -> a -> Doc
doc02 :: Int -> Doc
docConcat :: String -> Bin Doc
instance Write a => Write (Named a)
instance Write Bool
instance Write String
instance Write Integer
instance Write Int
instance Write Doc

module Koshucode.Baala.Base.Text


-- | Abort reasons.
module Koshucode.Baala.Base.Abort.Reason
data AbortReason
AbortReason :: String -> [String] -> [String] -> [(String, CodePt)] -> AbortReason

-- | Reason in one line
abortReason :: AbortReason -> String

-- | Detailed description
abortDetail :: AbortReason -> [String]

-- | Additional notes for long description
abortNote :: AbortReason -> [String]

-- | Tag and aborting point
abortPoint :: AbortReason -> [(String, CodePt)]

-- | Abortable result, i.e., either of right result or abort reason.
type Ab a = Either AbortReason a

-- | Abortable mapping.
type AbMap a = a -> Ab a
type AbManyMap a = a -> Ab [a]
type AbPred a = a -> Ab Bool
type IOAb a = IO (Ab a)

-- | Construct abort reason with reason text.
abortBecause :: String -> AbortReason

-- | Construct abort reason with reason and detailed text.
abortLine :: String -> String -> AbortReason

-- | Construct abort reason with reason and multilined detailed text.
abortLines :: String -> [String] -> AbortReason

-- | Construct abort reason with reason and note.
abortPage :: String -> [String] -> AbortReason
instance Show AbortReason
instance Eq AbortReason
instance Ord AbortReason
instance ToMarkup AbortReason


-- | Abortable process
module Koshucode.Baala.Base.Abort.Abortable

-- | Push source information when process is aborted.
abortable :: CodePtr p => String -> [p] -> Map (Ab b)
abortableSourced :: String -> (a -> Ab b) -> Sourced a -> Ab (Sourced b)


-- | Reporting abort reasons.
module Koshucode.Baala.Base.Abort.Report

-- | Command name and its arguments.
type CommandLine = [String]

-- | Stop program execution abnormally.
abort :: CommandLine -> AbortReason -> IO x

-- | Print abort message.
abortPrint :: CommandLine -> AbortReason -> IO ()

-- | Convert abort reason to message lines.
abortMessage :: CommandLine -> AbortReason -> [String]

-- | Stop on error <tt>'BUG DISCOVERED'</tt>
bug :: String -> a


-- | Abort symbols
module Koshucode.Baala.Base.Abort

module Koshucode.Baala.Base.Abort.Message

-- | AD-LIB: reason
adlib :: String -> Ab a

-- | BUG: reason
bug :: String -> Ab a

-- | Unsupported feature
unsupported :: String -> Ab a

module Koshucode.Baala.Base.Syntax.Message
abCode :: CodePtr cp => [cp] -> Map (Ab b)

-- | Extra close bracket
extraCloseBracket :: Ab a

-- | Unclosed open bracket
extraOpenBracket :: Ab a

module Koshucode.Baala.Base.Message


-- | Text lines delimited by carriage returns or line feeds.
module Koshucode.Baala.Base.Syntax.Line

-- | Line number.
type LineNumber = Int

-- | Line with number.
type NumberedLine = (LineNumber, String)

-- | Line number and its content.
linesCrlfNumbered :: String -> [NumberedLine]

-- | Split string into lines. The result strings do not contain carriage
--   returns (<tt>\r</tt>) and line feeds (<tt>\n</tt>).
linesCrlf :: String -> [String]
linesFrom :: Show a => a -> [String]

-- | Tokens in line.
data CodeLine a
CodeLine :: LineNumber -> String -> [a] -> CodeLine a

-- | Line number, from 1.
lineNumber :: CodeLine a -> LineNumber

-- | Line content without newline.
lineContent :: CodeLine a -> String

-- | Tokens in the line.
lineTokens :: CodeLine a -> [a]
type IndentSize = Int
lineIndentPair :: (a -> IndentSize) -> CodeLine a -> (IndentSize, CodeLine a)
data CodeRoll a
CodeRoll :: AbMap (CodeRoll a) -> CodePt -> String -> [a] -> WordTable -> CodeRoll a
codeMap :: CodeRoll a -> AbMap (CodeRoll a)
codeInputPt :: CodeRoll a -> CodePt
codeInput :: CodeRoll a -> String
codeOutput :: CodeRoll a -> [a]
codeWords :: CodeRoll a -> WordTable
type WordTable = Map String String

-- | Split source text into <a>CodeLine</a> list.
--   
--   <ol>
--   <li>Split source text into lines by line delimiters (carriage return
--   <tt>\r</tt> or line feed <tt>\n</tt>).</li>
--   <li>Numbering lines from 1. Internally, this is represented as a list
--   of pairs <tt>(</tt><a>LineNumber</a><tt>,</tt>
--   <a>String</a><tt>)</tt>.</li>
--   <li>Tokenize each lines, and put tokens together in
--   <a>CodeLine</a>.</li>
--   </ol>
codeRollUp :: AbMap (CodeRoll a) -> CodePiece -> String -> Ab [CodeLine a]

-- | Update <a>codeInput</a> and push result element to <a>codeOutput</a>.
codeUpdate :: String -> a -> Map (CodeRoll a)
codeUpdateWords :: WordTable -> String -> a -> Map (CodeRoll a)

-- | Change mapper of code roll.
codeChange :: AbMap (CodeRoll a) -> Map (CodeRoll a)
instance Typeable CodeLine
instance Show a => Show (CodeLine a)
instance Eq a => Eq (CodeLine a)
instance Ord a => Ord (CodeLine a)
instance Data a => Data (CodeLine a)
instance CodePtr a => CodePtr (CodeLine a)
instance Write (CodeLine a)


-- | This module provides a container for tokens. No tokens in Koshucode
--   are in a extent of multiple lines. <tt>CodeLine</tt> includes whole
--   tokens in a line. You can represent tokenized source code as a list of
--   <tt>CodeLine</tt>.
module Koshucode.Baala.Base.Syntax.Clause

-- | Tokens in clause.
data CodeClause a
CodeClause :: [CodeLine a] -> [a] -> CodeClause a

-- | Source lines of clause
clauseLines :: CodeClause a -> [CodeLine a]

-- | Source tokens of clause
clauseTokens :: CodeClause a -> [a]

-- | Clause with no tokens.
codeClauseEmpty :: CodeClause a
splitClause :: Gather [(IndentSize, a)] [a]
instance Typeable CodeClause
instance Show a => Show (CodeClause a)
instance Data a => Data (CodeClause a)
instance CodePtr a => CodePtr (CodeClause a)

module Koshucode.Baala.Base.Syntax.Tree

-- | Tree of leaf and branch.
data CodeTree p a

-- | Terminal of tree.
TreeL :: a -> CodeTree p a

-- | Bracket-type and subtrees.
TreeB :: p -> (Maybe (a, a)) -> [CodeTree p a] -> CodeTree p a

-- | Convert a list of elements to a single tree.
tree :: (Ord p, CodePtr a) => GetBracketType p a -> Bracket p -> p -> [a] -> Ab (CodeTree p a)

-- | Convert a list of elements to trees.
trees :: (Ord p, CodePtr a) => GetBracketType p a -> Bracket p -> [a] -> Ab [CodeTree p a]
treeWrap :: p -> [CodeTree p a] -> CodeTree p a

-- | Convert tree to list of tokens.
untree :: CodeTree p a -> [a]

-- | Convert tree to list of tokens.
untrees :: [CodeTree p a] -> [a]
leaves :: CodeTree p a -> [a]

-- | Simplify tree by removing double brackets, like <tt>((a))</tt> to
--   <tt>(a)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; undouble (== 0) $ TreeB 0 Nothing [TreeB 0 Nothing [TreeL "A", TreeL "B"]]
--   TreeB 0 Nothing [TreeL "A", TreeL "B"]
--   </pre>
undouble :: Pred p -> Map (CodeTree p a)
mapToLeaf :: (a -> a) -> Map (CodeTree p a)

-- | Bracket type.
data Bracket p

-- | None bracket
BracketNone :: Bracket p

-- | Open bracket
BracketOpen :: p -> Bracket p

-- | Close bracket
BracketClose :: p -> Bracket p

-- | Get a bracket type.
type GetBracketType p a = a -> Bracket p

-- | Make <a>GetBracketType</a> functions from a type-open-close table.
--   
--   Make bracket/type functions from <tt>()</tt> and <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let bracket n [a, b] = (n, (== a), (== b))
--   
--   &gt;&gt;&gt; let pt = bracketTable [ bracket 1 "()", bracket 2 "[]" ]
--   </pre>
--   
--   Get bracket types for each chars. Types of open brackets are positive
--   integer, and closes are negative.
--   
--   <pre>
--   &gt;&gt;&gt; map pt "ab(cd[ef])g"
--   [0, 0, 1, 0, 0, 2, 0, 0, -2, -1, 0]
--   </pre>
bracketTable :: Eq a => [(p, Pred a, Pred a)] -> GetBracketType p a
instance Typeable CodeTree
instance Typeable Bracket
instance (Show p, Show a) => Show (CodeTree p a)
instance (Eq p, Eq a) => Eq (CodeTree p a)
instance (Ord p, Ord a) => Ord (CodeTree p a)
instance (Data p, Data a) => Data (CodeTree p a)
instance Show p => Show (Bracket p)
instance Eq p => Eq (Bracket p)
instance Ord p => Ord (Bracket p)
instance Data p => Data (Bracket p)
instance Functor (CodeTree p)


-- | Convert infixed-operator trees into prefixed-operator trees.
module Koshucode.Baala.Base.Syntax.Infix

-- | Direction and height for binary splitting.
--   
--   <ul>
--   <li><i><tt>Left</tt> <i>H</i></i> Splits first the left-most operator,
--   and operator height is <i>H</i>. For example, if the operator
--   <tt>:</tt> is of <tt>Left 5</tt>, an expression <tt>(a : b : c)</tt>
--   is splitted into <tt>(: a (b : c))</tt> and then <tt>(: a (: b
--   c))</tt>.</li>
--   <li><i><tt>Right</tt> <i>H</i></i> Right-most splitting and height
--   <i>H</i>. For example, if the operator <tt>.</tt> is of <tt>Right
--   3</tt>, an expression <tt>(a . b . c)</tt> is splitted into <tt>(. (a
--   . b) c)</tt> and then <tt>(. (. a b) c)</tt>. An expression <tt>(a . b
--   : c)</tt> is into <tt>(: (a . b) c)</tt>, and then <tt>(: (. a b)
--   c)</tt>. Symbols that is not a binary operator like <tt>b</tt> are of
--   height 0. For that reason, heights of expression <tt>(a . b : c)</tt>
--   are <tt>(0 3 0 5 0)</tt></li>
--   </ul>
type InfixHeight = Either Int Int

-- | Make the height function from a height table of operators.
infixHeight :: Ord b => (a -> Maybe b) -> [(b, InfixHeight)] -> a -> InfixHeight

-- | Split branches in a given tree at infixed binary operators.
infixToPrefix :: (Map a, Map a, Map a) -> (a -> InfixHeight) -> Collect (InfixTree p a) -> InfixMapper p a -> InfixAbMap a (CodeTree p a)
type InfixAb a x = Either [(InfixHeight, a)] x
type InfixAbMap a x = x -> InfixAb a x
type InfixTree p a = CodeTree p (InfixHeight, a)
type InfixMapper p a = InfixAbMap a [InfixTree p a] -> InfixAbMap a (InfixTree p a)


-- | Syntactic functions.
module Koshucode.Baala.Base.Syntax

module Koshucode.Baala.Base
